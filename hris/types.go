// This file was auto-generated by Fern from our API Definition.

package hris

import (
	json "encoding/json"
	fmt "fmt"
	strconv "strconv"
	time "time"
)

type AccountDetails struct {
	Id                      *string       `json:"id,omitempty"`
	Integration             *string       `json:"integration,omitempty"`
	IntegrationSlug         *string       `json:"integration_slug,omitempty"`
	Category                *CategoryEnum `json:"category,omitempty"`
	EndUserOriginId         *string       `json:"end_user_origin_id,omitempty"`
	EndUserOrganizationName *string       `json:"end_user_organization_name,omitempty"`
	EndUserEmailAddress     *string       `json:"end_user_email_address,omitempty"`
	Status                  *string       `json:"status,omitempty"`
	WebhookListenerUrl      *string       `json:"webhook_listener_url,omitempty"`
	// Whether a Production Linked Account's credentials match another existing Production Linked Account. This field is `null` for Test Linked Accounts, incomplete Production Linked Accounts, and ignored duplicate Production Linked Account sets.
	IsDuplicate *bool   `json:"is_duplicate,omitempty"`
	AccountType *string `json:"account_type,omitempty"`
}

// # The LinkedAccount Object
//
// ### Description
//
// The `LinkedAccount` object is used to represent an end user's link with a specific integration.
//
// ### Usage Example
//
// View a list of your organization's `LinkedAccount` objects.
type AccountDetailsAndActions struct {
	Id                      string                             `json:"id"`
	Category                *CategoryEnum                      `json:"category,omitempty"`
	Status                  AccountDetailsAndActionsStatusEnum `json:"status,omitempty"`
	StatusDetail            *string                            `json:"status_detail,omitempty"`
	EndUserOriginId         *string                            `json:"end_user_origin_id,omitempty"`
	EndUserOrganizationName string                             `json:"end_user_organization_name"`
	EndUserEmailAddress     string                             `json:"end_user_email_address"`
	WebhookListenerUrl      string                             `json:"webhook_listener_url"`
	// Whether a Production Linked Account's credentials match another existing Production Linked Account. This field is `null` for Test Linked Accounts, incomplete Production Linked Accounts, and ignored duplicate Production Linked Account sets.
	IsDuplicate *bool                                `json:"is_duplicate,omitempty"`
	Integration *AccountDetailsAndActionsIntegration `json:"integration,omitempty"`
	AccountType string                               `json:"account_type"`
}

type AccountDetailsAndActionsIntegration struct {
	Name                     string            `json:"name"`
	Categories               []CategoriesEnum  `json:"categories,omitempty"`
	Image                    *string           `json:"image,omitempty"`
	SquareImage              *string           `json:"square_image,omitempty"`
	Color                    string            `json:"color"`
	Slug                     string            `json:"slug"`
	PassthroughAvailable     bool              `json:"passthrough_available"`
	AvailableModelOperations []*ModelOperation `json:"available_model_operations,omitempty"`
}

// - `COMPLETE` - COMPLETE
// - `INCOMPLETE` - INCOMPLETE
// - `RELINK_NEEDED` - RELINK_NEEDED
type AccountDetailsAndActionsStatusEnum uint

const (
	AccountDetailsAndActionsStatusEnumComplete AccountDetailsAndActionsStatusEnum = iota + 1
	AccountDetailsAndActionsStatusEnumIncomplete
	AccountDetailsAndActionsStatusEnumRelinkNeeded
)

func (a AccountDetailsAndActionsStatusEnum) String() string {
	switch a {
	default:
		return strconv.Itoa(int(a))
	case AccountDetailsAndActionsStatusEnumComplete:
		return "COMPLETE"
	case AccountDetailsAndActionsStatusEnumIncomplete:
		return "INCOMPLETE"
	case AccountDetailsAndActionsStatusEnumRelinkNeeded:
		return "RELINK_NEEDED"
	}
}

func (a AccountDetailsAndActionsStatusEnum) MarshalJSON() ([]byte, error) {
	return []byte(fmt.Sprintf("%q", a.String())), nil
}

func (a *AccountDetailsAndActionsStatusEnum) UnmarshalJSON(data []byte) error {
	var raw string
	if err := json.Unmarshal(data, &raw); err != nil {
		return err
	}
	switch raw {
	case "COMPLETE":
		value := AccountDetailsAndActionsStatusEnumComplete
		*a = value
	case "INCOMPLETE":
		value := AccountDetailsAndActionsStatusEnumIncomplete
		*a = value
	case "RELINK_NEEDED":
		value := AccountDetailsAndActionsStatusEnumRelinkNeeded
		*a = value
	}
	return nil
}

type AccountIntegration struct {
	// Company name.
	Name string `json:"name"`
	// Category or categories this integration belongs to. Multiple categories should be comma separated, i.e. [ats, hris].
	Categories []CategoriesEnum `json:"categories,omitempty"`
	// Company logo in rectangular shape. <b>Upload an image with a clear background.</b>
	Image *string `json:"image,omitempty"`
	// Company logo in square shape. <b>Upload an image with a white background.</b>
	SquareImage *string `json:"square_image,omitempty"`
	// The color of this integration used for buttons and text throughout the app and landing pages. <b>Choose a darker, saturated color.</b>
	Color *string `json:"color,omitempty"`
	Slug  *string `json:"slug,omitempty"`
	// If checked, this integration will not appear in the linking flow, and will appear elsewhere with a Beta tag.
	IsInBeta *bool `json:"is_in_beta,omitempty"`
	// Mapping of API endpoints to documentation urls for support. Example: {'GET': [['/common-model-scopes', 'https://docs.merge.dev/accounting/common-model-scopes/#common_model_scopes_retrieve'],['/common-model-actions', 'https://docs.merge.dev/accounting/common-model-actions/#common_model_actions_retrieve']], 'POST': []}
	ApiEndpointsToDocumentationUrls map[string]any `json:"api_endpoints_to_documentation_urls,omitempty"`
	// Setup guide URL for third party webhook creation. Exposed in Merge Docs.
	WebhookSetupGuideUrl *string `json:"webhook_setup_guide_url,omitempty"`
}

type AccountToken struct {
	AccountToken string              `json:"account_token"`
	Integration  *AccountIntegration `json:"integration,omitempty"`
}

// - `SAVINGS` - SAVINGS
// - `CHECKING` - CHECKING
type AccountTypeEnum uint

const (
	AccountTypeEnumSavings AccountTypeEnum = iota + 1
	AccountTypeEnumChecking
)

func (a AccountTypeEnum) String() string {
	switch a {
	default:
		return strconv.Itoa(int(a))
	case AccountTypeEnumSavings:
		return "SAVINGS"
	case AccountTypeEnumChecking:
		return "CHECKING"
	}
}

func (a AccountTypeEnum) MarshalJSON() ([]byte, error) {
	return []byte(fmt.Sprintf("%q", a.String())), nil
}

func (a *AccountTypeEnum) UnmarshalJSON(data []byte) error {
	var raw string
	if err := json.Unmarshal(data, &raw); err != nil {
		return err
	}
	switch raw {
	case "SAVINGS":
		value := AccountTypeEnumSavings
		*a = value
	case "CHECKING":
		value := AccountTypeEnumChecking
		*a = value
	}
	return nil
}

type AsyncPassthroughReciept struct {
	AsyncPassthroughReceiptId string `json:"async_passthrough_receipt_id"`
}

type AuditLogEvent struct {
	Id *string `json:"id,omitempty"`
	// The User's full name at the time of this Event occurring.
	UserName *string `json:"user_name,omitempty"`
	// The User's email at the time of this Event occurring.
	UserEmail *string `json:"user_email,omitempty"`
	// Designates the role of the user (or SYSTEM/API if action not taken by a user) at the time of this Event occurring.
	//
	// - `ADMIN` - ADMIN
	// - `DEVELOPER` - DEVELOPER
	// - `MEMBER` - MEMBER
	// - `API` - API
	// - `SYSTEM` - SYSTEM
	// - `MERGE_TEAM` - MERGE_TEAM
	Role      *AuditLogEventRole `json:"role,omitempty"`
	IpAddress string             `json:"ip_address"`
	// Designates the type of event that occurred.
	//
	// - `CREATED_REMOTE_PRODUCTION_API_KEY` - CREATED_REMOTE_PRODUCTION_API_KEY
	// - `DELETED_REMOTE_PRODUCTION_API_KEY` - DELETED_REMOTE_PRODUCTION_API_KEY
	// - `CREATED_TEST_API_KEY` - CREATED_TEST_API_KEY
	// - `DELETED_TEST_API_KEY` - DELETED_TEST_API_KEY
	// - `REGENERATED_PRODUCTION_API_KEY` - REGENERATED_PRODUCTION_API_KEY
	// - `INVITED_USER` - INVITED_USER
	// - `TWO_FACTOR_AUTH_ENABLED` - TWO_FACTOR_AUTH_ENABLED
	// - `TWO_FACTOR_AUTH_DISABLED` - TWO_FACTOR_AUTH_DISABLED
	// - `DELETED_LINKED_ACCOUNT` - DELETED_LINKED_ACCOUNT
	// - `CREATED_DESTINATION` - CREATED_DESTINATION
	// - `DELETED_DESTINATION` - DELETED_DESTINATION
	// - `CHANGED_SCOPES` - CHANGED_SCOPES
	// - `CHANGED_PERSONAL_INFORMATION` - CHANGED_PERSONAL_INFORMATION
	// - `CHANGED_ORGANIZATION_SETTINGS` - CHANGED_ORGANIZATION_SETTINGS
	// - `ENABLED_INTEGRATION` - ENABLED_INTEGRATION
	// - `DISABLED_INTEGRATION` - DISABLED_INTEGRATION
	// - `ENABLED_CATEGORY` - ENABLED_CATEGORY
	// - `DISABLED_CATEGORY` - DISABLED_CATEGORY
	// - `CHANGED_PASSWORD` - CHANGED_PASSWORD
	// - `RESET_PASSWORD` - RESET_PASSWORD
	// - `ENABLED_REDACT_UNMAPPED_DATA_FOR_ORGANIZATION` - ENABLED_REDACT_UNMAPPED_DATA_FOR_ORGANIZATION
	// - `ENABLED_REDACT_UNMAPPED_DATA_FOR_LINKED_ACCOUNT` - ENABLED_REDACT_UNMAPPED_DATA_FOR_LINKED_ACCOUNT
	// - `DISABLED_REDACT_UNMAPPED_DATA_FOR_ORGANIZATION` - DISABLED_REDACT_UNMAPPED_DATA_FOR_ORGANIZATION
	// - `DISABLED_REDACT_UNMAPPED_DATA_FOR_LINKED_ACCOUNT` - DISABLED_REDACT_UNMAPPED_DATA_FOR_LINKED_ACCOUNT
	// - `CREATED_INTEGRATION_WIDE_FIELD_MAPPING` - CREATED_INTEGRATION_WIDE_FIELD_MAPPING
	// - `CREATED_LINKED_ACCOUNT_FIELD_MAPPING` - CREATED_LINKED_ACCOUNT_FIELD_MAPPING
	// - `CHANGED_INTEGRATION_WIDE_FIELD_MAPPING` - CHANGED_INTEGRATION_WIDE_FIELD_MAPPING
	// - `CHANGED_LINKED_ACCOUNT_FIELD_MAPPING` - CHANGED_LINKED_ACCOUNT_FIELD_MAPPING
	// - `DELETED_INTEGRATION_WIDE_FIELD_MAPPING` - DELETED_INTEGRATION_WIDE_FIELD_MAPPING
	// - `DELETED_LINKED_ACCOUNT_FIELD_MAPPING` - DELETED_LINKED_ACCOUNT_FIELD_MAPPING
	EventType        *AuditLogEventEventType `json:"event_type,omitempty"`
	EventDescription string                  `json:"event_description"`
	CreatedAt        *time.Time              `json:"created_at,omitempty"`
}

// Designates the type of event that occurred.
//
// - `CREATED_REMOTE_PRODUCTION_API_KEY` - CREATED_REMOTE_PRODUCTION_API_KEY
// - `DELETED_REMOTE_PRODUCTION_API_KEY` - DELETED_REMOTE_PRODUCTION_API_KEY
// - `CREATED_TEST_API_KEY` - CREATED_TEST_API_KEY
// - `DELETED_TEST_API_KEY` - DELETED_TEST_API_KEY
// - `REGENERATED_PRODUCTION_API_KEY` - REGENERATED_PRODUCTION_API_KEY
// - `INVITED_USER` - INVITED_USER
// - `TWO_FACTOR_AUTH_ENABLED` - TWO_FACTOR_AUTH_ENABLED
// - `TWO_FACTOR_AUTH_DISABLED` - TWO_FACTOR_AUTH_DISABLED
// - `DELETED_LINKED_ACCOUNT` - DELETED_LINKED_ACCOUNT
// - `CREATED_DESTINATION` - CREATED_DESTINATION
// - `DELETED_DESTINATION` - DELETED_DESTINATION
// - `CHANGED_SCOPES` - CHANGED_SCOPES
// - `CHANGED_PERSONAL_INFORMATION` - CHANGED_PERSONAL_INFORMATION
// - `CHANGED_ORGANIZATION_SETTINGS` - CHANGED_ORGANIZATION_SETTINGS
// - `ENABLED_INTEGRATION` - ENABLED_INTEGRATION
// - `DISABLED_INTEGRATION` - DISABLED_INTEGRATION
// - `ENABLED_CATEGORY` - ENABLED_CATEGORY
// - `DISABLED_CATEGORY` - DISABLED_CATEGORY
// - `CHANGED_PASSWORD` - CHANGED_PASSWORD
// - `RESET_PASSWORD` - RESET_PASSWORD
// - `ENABLED_REDACT_UNMAPPED_DATA_FOR_ORGANIZATION` - ENABLED_REDACT_UNMAPPED_DATA_FOR_ORGANIZATION
// - `ENABLED_REDACT_UNMAPPED_DATA_FOR_LINKED_ACCOUNT` - ENABLED_REDACT_UNMAPPED_DATA_FOR_LINKED_ACCOUNT
// - `DISABLED_REDACT_UNMAPPED_DATA_FOR_ORGANIZATION` - DISABLED_REDACT_UNMAPPED_DATA_FOR_ORGANIZATION
// - `DISABLED_REDACT_UNMAPPED_DATA_FOR_LINKED_ACCOUNT` - DISABLED_REDACT_UNMAPPED_DATA_FOR_LINKED_ACCOUNT
// - `CREATED_INTEGRATION_WIDE_FIELD_MAPPING` - CREATED_INTEGRATION_WIDE_FIELD_MAPPING
// - `CREATED_LINKED_ACCOUNT_FIELD_MAPPING` - CREATED_LINKED_ACCOUNT_FIELD_MAPPING
// - `CHANGED_INTEGRATION_WIDE_FIELD_MAPPING` - CHANGED_INTEGRATION_WIDE_FIELD_MAPPING
// - `CHANGED_LINKED_ACCOUNT_FIELD_MAPPING` - CHANGED_LINKED_ACCOUNT_FIELD_MAPPING
// - `DELETED_INTEGRATION_WIDE_FIELD_MAPPING` - DELETED_INTEGRATION_WIDE_FIELD_MAPPING
// - `DELETED_LINKED_ACCOUNT_FIELD_MAPPING` - DELETED_LINKED_ACCOUNT_FIELD_MAPPING
type AuditLogEventEventType struct {
	typeName      string
	EventTypeEnum EventTypeEnum
	String        string
}

func NewAuditLogEventEventTypeFromEventTypeEnum(value EventTypeEnum) *AuditLogEventEventType {
	return &AuditLogEventEventType{typeName: "eventTypeEnum", EventTypeEnum: value}
}

func NewAuditLogEventEventTypeFromString(value string) *AuditLogEventEventType {
	return &AuditLogEventEventType{typeName: "string", String: value}
}

func (a *AuditLogEventEventType) UnmarshalJSON(data []byte) error {
	var valueEventTypeEnum EventTypeEnum
	if err := json.Unmarshal(data, &valueEventTypeEnum); err == nil {
		a.typeName = "eventTypeEnum"
		a.EventTypeEnum = valueEventTypeEnum
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		a.typeName = "string"
		a.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, a)
}

func (a AuditLogEventEventType) MarshalJSON() ([]byte, error) {
	switch a.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", a.typeName, a)
	case "eventTypeEnum":
		return json.Marshal(a.EventTypeEnum)
	case "string":
		return json.Marshal(a.String)
	}
}

type AuditLogEventEventTypeVisitor interface {
	VisitEventTypeEnum(EventTypeEnum) error
	VisitString(string) error
}

func (a *AuditLogEventEventType) Accept(visitor AuditLogEventEventTypeVisitor) error {
	switch a.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", a.typeName, a)
	case "eventTypeEnum":
		return visitor.VisitEventTypeEnum(a.EventTypeEnum)
	case "string":
		return visitor.VisitString(a.String)
	}
}

// Designates the role of the user (or SYSTEM/API if action not taken by a user) at the time of this Event occurring.
//
// - `ADMIN` - ADMIN
// - `DEVELOPER` - DEVELOPER
// - `MEMBER` - MEMBER
// - `API` - API
// - `SYSTEM` - SYSTEM
// - `MERGE_TEAM` - MERGE_TEAM
type AuditLogEventRole struct {
	typeName string
	RoleEnum RoleEnum
	String   string
}

func NewAuditLogEventRoleFromRoleEnum(value RoleEnum) *AuditLogEventRole {
	return &AuditLogEventRole{typeName: "roleEnum", RoleEnum: value}
}

func NewAuditLogEventRoleFromString(value string) *AuditLogEventRole {
	return &AuditLogEventRole{typeName: "string", String: value}
}

func (a *AuditLogEventRole) UnmarshalJSON(data []byte) error {
	var valueRoleEnum RoleEnum
	if err := json.Unmarshal(data, &valueRoleEnum); err == nil {
		a.typeName = "roleEnum"
		a.RoleEnum = valueRoleEnum
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		a.typeName = "string"
		a.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, a)
}

func (a AuditLogEventRole) MarshalJSON() ([]byte, error) {
	switch a.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", a.typeName, a)
	case "roleEnum":
		return json.Marshal(a.RoleEnum)
	case "string":
		return json.Marshal(a.String)
	}
}

type AuditLogEventRoleVisitor interface {
	VisitRoleEnum(RoleEnum) error
	VisitString(string) error
}

func (a *AuditLogEventRole) Accept(visitor AuditLogEventRoleVisitor) error {
	switch a.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", a.typeName, a)
	case "roleEnum":
		return visitor.VisitRoleEnum(a.RoleEnum)
	case "string":
		return visitor.VisitString(a.String)
	}
}

// # The AvailableActions Object
//
// ### Description
//
// The `Activity` object is used to see all available model/operation combinations for an integration.
//
// ### Usage Example
//
// Fetch all the actions available for the `Zenefits` integration.
type AvailableActions struct {
	Integration              *AccountIntegration `json:"integration,omitempty"`
	PassthroughAvailable     bool                `json:"passthrough_available"`
	AvailableModelOperations []*ModelOperation   `json:"available_model_operations,omitempty"`
}

// # The BankInfo Object
//
// ### Description
//
// The `BankInfo` object is used to represent the Bank Account information for an Employee.
//
// ### Usage Example
//
// Fetch from the `LIST BankInfo` endpoint and filter by `ID` to show all bank information.
type BankInfo struct {
	Id *string `json:"id,omitempty"`
	// The third-party API ID of the matching object.
	RemoteId *string `json:"remote_id,omitempty"`
	// The employee with this bank account.
	Employee *BankInfoEmployee `json:"employee,omitempty"`
	// The account number.
	AccountNumber *string `json:"account_number,omitempty"`
	// The routing number.
	RoutingNumber *string `json:"routing_number,omitempty"`
	// The bank name.
	BankName *string `json:"bank_name,omitempty"`
	// The bank account type
	//
	// - `SAVINGS` - SAVINGS
	// - `CHECKING` - CHECKING
	AccountType *BankInfoAccountType `json:"account_type,omitempty"`
	// When the matching bank object was created in the third party system.
	RemoteCreatedAt *time.Time `json:"remote_created_at,omitempty"`
	// Indicates whether or not this object has been deleted in the third party platform.
	RemoteWasDeleted *bool      `json:"remote_was_deleted,omitempty"`
	CreatedAt        *time.Time `json:"created_at,omitempty"`
	// This is the datetime that this object was last updated by Merge
	ModifiedAt    *time.Time     `json:"modified_at,omitempty"`
	FieldMappings map[string]any `json:"field_mappings,omitempty"`
	RemoteData    []*RemoteData  `json:"remote_data,omitempty"`
}

// The bank account type
//
// - `SAVINGS` - SAVINGS
// - `CHECKING` - CHECKING
type BankInfoAccountType struct {
	typeName        string
	AccountTypeEnum AccountTypeEnum
	String          string
}

func NewBankInfoAccountTypeFromAccountTypeEnum(value AccountTypeEnum) *BankInfoAccountType {
	return &BankInfoAccountType{typeName: "accountTypeEnum", AccountTypeEnum: value}
}

func NewBankInfoAccountTypeFromString(value string) *BankInfoAccountType {
	return &BankInfoAccountType{typeName: "string", String: value}
}

func (b *BankInfoAccountType) UnmarshalJSON(data []byte) error {
	var valueAccountTypeEnum AccountTypeEnum
	if err := json.Unmarshal(data, &valueAccountTypeEnum); err == nil {
		b.typeName = "accountTypeEnum"
		b.AccountTypeEnum = valueAccountTypeEnum
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		b.typeName = "string"
		b.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, b)
}

func (b BankInfoAccountType) MarshalJSON() ([]byte, error) {
	switch b.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", b.typeName, b)
	case "accountTypeEnum":
		return json.Marshal(b.AccountTypeEnum)
	case "string":
		return json.Marshal(b.String)
	}
}

type BankInfoAccountTypeVisitor interface {
	VisitAccountTypeEnum(AccountTypeEnum) error
	VisitString(string) error
}

func (b *BankInfoAccountType) Accept(visitor BankInfoAccountTypeVisitor) error {
	switch b.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", b.typeName, b)
	case "accountTypeEnum":
		return visitor.VisitAccountTypeEnum(b.AccountTypeEnum)
	case "string":
		return visitor.VisitString(b.String)
	}
}

// The employee with this bank account.
type BankInfoEmployee struct {
	typeName string
	String   string
	Employee *Employee
}

func NewBankInfoEmployeeFromString(value string) *BankInfoEmployee {
	return &BankInfoEmployee{typeName: "string", String: value}
}

func NewBankInfoEmployeeFromEmployee(value *Employee) *BankInfoEmployee {
	return &BankInfoEmployee{typeName: "employee", Employee: value}
}

func (b *BankInfoEmployee) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		b.typeName = "string"
		b.String = valueString
		return nil
	}
	valueEmployee := new(Employee)
	if err := json.Unmarshal(data, &valueEmployee); err == nil {
		b.typeName = "employee"
		b.Employee = valueEmployee
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, b)
}

func (b BankInfoEmployee) MarshalJSON() ([]byte, error) {
	switch b.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", b.typeName, b)
	case "string":
		return json.Marshal(b.String)
	case "employee":
		return json.Marshal(b.Employee)
	}
}

type BankInfoEmployeeVisitor interface {
	VisitString(string) error
	VisitEmployee(*Employee) error
}

func (b *BankInfoEmployee) Accept(visitor BankInfoEmployeeVisitor) error {
	switch b.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", b.typeName, b)
	case "string":
		return visitor.VisitString(b.String)
	case "employee":
		return visitor.VisitEmployee(b.Employee)
	}
}

// # The Benefit Object
//
// ### Description
//
// The `Benefit` object is used to represent a benefit that an employee has enrolled in.
//
// ### Usage Example
//
// Fetch from the `LIST Benefits` endpoint and filter by `ID` to show all benefits.
type Benefit struct {
	Id *string `json:"id,omitempty"`
	// The third-party API ID of the matching object.
	RemoteId *string `json:"remote_id,omitempty"`
	// The employee on the plan.
	Employee *BenefitEmployee `json:"employee,omitempty"`
	// The name of the benefit provider.
	ProviderName *string `json:"provider_name,omitempty"`
	// The type of benefit plan
	BenefitPlanType *string `json:"benefit_plan_type,omitempty"`
	// The employee's contribution.
	EmployeeContribution *float64 `json:"employee_contribution,omitempty"`
	// The company's contribution.
	CompanyContribution *float64 `json:"company_contribution,omitempty"`
	// The day and time the benefit started.
	StartDate *time.Time `json:"start_date,omitempty"`
	// The day and time the benefit ended.
	EndDate *time.Time `json:"end_date,omitempty"`
	// Indicates whether or not this object has been deleted in the third party platform.
	RemoteWasDeleted *bool `json:"remote_was_deleted,omitempty"`
	// The employer benefit plan the employee is enrolled in.
	EmployerBenefit *string    `json:"employer_benefit,omitempty"`
	CreatedAt       *time.Time `json:"created_at,omitempty"`
	// This is the datetime that this object was last updated by Merge
	ModifiedAt    *time.Time     `json:"modified_at,omitempty"`
	FieldMappings map[string]any `json:"field_mappings,omitempty"`
	RemoteData    []*RemoteData  `json:"remote_data,omitempty"`
}

// The employee on the plan.
type BenefitEmployee struct {
	typeName string
	String   string
	Employee *Employee
}

func NewBenefitEmployeeFromString(value string) *BenefitEmployee {
	return &BenefitEmployee{typeName: "string", String: value}
}

func NewBenefitEmployeeFromEmployee(value *Employee) *BenefitEmployee {
	return &BenefitEmployee{typeName: "employee", Employee: value}
}

func (b *BenefitEmployee) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		b.typeName = "string"
		b.String = valueString
		return nil
	}
	valueEmployee := new(Employee)
	if err := json.Unmarshal(data, &valueEmployee); err == nil {
		b.typeName = "employee"
		b.Employee = valueEmployee
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, b)
}

func (b BenefitEmployee) MarshalJSON() ([]byte, error) {
	switch b.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", b.typeName, b)
	case "string":
		return json.Marshal(b.String)
	case "employee":
		return json.Marshal(b.Employee)
	}
}

type BenefitEmployeeVisitor interface {
	VisitString(string) error
	VisitEmployee(*Employee) error
}

func (b *BenefitEmployee) Accept(visitor BenefitEmployeeVisitor) error {
	switch b.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", b.typeName, b)
	case "string":
		return visitor.VisitString(b.String)
	case "employee":
		return visitor.VisitEmployee(b.Employee)
	}
}

// - `MEDICAL` - MEDICAL
// - `HEALTH_SAVINGS` - HEALTH_SAVINGS
// - `INSURANCE` - INSURANCE
// - `RETIREMENT` - RETIREMENT
// - `OTHER` - OTHER
type BenefitPlanTypeEnum uint

const (
	BenefitPlanTypeEnumMedical BenefitPlanTypeEnum = iota + 1
	BenefitPlanTypeEnumHealthSavings
	BenefitPlanTypeEnumInsurance
	BenefitPlanTypeEnumRetirement
	BenefitPlanTypeEnumOther
)

func (b BenefitPlanTypeEnum) String() string {
	switch b {
	default:
		return strconv.Itoa(int(b))
	case BenefitPlanTypeEnumMedical:
		return "MEDICAL"
	case BenefitPlanTypeEnumHealthSavings:
		return "HEALTH_SAVINGS"
	case BenefitPlanTypeEnumInsurance:
		return "INSURANCE"
	case BenefitPlanTypeEnumRetirement:
		return "RETIREMENT"
	case BenefitPlanTypeEnumOther:
		return "OTHER"
	}
}

func (b BenefitPlanTypeEnum) MarshalJSON() ([]byte, error) {
	return []byte(fmt.Sprintf("%q", b.String())), nil
}

func (b *BenefitPlanTypeEnum) UnmarshalJSON(data []byte) error {
	var raw string
	if err := json.Unmarshal(data, &raw); err != nil {
		return err
	}
	switch raw {
	case "MEDICAL":
		value := BenefitPlanTypeEnumMedical
		*b = value
	case "HEALTH_SAVINGS":
		value := BenefitPlanTypeEnumHealthSavings
		*b = value
	case "INSURANCE":
		value := BenefitPlanTypeEnumInsurance
		*b = value
	case "RETIREMENT":
		value := BenefitPlanTypeEnumRetirement
		*b = value
	case "OTHER":
		value := BenefitPlanTypeEnumOther
		*b = value
	}
	return nil
}

// - `hris` - hris
// - `ats` - ats
// - `accounting` - accounting
// - `ticketing` - ticketing
// - `crm` - crm
// - `mktg` - mktg
// - `filestorage` - filestorage
type CategoriesEnum uint

const (
	CategoriesEnumHris CategoriesEnum = iota + 1
	CategoriesEnumAts
	CategoriesEnumAccounting
	CategoriesEnumTicketing
	CategoriesEnumCrm
	CategoriesEnumMktg
	CategoriesEnumFilestorage
)

func (c CategoriesEnum) String() string {
	switch c {
	default:
		return strconv.Itoa(int(c))
	case CategoriesEnumHris:
		return "hris"
	case CategoriesEnumAts:
		return "ats"
	case CategoriesEnumAccounting:
		return "accounting"
	case CategoriesEnumTicketing:
		return "ticketing"
	case CategoriesEnumCrm:
		return "crm"
	case CategoriesEnumMktg:
		return "mktg"
	case CategoriesEnumFilestorage:
		return "filestorage"
	}
}

func (c CategoriesEnum) MarshalJSON() ([]byte, error) {
	return []byte(fmt.Sprintf("%q", c.String())), nil
}

func (c *CategoriesEnum) UnmarshalJSON(data []byte) error {
	var raw string
	if err := json.Unmarshal(data, &raw); err != nil {
		return err
	}
	switch raw {
	case "hris":
		value := CategoriesEnumHris
		*c = value
	case "ats":
		value := CategoriesEnumAts
		*c = value
	case "accounting":
		value := CategoriesEnumAccounting
		*c = value
	case "ticketing":
		value := CategoriesEnumTicketing
		*c = value
	case "crm":
		value := CategoriesEnumCrm
		*c = value
	case "mktg":
		value := CategoriesEnumMktg
		*c = value
	case "filestorage":
		value := CategoriesEnumFilestorage
		*c = value
	}
	return nil
}

// - `hris` - hris
// - `ats` - ats
// - `accounting` - accounting
// - `ticketing` - ticketing
// - `crm` - crm
// - `mktg` - mktg
// - `filestorage` - filestorage
type CategoryEnum uint

const (
	CategoryEnumHris CategoryEnum = iota + 1
	CategoryEnumAts
	CategoryEnumAccounting
	CategoryEnumTicketing
	CategoryEnumCrm
	CategoryEnumMktg
	CategoryEnumFilestorage
)

func (c CategoryEnum) String() string {
	switch c {
	default:
		return strconv.Itoa(int(c))
	case CategoryEnumHris:
		return "hris"
	case CategoryEnumAts:
		return "ats"
	case CategoryEnumAccounting:
		return "accounting"
	case CategoryEnumTicketing:
		return "ticketing"
	case CategoryEnumCrm:
		return "crm"
	case CategoryEnumMktg:
		return "mktg"
	case CategoryEnumFilestorage:
		return "filestorage"
	}
}

func (c CategoryEnum) MarshalJSON() ([]byte, error) {
	return []byte(fmt.Sprintf("%q", c.String())), nil
}

func (c *CategoryEnum) UnmarshalJSON(data []byte) error {
	var raw string
	if err := json.Unmarshal(data, &raw); err != nil {
		return err
	}
	switch raw {
	case "hris":
		value := CategoryEnumHris
		*c = value
	case "ats":
		value := CategoryEnumAts
		*c = value
	case "accounting":
		value := CategoryEnumAccounting
		*c = value
	case "ticketing":
		value := CategoryEnumTicketing
		*c = value
	case "crm":
		value := CategoryEnumCrm
		*c = value
	case "mktg":
		value := CategoryEnumMktg
		*c = value
	case "filestorage":
		value := CategoryEnumFilestorage
		*c = value
	}
	return nil
}

type CommonModelScopesBodyRequest struct {
	ModelId        string               `json:"model_id"`
	EnabledActions []EnabledActionsEnum `json:"enabled_actions,omitempty"`
	DisabledFields []string             `json:"disabled_fields,omitempty"`
}

// # The Company Object
//
// ### Description
//
// The `Company` object is used to represent a company within the HRIS / Payroll system.
//
// ### Usage Example
//
// Fetch from the `LIST Companies` endpoint and filter by `ID` to show all companies.
type Company struct {
	Id *string `json:"id,omitempty"`
	// The third-party API ID of the matching object.
	RemoteId *string `json:"remote_id,omitempty"`
	// The company's legal name.
	LegalName *string `json:"legal_name,omitempty"`
	// The company's display name.
	DisplayName *string `json:"display_name,omitempty"`
	// The company's Employer Identification Numbers.
	Eins []*string `json:"eins,omitempty"`
	// Indicates whether or not this object has been deleted in the third party platform.
	RemoteWasDeleted *bool      `json:"remote_was_deleted,omitempty"`
	CreatedAt        *time.Time `json:"created_at,omitempty"`
	// This is the datetime that this object was last updated by Merge
	ModifiedAt    *time.Time     `json:"modified_at,omitempty"`
	FieldMappings map[string]any `json:"field_mappings,omitempty"`
	RemoteData    []*RemoteData  `json:"remote_data,omitempty"`
}

type ConditionSchema struct {
	// The ID of the condition schema. This ID is used when updating selective syncs for a linked account.
	Id string `json:"id"`
	// The common model for which a condition schema is defined.
	CommonModel *string `json:"common_model,omitempty"`
	// User-facing _native condition_ name. e.g. "Skip Manager".
	NativeName *string `json:"native_name,omitempty"`
	// The name of the field on the common model that this condition corresponds to, if they conceptually match. e.g. "location_type".
	FieldName *string `json:"field_name,omitempty"`
	// Whether this condition can only be applied once. If false, the condition can be AND'd together multiple times.
	IsUnique *bool `json:"is_unique,omitempty"`
	// The type of value(s) that can be set for this condition.
	//
	// - `BOOLEAN` - BOOLEAN
	// - `DATE` - DATE
	// - `DATE_TIME` - DATE_TIME
	// - `INTEGER` - INTEGER
	// - `FLOAT` - FLOAT
	// - `STRING` - STRING
	// - `LIST_OF_STRINGS` - LIST_OF_STRINGS
	ConditionType *ConditionSchemaConditionType `json:"condition_type,omitempty"`
	// The schemas for the operators that can be used on a condition.
	Operators []*OperatorSchema `json:"operators,omitempty"`
}

// The type of value(s) that can be set for this condition.
//
// - `BOOLEAN` - BOOLEAN
// - `DATE` - DATE
// - `DATE_TIME` - DATE_TIME
// - `INTEGER` - INTEGER
// - `FLOAT` - FLOAT
// - `STRING` - STRING
// - `LIST_OF_STRINGS` - LIST_OF_STRINGS
type ConditionSchemaConditionType struct {
	typeName          string
	ConditionTypeEnum ConditionTypeEnum
	String            string
}

func NewConditionSchemaConditionTypeFromConditionTypeEnum(value ConditionTypeEnum) *ConditionSchemaConditionType {
	return &ConditionSchemaConditionType{typeName: "conditionTypeEnum", ConditionTypeEnum: value}
}

func NewConditionSchemaConditionTypeFromString(value string) *ConditionSchemaConditionType {
	return &ConditionSchemaConditionType{typeName: "string", String: value}
}

func (c *ConditionSchemaConditionType) UnmarshalJSON(data []byte) error {
	var valueConditionTypeEnum ConditionTypeEnum
	if err := json.Unmarshal(data, &valueConditionTypeEnum); err == nil {
		c.typeName = "conditionTypeEnum"
		c.ConditionTypeEnum = valueConditionTypeEnum
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		c.typeName = "string"
		c.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, c)
}

func (c ConditionSchemaConditionType) MarshalJSON() ([]byte, error) {
	switch c.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", c.typeName, c)
	case "conditionTypeEnum":
		return json.Marshal(c.ConditionTypeEnum)
	case "string":
		return json.Marshal(c.String)
	}
}

type ConditionSchemaConditionTypeVisitor interface {
	VisitConditionTypeEnum(ConditionTypeEnum) error
	VisitString(string) error
}

func (c *ConditionSchemaConditionType) Accept(visitor ConditionSchemaConditionTypeVisitor) error {
	switch c.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", c.typeName, c)
	case "conditionTypeEnum":
		return visitor.VisitConditionTypeEnum(c.ConditionTypeEnum)
	case "string":
		return visitor.VisitString(c.String)
	}
}

// - `BOOLEAN` - BOOLEAN
// - `DATE` - DATE
// - `DATE_TIME` - DATE_TIME
// - `INTEGER` - INTEGER
// - `FLOAT` - FLOAT
// - `STRING` - STRING
// - `LIST_OF_STRINGS` - LIST_OF_STRINGS
type ConditionTypeEnum uint

const (
	ConditionTypeEnumBoolean ConditionTypeEnum = iota + 1
	ConditionTypeEnumDate
	ConditionTypeEnumDateTime
	ConditionTypeEnumInteger
	ConditionTypeEnumFloat
	ConditionTypeEnumString
	ConditionTypeEnumListOfStrings
)

func (c ConditionTypeEnum) String() string {
	switch c {
	default:
		return strconv.Itoa(int(c))
	case ConditionTypeEnumBoolean:
		return "BOOLEAN"
	case ConditionTypeEnumDate:
		return "DATE"
	case ConditionTypeEnumDateTime:
		return "DATE_TIME"
	case ConditionTypeEnumInteger:
		return "INTEGER"
	case ConditionTypeEnumFloat:
		return "FLOAT"
	case ConditionTypeEnumString:
		return "STRING"
	case ConditionTypeEnumListOfStrings:
		return "LIST_OF_STRINGS"
	}
}

func (c ConditionTypeEnum) MarshalJSON() ([]byte, error) {
	return []byte(fmt.Sprintf("%q", c.String())), nil
}

func (c *ConditionTypeEnum) UnmarshalJSON(data []byte) error {
	var raw string
	if err := json.Unmarshal(data, &raw); err != nil {
		return err
	}
	switch raw {
	case "BOOLEAN":
		value := ConditionTypeEnumBoolean
		*c = value
	case "DATE":
		value := ConditionTypeEnumDate
		*c = value
	case "DATE_TIME":
		value := ConditionTypeEnumDateTime
		*c = value
	case "INTEGER":
		value := ConditionTypeEnumInteger
		*c = value
	case "FLOAT":
		value := ConditionTypeEnumFloat
		*c = value
	case "STRING":
		value := ConditionTypeEnumString
		*c = value
	case "LIST_OF_STRINGS":
		value := ConditionTypeEnumListOfStrings
		*c = value
	}
	return nil
}

// - `AF` - Afghanistan
// - `AX` - Åland Islands
// - `AL` - Albania
// - `DZ` - Algeria
// - `AS` - American Samoa
// - `AD` - Andorra
// - `AO` - Angola
// - `AI` - Anguilla
// - `AQ` - Antarctica
// - `AG` - Antigua and Barbuda
// - `AR` - Argentina
// - `AM` - Armenia
// - `AW` - Aruba
// - `AU` - Australia
// - `AT` - Austria
// - `AZ` - Azerbaijan
// - `BS` - Bahamas
// - `BH` - Bahrain
// - `BD` - Bangladesh
// - `BB` - Barbados
// - `BY` - Belarus
// - `BE` - Belgium
// - `BZ` - Belize
// - `BJ` - Benin
// - `BM` - Bermuda
// - `BT` - Bhutan
// - `BO` - Bolivia
// - `BQ` - Bonaire, Sint Eustatius and Saba
// - `BA` - Bosnia and Herzegovina
// - `BW` - Botswana
// - `BV` - Bouvet Island
// - `BR` - Brazil
// - `IO` - British Indian Ocean Territory
// - `BN` - Brunei
// - `BG` - Bulgaria
// - `BF` - Burkina Faso
// - `BI` - Burundi
// - `CV` - Cabo Verde
// - `KH` - Cambodia
// - `CM` - Cameroon
// - `CA` - Canada
// - `KY` - Cayman Islands
// - `CF` - Central African Republic
// - `TD` - Chad
// - `CL` - Chile
// - `CN` - China
// - `CX` - Christmas Island
// - `CC` - Cocos (Keeling) Islands
// - `CO` - Colombia
// - `KM` - Comoros
// - `CG` - Congo
// - `CD` - Congo (the Democratic Republic of the)
// - `CK` - Cook Islands
// - `CR` - Costa Rica
// - `CI` - Côte d'Ivoire
// - `HR` - Croatia
// - `CU` - Cuba
// - `CW` - Curaçao
// - `CY` - Cyprus
// - `CZ` - Czechia
// - `DK` - Denmark
// - `DJ` - Djibouti
// - `DM` - Dominica
// - `DO` - Dominican Republic
// - `EC` - Ecuador
// - `EG` - Egypt
// - `SV` - El Salvador
// - `GQ` - Equatorial Guinea
// - `ER` - Eritrea
// - `EE` - Estonia
// - `SZ` - Eswatini
// - `ET` - Ethiopia
// - `FK` - Falkland Islands (Malvinas)
// - `FO` - Faroe Islands
// - `FJ` - Fiji
// - `FI` - Finland
// - `FR` - France
// - `GF` - French Guiana
// - `PF` - French Polynesia
// - `TF` - French Southern Territories
// - `GA` - Gabon
// - `GM` - Gambia
// - `GE` - Georgia
// - `DE` - Germany
// - `GH` - Ghana
// - `GI` - Gibraltar
// - `GR` - Greece
// - `GL` - Greenland
// - `GD` - Grenada
// - `GP` - Guadeloupe
// - `GU` - Guam
// - `GT` - Guatemala
// - `GG` - Guernsey
// - `GN` - Guinea
// - `GW` - Guinea-Bissau
// - `GY` - Guyana
// - `HT` - Haiti
// - `HM` - Heard Island and McDonald Islands
// - `VA` - Holy See
// - `HN` - Honduras
// - `HK` - Hong Kong
// - `HU` - Hungary
// - `IS` - Iceland
// - `IN` - India
// - `ID` - Indonesia
// - `IR` - Iran
// - `IQ` - Iraq
// - `IE` - Ireland
// - `IM` - Isle of Man
// - `IL` - Israel
// - `IT` - Italy
// - `JM` - Jamaica
// - `JP` - Japan
// - `JE` - Jersey
// - `JO` - Jordan
// - `KZ` - Kazakhstan
// - `KE` - Kenya
// - `KI` - Kiribati
// - `KW` - Kuwait
// - `KG` - Kyrgyzstan
// - `LA` - Laos
// - `LV` - Latvia
// - `LB` - Lebanon
// - `LS` - Lesotho
// - `LR` - Liberia
// - `LY` - Libya
// - `LI` - Liechtenstein
// - `LT` - Lithuania
// - `LU` - Luxembourg
// - `MO` - Macao
// - `MG` - Madagascar
// - `MW` - Malawi
// - `MY` - Malaysia
// - `MV` - Maldives
// - `ML` - Mali
// - `MT` - Malta
// - `MH` - Marshall Islands
// - `MQ` - Martinique
// - `MR` - Mauritania
// - `MU` - Mauritius
// - `YT` - Mayotte
// - `MX` - Mexico
// - `FM` - Micronesia (Federated States of)
// - `MD` - Moldova
// - `MC` - Monaco
// - `MN` - Mongolia
// - `ME` - Montenegro
// - `MS` - Montserrat
// - `MA` - Morocco
// - `MZ` - Mozambique
// - `MM` - Myanmar
// - `NA` - Namibia
// - `NR` - Nauru
// - `NP` - Nepal
// - `NL` - Netherlands
// - `NC` - New Caledonia
// - `NZ` - New Zealand
// - `NI` - Nicaragua
// - `NE` - Niger
// - `NG` - Nigeria
// - `NU` - Niue
// - `NF` - Norfolk Island
// - `KP` - North Korea
// - `MK` - North Macedonia
// - `MP` - Northern Mariana Islands
// - `NO` - Norway
// - `OM` - Oman
// - `PK` - Pakistan
// - `PW` - Palau
// - `PS` - Palestine, State of
// - `PA` - Panama
// - `PG` - Papua New Guinea
// - `PY` - Paraguay
// - `PE` - Peru
// - `PH` - Philippines
// - `PN` - Pitcairn
// - `PL` - Poland
// - `PT` - Portugal
// - `PR` - Puerto Rico
// - `QA` - Qatar
// - `RE` - Réunion
// - `RO` - Romania
// - `RU` - Russia
// - `RW` - Rwanda
// - `BL` - Saint Barthélemy
// - `SH` - Saint Helena, Ascension and Tristan da Cunha
// - `KN` - Saint Kitts and Nevis
// - `LC` - Saint Lucia
// - `MF` - Saint Martin (French part)
// - `PM` - Saint Pierre and Miquelon
// - `VC` - Saint Vincent and the Grenadines
// - `WS` - Samoa
// - `SM` - San Marino
// - `ST` - Sao Tome and Principe
// - `SA` - Saudi Arabia
// - `SN` - Senegal
// - `RS` - Serbia
// - `SC` - Seychelles
// - `SL` - Sierra Leone
// - `SG` - Singapore
// - `SX` - Sint Maarten (Dutch part)
// - `SK` - Slovakia
// - `SI` - Slovenia
// - `SB` - Solomon Islands
// - `SO` - Somalia
// - `ZA` - South Africa
// - `GS` - South Georgia and the South Sandwich Islands
// - `KR` - South Korea
// - `SS` - South Sudan
// - `ES` - Spain
// - `LK` - Sri Lanka
// - `SD` - Sudan
// - `SR` - Suriname
// - `SJ` - Svalbard and Jan Mayen
// - `SE` - Sweden
// - `CH` - Switzerland
// - `SY` - Syria
// - `TW` - Taiwan
// - `TJ` - Tajikistan
// - `TZ` - Tanzania
// - `TH` - Thailand
// - `TL` - Timor-Leste
// - `TG` - Togo
// - `TK` - Tokelau
// - `TO` - Tonga
// - `TT` - Trinidad and Tobago
// - `TN` - Tunisia
// - `TR` - Turkey
// - `TM` - Turkmenistan
// - `TC` - Turks and Caicos Islands
// - `TV` - Tuvalu
// - `UG` - Uganda
// - `UA` - Ukraine
// - `AE` - United Arab Emirates
// - `GB` - United Kingdom
// - `UM` - United States Minor Outlying Islands
// - `US` - United States of America
// - `UY` - Uruguay
// - `UZ` - Uzbekistan
// - `VU` - Vanuatu
// - `VE` - Venezuela
// - `VN` - Vietnam
// - `VG` - Virgin Islands (British)
// - `VI` - Virgin Islands (U.S.)
// - `WF` - Wallis and Futuna
// - `EH` - Western Sahara
// - `YE` - Yemen
// - `ZM` - Zambia
// - `ZW` - Zimbabwe
type CountryEnum uint

const (
	CountryEnumAf CountryEnum = iota + 1
	CountryEnumAx
	CountryEnumAl
	CountryEnumDz
	CountryEnumAs
	CountryEnumAd
	CountryEnumAo
	CountryEnumAi
	CountryEnumAq
	CountryEnumAg
	CountryEnumAr
	CountryEnumAm
	CountryEnumAw
	CountryEnumAu
	CountryEnumAt
	CountryEnumAz
	CountryEnumBs
	CountryEnumBh
	CountryEnumBd
	CountryEnumBb
	CountryEnumBy
	CountryEnumBe
	CountryEnumBz
	CountryEnumBj
	CountryEnumBm
	CountryEnumBt
	CountryEnumBo
	CountryEnumBq
	CountryEnumBa
	CountryEnumBw
	CountryEnumBv
	CountryEnumBr
	CountryEnumIo
	CountryEnumBn
	CountryEnumBg
	CountryEnumBf
	CountryEnumBi
	CountryEnumCv
	CountryEnumKh
	CountryEnumCm
	CountryEnumCa
	CountryEnumKy
	CountryEnumCf
	CountryEnumTd
	CountryEnumCl
	CountryEnumCn
	CountryEnumCx
	CountryEnumCc
	CountryEnumCo
	CountryEnumKm
	CountryEnumCg
	CountryEnumCd
	CountryEnumCk
	CountryEnumCr
	CountryEnumCi
	CountryEnumHr
	CountryEnumCu
	CountryEnumCw
	CountryEnumCy
	CountryEnumCz
	CountryEnumDk
	CountryEnumDj
	CountryEnumDm
	CountryEnumDo
	CountryEnumEc
	CountryEnumEg
	CountryEnumSv
	CountryEnumGq
	CountryEnumEr
	CountryEnumEe
	CountryEnumSz
	CountryEnumEt
	CountryEnumFk
	CountryEnumFo
	CountryEnumFj
	CountryEnumFi
	CountryEnumFr
	CountryEnumGf
	CountryEnumPf
	CountryEnumTf
	CountryEnumGa
	CountryEnumGm
	CountryEnumGe
	CountryEnumDe
	CountryEnumGh
	CountryEnumGi
	CountryEnumGr
	CountryEnumGl
	CountryEnumGd
	CountryEnumGp
	CountryEnumGu
	CountryEnumGt
	CountryEnumGg
	CountryEnumGn
	CountryEnumGw
	CountryEnumGy
	CountryEnumHt
	CountryEnumHm
	CountryEnumVa
	CountryEnumHn
	CountryEnumHk
	CountryEnumHu
	CountryEnumIs
	CountryEnumIn
	CountryEnumId
	CountryEnumIr
	CountryEnumIq
	CountryEnumIe
	CountryEnumIm
	CountryEnumIl
	CountryEnumIt
	CountryEnumJm
	CountryEnumJp
	CountryEnumJe
	CountryEnumJo
	CountryEnumKz
	CountryEnumKe
	CountryEnumKi
	CountryEnumKw
	CountryEnumKg
	CountryEnumLa
	CountryEnumLv
	CountryEnumLb
	CountryEnumLs
	CountryEnumLr
	CountryEnumLy
	CountryEnumLi
	CountryEnumLt
	CountryEnumLu
	CountryEnumMo
	CountryEnumMg
	CountryEnumMw
	CountryEnumMy
	CountryEnumMv
	CountryEnumMl
	CountryEnumMt
	CountryEnumMh
	CountryEnumMq
	CountryEnumMr
	CountryEnumMu
	CountryEnumYt
	CountryEnumMx
	CountryEnumFm
	CountryEnumMd
	CountryEnumMc
	CountryEnumMn
	CountryEnumMe
	CountryEnumMs
	CountryEnumMa
	CountryEnumMz
	CountryEnumMm
	CountryEnumNa
	CountryEnumNr
	CountryEnumNp
	CountryEnumNl
	CountryEnumNc
	CountryEnumNz
	CountryEnumNi
	CountryEnumNe
	CountryEnumNg
	CountryEnumNu
	CountryEnumNf
	CountryEnumKp
	CountryEnumMk
	CountryEnumMp
	CountryEnumNo
	CountryEnumOm
	CountryEnumPk
	CountryEnumPw
	CountryEnumPs
	CountryEnumPa
	CountryEnumPg
	CountryEnumPy
	CountryEnumPe
	CountryEnumPh
	CountryEnumPn
	CountryEnumPl
	CountryEnumPt
	CountryEnumPr
	CountryEnumQa
	CountryEnumRe
	CountryEnumRo
	CountryEnumRu
	CountryEnumRw
	CountryEnumBl
	CountryEnumSh
	CountryEnumKn
	CountryEnumLc
	CountryEnumMf
	CountryEnumPm
	CountryEnumVc
	CountryEnumWs
	CountryEnumSm
	CountryEnumSt
	CountryEnumSa
	CountryEnumSn
	CountryEnumRs
	CountryEnumSc
	CountryEnumSl
	CountryEnumSg
	CountryEnumSx
	CountryEnumSk
	CountryEnumSi
	CountryEnumSb
	CountryEnumSo
	CountryEnumZa
	CountryEnumGs
	CountryEnumKr
	CountryEnumSs
	CountryEnumEs
	CountryEnumLk
	CountryEnumSd
	CountryEnumSr
	CountryEnumSj
	CountryEnumSe
	CountryEnumCh
	CountryEnumSy
	CountryEnumTw
	CountryEnumTj
	CountryEnumTz
	CountryEnumTh
	CountryEnumTl
	CountryEnumTg
	CountryEnumTk
	CountryEnumTo
	CountryEnumTt
	CountryEnumTn
	CountryEnumTr
	CountryEnumTm
	CountryEnumTc
	CountryEnumTv
	CountryEnumUg
	CountryEnumUa
	CountryEnumAe
	CountryEnumGb
	CountryEnumUm
	CountryEnumUs
	CountryEnumUy
	CountryEnumUz
	CountryEnumVu
	CountryEnumVe
	CountryEnumVn
	CountryEnumVg
	CountryEnumVi
	CountryEnumWf
	CountryEnumEh
	CountryEnumYe
	CountryEnumZm
	CountryEnumZw
)

func (c CountryEnum) String() string {
	switch c {
	default:
		return strconv.Itoa(int(c))
	case CountryEnumAf:
		return "AF"
	case CountryEnumAx:
		return "AX"
	case CountryEnumAl:
		return "AL"
	case CountryEnumDz:
		return "DZ"
	case CountryEnumAs:
		return "AS"
	case CountryEnumAd:
		return "AD"
	case CountryEnumAo:
		return "AO"
	case CountryEnumAi:
		return "AI"
	case CountryEnumAq:
		return "AQ"
	case CountryEnumAg:
		return "AG"
	case CountryEnumAr:
		return "AR"
	case CountryEnumAm:
		return "AM"
	case CountryEnumAw:
		return "AW"
	case CountryEnumAu:
		return "AU"
	case CountryEnumAt:
		return "AT"
	case CountryEnumAz:
		return "AZ"
	case CountryEnumBs:
		return "BS"
	case CountryEnumBh:
		return "BH"
	case CountryEnumBd:
		return "BD"
	case CountryEnumBb:
		return "BB"
	case CountryEnumBy:
		return "BY"
	case CountryEnumBe:
		return "BE"
	case CountryEnumBz:
		return "BZ"
	case CountryEnumBj:
		return "BJ"
	case CountryEnumBm:
		return "BM"
	case CountryEnumBt:
		return "BT"
	case CountryEnumBo:
		return "BO"
	case CountryEnumBq:
		return "BQ"
	case CountryEnumBa:
		return "BA"
	case CountryEnumBw:
		return "BW"
	case CountryEnumBv:
		return "BV"
	case CountryEnumBr:
		return "BR"
	case CountryEnumIo:
		return "IO"
	case CountryEnumBn:
		return "BN"
	case CountryEnumBg:
		return "BG"
	case CountryEnumBf:
		return "BF"
	case CountryEnumBi:
		return "BI"
	case CountryEnumCv:
		return "CV"
	case CountryEnumKh:
		return "KH"
	case CountryEnumCm:
		return "CM"
	case CountryEnumCa:
		return "CA"
	case CountryEnumKy:
		return "KY"
	case CountryEnumCf:
		return "CF"
	case CountryEnumTd:
		return "TD"
	case CountryEnumCl:
		return "CL"
	case CountryEnumCn:
		return "CN"
	case CountryEnumCx:
		return "CX"
	case CountryEnumCc:
		return "CC"
	case CountryEnumCo:
		return "CO"
	case CountryEnumKm:
		return "KM"
	case CountryEnumCg:
		return "CG"
	case CountryEnumCd:
		return "CD"
	case CountryEnumCk:
		return "CK"
	case CountryEnumCr:
		return "CR"
	case CountryEnumCi:
		return "CI"
	case CountryEnumHr:
		return "HR"
	case CountryEnumCu:
		return "CU"
	case CountryEnumCw:
		return "CW"
	case CountryEnumCy:
		return "CY"
	case CountryEnumCz:
		return "CZ"
	case CountryEnumDk:
		return "DK"
	case CountryEnumDj:
		return "DJ"
	case CountryEnumDm:
		return "DM"
	case CountryEnumDo:
		return "DO"
	case CountryEnumEc:
		return "EC"
	case CountryEnumEg:
		return "EG"
	case CountryEnumSv:
		return "SV"
	case CountryEnumGq:
		return "GQ"
	case CountryEnumEr:
		return "ER"
	case CountryEnumEe:
		return "EE"
	case CountryEnumSz:
		return "SZ"
	case CountryEnumEt:
		return "ET"
	case CountryEnumFk:
		return "FK"
	case CountryEnumFo:
		return "FO"
	case CountryEnumFj:
		return "FJ"
	case CountryEnumFi:
		return "FI"
	case CountryEnumFr:
		return "FR"
	case CountryEnumGf:
		return "GF"
	case CountryEnumPf:
		return "PF"
	case CountryEnumTf:
		return "TF"
	case CountryEnumGa:
		return "GA"
	case CountryEnumGm:
		return "GM"
	case CountryEnumGe:
		return "GE"
	case CountryEnumDe:
		return "DE"
	case CountryEnumGh:
		return "GH"
	case CountryEnumGi:
		return "GI"
	case CountryEnumGr:
		return "GR"
	case CountryEnumGl:
		return "GL"
	case CountryEnumGd:
		return "GD"
	case CountryEnumGp:
		return "GP"
	case CountryEnumGu:
		return "GU"
	case CountryEnumGt:
		return "GT"
	case CountryEnumGg:
		return "GG"
	case CountryEnumGn:
		return "GN"
	case CountryEnumGw:
		return "GW"
	case CountryEnumGy:
		return "GY"
	case CountryEnumHt:
		return "HT"
	case CountryEnumHm:
		return "HM"
	case CountryEnumVa:
		return "VA"
	case CountryEnumHn:
		return "HN"
	case CountryEnumHk:
		return "HK"
	case CountryEnumHu:
		return "HU"
	case CountryEnumIs:
		return "IS"
	case CountryEnumIn:
		return "IN"
	case CountryEnumId:
		return "ID"
	case CountryEnumIr:
		return "IR"
	case CountryEnumIq:
		return "IQ"
	case CountryEnumIe:
		return "IE"
	case CountryEnumIm:
		return "IM"
	case CountryEnumIl:
		return "IL"
	case CountryEnumIt:
		return "IT"
	case CountryEnumJm:
		return "JM"
	case CountryEnumJp:
		return "JP"
	case CountryEnumJe:
		return "JE"
	case CountryEnumJo:
		return "JO"
	case CountryEnumKz:
		return "KZ"
	case CountryEnumKe:
		return "KE"
	case CountryEnumKi:
		return "KI"
	case CountryEnumKw:
		return "KW"
	case CountryEnumKg:
		return "KG"
	case CountryEnumLa:
		return "LA"
	case CountryEnumLv:
		return "LV"
	case CountryEnumLb:
		return "LB"
	case CountryEnumLs:
		return "LS"
	case CountryEnumLr:
		return "LR"
	case CountryEnumLy:
		return "LY"
	case CountryEnumLi:
		return "LI"
	case CountryEnumLt:
		return "LT"
	case CountryEnumLu:
		return "LU"
	case CountryEnumMo:
		return "MO"
	case CountryEnumMg:
		return "MG"
	case CountryEnumMw:
		return "MW"
	case CountryEnumMy:
		return "MY"
	case CountryEnumMv:
		return "MV"
	case CountryEnumMl:
		return "ML"
	case CountryEnumMt:
		return "MT"
	case CountryEnumMh:
		return "MH"
	case CountryEnumMq:
		return "MQ"
	case CountryEnumMr:
		return "MR"
	case CountryEnumMu:
		return "MU"
	case CountryEnumYt:
		return "YT"
	case CountryEnumMx:
		return "MX"
	case CountryEnumFm:
		return "FM"
	case CountryEnumMd:
		return "MD"
	case CountryEnumMc:
		return "MC"
	case CountryEnumMn:
		return "MN"
	case CountryEnumMe:
		return "ME"
	case CountryEnumMs:
		return "MS"
	case CountryEnumMa:
		return "MA"
	case CountryEnumMz:
		return "MZ"
	case CountryEnumMm:
		return "MM"
	case CountryEnumNa:
		return "NA"
	case CountryEnumNr:
		return "NR"
	case CountryEnumNp:
		return "NP"
	case CountryEnumNl:
		return "NL"
	case CountryEnumNc:
		return "NC"
	case CountryEnumNz:
		return "NZ"
	case CountryEnumNi:
		return "NI"
	case CountryEnumNe:
		return "NE"
	case CountryEnumNg:
		return "NG"
	case CountryEnumNu:
		return "NU"
	case CountryEnumNf:
		return "NF"
	case CountryEnumKp:
		return "KP"
	case CountryEnumMk:
		return "MK"
	case CountryEnumMp:
		return "MP"
	case CountryEnumNo:
		return "NO"
	case CountryEnumOm:
		return "OM"
	case CountryEnumPk:
		return "PK"
	case CountryEnumPw:
		return "PW"
	case CountryEnumPs:
		return "PS"
	case CountryEnumPa:
		return "PA"
	case CountryEnumPg:
		return "PG"
	case CountryEnumPy:
		return "PY"
	case CountryEnumPe:
		return "PE"
	case CountryEnumPh:
		return "PH"
	case CountryEnumPn:
		return "PN"
	case CountryEnumPl:
		return "PL"
	case CountryEnumPt:
		return "PT"
	case CountryEnumPr:
		return "PR"
	case CountryEnumQa:
		return "QA"
	case CountryEnumRe:
		return "RE"
	case CountryEnumRo:
		return "RO"
	case CountryEnumRu:
		return "RU"
	case CountryEnumRw:
		return "RW"
	case CountryEnumBl:
		return "BL"
	case CountryEnumSh:
		return "SH"
	case CountryEnumKn:
		return "KN"
	case CountryEnumLc:
		return "LC"
	case CountryEnumMf:
		return "MF"
	case CountryEnumPm:
		return "PM"
	case CountryEnumVc:
		return "VC"
	case CountryEnumWs:
		return "WS"
	case CountryEnumSm:
		return "SM"
	case CountryEnumSt:
		return "ST"
	case CountryEnumSa:
		return "SA"
	case CountryEnumSn:
		return "SN"
	case CountryEnumRs:
		return "RS"
	case CountryEnumSc:
		return "SC"
	case CountryEnumSl:
		return "SL"
	case CountryEnumSg:
		return "SG"
	case CountryEnumSx:
		return "SX"
	case CountryEnumSk:
		return "SK"
	case CountryEnumSi:
		return "SI"
	case CountryEnumSb:
		return "SB"
	case CountryEnumSo:
		return "SO"
	case CountryEnumZa:
		return "ZA"
	case CountryEnumGs:
		return "GS"
	case CountryEnumKr:
		return "KR"
	case CountryEnumSs:
		return "SS"
	case CountryEnumEs:
		return "ES"
	case CountryEnumLk:
		return "LK"
	case CountryEnumSd:
		return "SD"
	case CountryEnumSr:
		return "SR"
	case CountryEnumSj:
		return "SJ"
	case CountryEnumSe:
		return "SE"
	case CountryEnumCh:
		return "CH"
	case CountryEnumSy:
		return "SY"
	case CountryEnumTw:
		return "TW"
	case CountryEnumTj:
		return "TJ"
	case CountryEnumTz:
		return "TZ"
	case CountryEnumTh:
		return "TH"
	case CountryEnumTl:
		return "TL"
	case CountryEnumTg:
		return "TG"
	case CountryEnumTk:
		return "TK"
	case CountryEnumTo:
		return "TO"
	case CountryEnumTt:
		return "TT"
	case CountryEnumTn:
		return "TN"
	case CountryEnumTr:
		return "TR"
	case CountryEnumTm:
		return "TM"
	case CountryEnumTc:
		return "TC"
	case CountryEnumTv:
		return "TV"
	case CountryEnumUg:
		return "UG"
	case CountryEnumUa:
		return "UA"
	case CountryEnumAe:
		return "AE"
	case CountryEnumGb:
		return "GB"
	case CountryEnumUm:
		return "UM"
	case CountryEnumUs:
		return "US"
	case CountryEnumUy:
		return "UY"
	case CountryEnumUz:
		return "UZ"
	case CountryEnumVu:
		return "VU"
	case CountryEnumVe:
		return "VE"
	case CountryEnumVn:
		return "VN"
	case CountryEnumVg:
		return "VG"
	case CountryEnumVi:
		return "VI"
	case CountryEnumWf:
		return "WF"
	case CountryEnumEh:
		return "EH"
	case CountryEnumYe:
		return "YE"
	case CountryEnumZm:
		return "ZM"
	case CountryEnumZw:
		return "ZW"
	}
}

func (c CountryEnum) MarshalJSON() ([]byte, error) {
	return []byte(fmt.Sprintf("%q", c.String())), nil
}

func (c *CountryEnum) UnmarshalJSON(data []byte) error {
	var raw string
	if err := json.Unmarshal(data, &raw); err != nil {
		return err
	}
	switch raw {
	case "AF":
		value := CountryEnumAf
		*c = value
	case "AX":
		value := CountryEnumAx
		*c = value
	case "AL":
		value := CountryEnumAl
		*c = value
	case "DZ":
		value := CountryEnumDz
		*c = value
	case "AS":
		value := CountryEnumAs
		*c = value
	case "AD":
		value := CountryEnumAd
		*c = value
	case "AO":
		value := CountryEnumAo
		*c = value
	case "AI":
		value := CountryEnumAi
		*c = value
	case "AQ":
		value := CountryEnumAq
		*c = value
	case "AG":
		value := CountryEnumAg
		*c = value
	case "AR":
		value := CountryEnumAr
		*c = value
	case "AM":
		value := CountryEnumAm
		*c = value
	case "AW":
		value := CountryEnumAw
		*c = value
	case "AU":
		value := CountryEnumAu
		*c = value
	case "AT":
		value := CountryEnumAt
		*c = value
	case "AZ":
		value := CountryEnumAz
		*c = value
	case "BS":
		value := CountryEnumBs
		*c = value
	case "BH":
		value := CountryEnumBh
		*c = value
	case "BD":
		value := CountryEnumBd
		*c = value
	case "BB":
		value := CountryEnumBb
		*c = value
	case "BY":
		value := CountryEnumBy
		*c = value
	case "BE":
		value := CountryEnumBe
		*c = value
	case "BZ":
		value := CountryEnumBz
		*c = value
	case "BJ":
		value := CountryEnumBj
		*c = value
	case "BM":
		value := CountryEnumBm
		*c = value
	case "BT":
		value := CountryEnumBt
		*c = value
	case "BO":
		value := CountryEnumBo
		*c = value
	case "BQ":
		value := CountryEnumBq
		*c = value
	case "BA":
		value := CountryEnumBa
		*c = value
	case "BW":
		value := CountryEnumBw
		*c = value
	case "BV":
		value := CountryEnumBv
		*c = value
	case "BR":
		value := CountryEnumBr
		*c = value
	case "IO":
		value := CountryEnumIo
		*c = value
	case "BN":
		value := CountryEnumBn
		*c = value
	case "BG":
		value := CountryEnumBg
		*c = value
	case "BF":
		value := CountryEnumBf
		*c = value
	case "BI":
		value := CountryEnumBi
		*c = value
	case "CV":
		value := CountryEnumCv
		*c = value
	case "KH":
		value := CountryEnumKh
		*c = value
	case "CM":
		value := CountryEnumCm
		*c = value
	case "CA":
		value := CountryEnumCa
		*c = value
	case "KY":
		value := CountryEnumKy
		*c = value
	case "CF":
		value := CountryEnumCf
		*c = value
	case "TD":
		value := CountryEnumTd
		*c = value
	case "CL":
		value := CountryEnumCl
		*c = value
	case "CN":
		value := CountryEnumCn
		*c = value
	case "CX":
		value := CountryEnumCx
		*c = value
	case "CC":
		value := CountryEnumCc
		*c = value
	case "CO":
		value := CountryEnumCo
		*c = value
	case "KM":
		value := CountryEnumKm
		*c = value
	case "CG":
		value := CountryEnumCg
		*c = value
	case "CD":
		value := CountryEnumCd
		*c = value
	case "CK":
		value := CountryEnumCk
		*c = value
	case "CR":
		value := CountryEnumCr
		*c = value
	case "CI":
		value := CountryEnumCi
		*c = value
	case "HR":
		value := CountryEnumHr
		*c = value
	case "CU":
		value := CountryEnumCu
		*c = value
	case "CW":
		value := CountryEnumCw
		*c = value
	case "CY":
		value := CountryEnumCy
		*c = value
	case "CZ":
		value := CountryEnumCz
		*c = value
	case "DK":
		value := CountryEnumDk
		*c = value
	case "DJ":
		value := CountryEnumDj
		*c = value
	case "DM":
		value := CountryEnumDm
		*c = value
	case "DO":
		value := CountryEnumDo
		*c = value
	case "EC":
		value := CountryEnumEc
		*c = value
	case "EG":
		value := CountryEnumEg
		*c = value
	case "SV":
		value := CountryEnumSv
		*c = value
	case "GQ":
		value := CountryEnumGq
		*c = value
	case "ER":
		value := CountryEnumEr
		*c = value
	case "EE":
		value := CountryEnumEe
		*c = value
	case "SZ":
		value := CountryEnumSz
		*c = value
	case "ET":
		value := CountryEnumEt
		*c = value
	case "FK":
		value := CountryEnumFk
		*c = value
	case "FO":
		value := CountryEnumFo
		*c = value
	case "FJ":
		value := CountryEnumFj
		*c = value
	case "FI":
		value := CountryEnumFi
		*c = value
	case "FR":
		value := CountryEnumFr
		*c = value
	case "GF":
		value := CountryEnumGf
		*c = value
	case "PF":
		value := CountryEnumPf
		*c = value
	case "TF":
		value := CountryEnumTf
		*c = value
	case "GA":
		value := CountryEnumGa
		*c = value
	case "GM":
		value := CountryEnumGm
		*c = value
	case "GE":
		value := CountryEnumGe
		*c = value
	case "DE":
		value := CountryEnumDe
		*c = value
	case "GH":
		value := CountryEnumGh
		*c = value
	case "GI":
		value := CountryEnumGi
		*c = value
	case "GR":
		value := CountryEnumGr
		*c = value
	case "GL":
		value := CountryEnumGl
		*c = value
	case "GD":
		value := CountryEnumGd
		*c = value
	case "GP":
		value := CountryEnumGp
		*c = value
	case "GU":
		value := CountryEnumGu
		*c = value
	case "GT":
		value := CountryEnumGt
		*c = value
	case "GG":
		value := CountryEnumGg
		*c = value
	case "GN":
		value := CountryEnumGn
		*c = value
	case "GW":
		value := CountryEnumGw
		*c = value
	case "GY":
		value := CountryEnumGy
		*c = value
	case "HT":
		value := CountryEnumHt
		*c = value
	case "HM":
		value := CountryEnumHm
		*c = value
	case "VA":
		value := CountryEnumVa
		*c = value
	case "HN":
		value := CountryEnumHn
		*c = value
	case "HK":
		value := CountryEnumHk
		*c = value
	case "HU":
		value := CountryEnumHu
		*c = value
	case "IS":
		value := CountryEnumIs
		*c = value
	case "IN":
		value := CountryEnumIn
		*c = value
	case "ID":
		value := CountryEnumId
		*c = value
	case "IR":
		value := CountryEnumIr
		*c = value
	case "IQ":
		value := CountryEnumIq
		*c = value
	case "IE":
		value := CountryEnumIe
		*c = value
	case "IM":
		value := CountryEnumIm
		*c = value
	case "IL":
		value := CountryEnumIl
		*c = value
	case "IT":
		value := CountryEnumIt
		*c = value
	case "JM":
		value := CountryEnumJm
		*c = value
	case "JP":
		value := CountryEnumJp
		*c = value
	case "JE":
		value := CountryEnumJe
		*c = value
	case "JO":
		value := CountryEnumJo
		*c = value
	case "KZ":
		value := CountryEnumKz
		*c = value
	case "KE":
		value := CountryEnumKe
		*c = value
	case "KI":
		value := CountryEnumKi
		*c = value
	case "KW":
		value := CountryEnumKw
		*c = value
	case "KG":
		value := CountryEnumKg
		*c = value
	case "LA":
		value := CountryEnumLa
		*c = value
	case "LV":
		value := CountryEnumLv
		*c = value
	case "LB":
		value := CountryEnumLb
		*c = value
	case "LS":
		value := CountryEnumLs
		*c = value
	case "LR":
		value := CountryEnumLr
		*c = value
	case "LY":
		value := CountryEnumLy
		*c = value
	case "LI":
		value := CountryEnumLi
		*c = value
	case "LT":
		value := CountryEnumLt
		*c = value
	case "LU":
		value := CountryEnumLu
		*c = value
	case "MO":
		value := CountryEnumMo
		*c = value
	case "MG":
		value := CountryEnumMg
		*c = value
	case "MW":
		value := CountryEnumMw
		*c = value
	case "MY":
		value := CountryEnumMy
		*c = value
	case "MV":
		value := CountryEnumMv
		*c = value
	case "ML":
		value := CountryEnumMl
		*c = value
	case "MT":
		value := CountryEnumMt
		*c = value
	case "MH":
		value := CountryEnumMh
		*c = value
	case "MQ":
		value := CountryEnumMq
		*c = value
	case "MR":
		value := CountryEnumMr
		*c = value
	case "MU":
		value := CountryEnumMu
		*c = value
	case "YT":
		value := CountryEnumYt
		*c = value
	case "MX":
		value := CountryEnumMx
		*c = value
	case "FM":
		value := CountryEnumFm
		*c = value
	case "MD":
		value := CountryEnumMd
		*c = value
	case "MC":
		value := CountryEnumMc
		*c = value
	case "MN":
		value := CountryEnumMn
		*c = value
	case "ME":
		value := CountryEnumMe
		*c = value
	case "MS":
		value := CountryEnumMs
		*c = value
	case "MA":
		value := CountryEnumMa
		*c = value
	case "MZ":
		value := CountryEnumMz
		*c = value
	case "MM":
		value := CountryEnumMm
		*c = value
	case "NA":
		value := CountryEnumNa
		*c = value
	case "NR":
		value := CountryEnumNr
		*c = value
	case "NP":
		value := CountryEnumNp
		*c = value
	case "NL":
		value := CountryEnumNl
		*c = value
	case "NC":
		value := CountryEnumNc
		*c = value
	case "NZ":
		value := CountryEnumNz
		*c = value
	case "NI":
		value := CountryEnumNi
		*c = value
	case "NE":
		value := CountryEnumNe
		*c = value
	case "NG":
		value := CountryEnumNg
		*c = value
	case "NU":
		value := CountryEnumNu
		*c = value
	case "NF":
		value := CountryEnumNf
		*c = value
	case "KP":
		value := CountryEnumKp
		*c = value
	case "MK":
		value := CountryEnumMk
		*c = value
	case "MP":
		value := CountryEnumMp
		*c = value
	case "NO":
		value := CountryEnumNo
		*c = value
	case "OM":
		value := CountryEnumOm
		*c = value
	case "PK":
		value := CountryEnumPk
		*c = value
	case "PW":
		value := CountryEnumPw
		*c = value
	case "PS":
		value := CountryEnumPs
		*c = value
	case "PA":
		value := CountryEnumPa
		*c = value
	case "PG":
		value := CountryEnumPg
		*c = value
	case "PY":
		value := CountryEnumPy
		*c = value
	case "PE":
		value := CountryEnumPe
		*c = value
	case "PH":
		value := CountryEnumPh
		*c = value
	case "PN":
		value := CountryEnumPn
		*c = value
	case "PL":
		value := CountryEnumPl
		*c = value
	case "PT":
		value := CountryEnumPt
		*c = value
	case "PR":
		value := CountryEnumPr
		*c = value
	case "QA":
		value := CountryEnumQa
		*c = value
	case "RE":
		value := CountryEnumRe
		*c = value
	case "RO":
		value := CountryEnumRo
		*c = value
	case "RU":
		value := CountryEnumRu
		*c = value
	case "RW":
		value := CountryEnumRw
		*c = value
	case "BL":
		value := CountryEnumBl
		*c = value
	case "SH":
		value := CountryEnumSh
		*c = value
	case "KN":
		value := CountryEnumKn
		*c = value
	case "LC":
		value := CountryEnumLc
		*c = value
	case "MF":
		value := CountryEnumMf
		*c = value
	case "PM":
		value := CountryEnumPm
		*c = value
	case "VC":
		value := CountryEnumVc
		*c = value
	case "WS":
		value := CountryEnumWs
		*c = value
	case "SM":
		value := CountryEnumSm
		*c = value
	case "ST":
		value := CountryEnumSt
		*c = value
	case "SA":
		value := CountryEnumSa
		*c = value
	case "SN":
		value := CountryEnumSn
		*c = value
	case "RS":
		value := CountryEnumRs
		*c = value
	case "SC":
		value := CountryEnumSc
		*c = value
	case "SL":
		value := CountryEnumSl
		*c = value
	case "SG":
		value := CountryEnumSg
		*c = value
	case "SX":
		value := CountryEnumSx
		*c = value
	case "SK":
		value := CountryEnumSk
		*c = value
	case "SI":
		value := CountryEnumSi
		*c = value
	case "SB":
		value := CountryEnumSb
		*c = value
	case "SO":
		value := CountryEnumSo
		*c = value
	case "ZA":
		value := CountryEnumZa
		*c = value
	case "GS":
		value := CountryEnumGs
		*c = value
	case "KR":
		value := CountryEnumKr
		*c = value
	case "SS":
		value := CountryEnumSs
		*c = value
	case "ES":
		value := CountryEnumEs
		*c = value
	case "LK":
		value := CountryEnumLk
		*c = value
	case "SD":
		value := CountryEnumSd
		*c = value
	case "SR":
		value := CountryEnumSr
		*c = value
	case "SJ":
		value := CountryEnumSj
		*c = value
	case "SE":
		value := CountryEnumSe
		*c = value
	case "CH":
		value := CountryEnumCh
		*c = value
	case "SY":
		value := CountryEnumSy
		*c = value
	case "TW":
		value := CountryEnumTw
		*c = value
	case "TJ":
		value := CountryEnumTj
		*c = value
	case "TZ":
		value := CountryEnumTz
		*c = value
	case "TH":
		value := CountryEnumTh
		*c = value
	case "TL":
		value := CountryEnumTl
		*c = value
	case "TG":
		value := CountryEnumTg
		*c = value
	case "TK":
		value := CountryEnumTk
		*c = value
	case "TO":
		value := CountryEnumTo
		*c = value
	case "TT":
		value := CountryEnumTt
		*c = value
	case "TN":
		value := CountryEnumTn
		*c = value
	case "TR":
		value := CountryEnumTr
		*c = value
	case "TM":
		value := CountryEnumTm
		*c = value
	case "TC":
		value := CountryEnumTc
		*c = value
	case "TV":
		value := CountryEnumTv
		*c = value
	case "UG":
		value := CountryEnumUg
		*c = value
	case "UA":
		value := CountryEnumUa
		*c = value
	case "AE":
		value := CountryEnumAe
		*c = value
	case "GB":
		value := CountryEnumGb
		*c = value
	case "UM":
		value := CountryEnumUm
		*c = value
	case "US":
		value := CountryEnumUs
		*c = value
	case "UY":
		value := CountryEnumUy
		*c = value
	case "UZ":
		value := CountryEnumUz
		*c = value
	case "VU":
		value := CountryEnumVu
		*c = value
	case "VE":
		value := CountryEnumVe
		*c = value
	case "VN":
		value := CountryEnumVn
		*c = value
	case "VG":
		value := CountryEnumVg
		*c = value
	case "VI":
		value := CountryEnumVi
		*c = value
	case "WF":
		value := CountryEnumWf
		*c = value
	case "EH":
		value := CountryEnumEh
		*c = value
	case "YE":
		value := CountryEnumYe
		*c = value
	case "ZM":
		value := CountryEnumZm
		*c = value
	case "ZW":
		value := CountryEnumZw
		*c = value
	}
	return nil
}

// # The DataPassthrough Object
//
// ### Description
//
// The `DataPassthrough` object is used to send information to an otherwise-unsupported third-party endpoint.
//
// ### Usage Example
//
// Create a `DataPassthrough` to get team hierarchies from your Rippling integration.
type DataPassthroughRequest struct {
	Method          MethodEnum `json:"method,omitempty"`
	Path            string     `json:"path"`
	BaseUrlOverride *string    `json:"base_url_override,omitempty"`
	Data            *string    `json:"data,omitempty"`
	// Pass an array of `MultipartFormField` objects in here instead of using the `data` param if `request_format` is set to `MULTIPART`.
	MultipartFormData []*MultipartFormFieldRequest `json:"multipart_form_data,omitempty"`
	// The headers to use for the request (Merge will handle the account's authorization headers). `Content-Type` header is required for passthrough. Choose content type corresponding to expected format of receiving server.
	Headers       map[string]any     `json:"headers,omitempty"`
	RequestFormat *RequestFormatEnum `json:"request_format,omitempty"`
	// Optional. If true, the response will always be an object of the form `{"type": T, "value": ...}` where `T` will be one of `string, boolean, number, null, array, object`.
	NormalizeResponse *bool `json:"normalize_response,omitempty"`
}

type DebugModeLog struct {
	LogId         string                `json:"log_id"`
	DashboardView string                `json:"dashboard_view"`
	LogSummary    *DebugModelLogSummary `json:"log_summary,omitempty"`
}

type DebugModelLogSummary struct {
	Url        string `json:"url"`
	Method     string `json:"method"`
	StatusCode int    `json:"status_code"`
}

// # The Deduction Object
//
// ### Description
//
// The `Deduction` object is used to represent an array of the wages withheld from total earnings for the purpose of paying taxes.
//
// ### Usage Example
//
// Fetch from the `LIST Deductions` endpoint and filter by `ID` to show all deductions.
type Deduction struct {
	Id *string `json:"id,omitempty"`
	// The third-party API ID of the matching object.
	RemoteId           *string `json:"remote_id,omitempty"`
	EmployeePayrollRun *string `json:"employee_payroll_run,omitempty"`
	// The deduction's name.
	Name *string `json:"name,omitempty"`
	// The amount of money that is withheld from an employee's gross pay by the employee.
	EmployeeDeduction *float64 `json:"employee_deduction,omitempty"`
	// The amount of money that is withheld on behalf of an employee by the company.
	CompanyDeduction *float64 `json:"company_deduction,omitempty"`
	// Indicates whether or not this object has been deleted in the third party platform.
	RemoteWasDeleted *bool      `json:"remote_was_deleted,omitempty"`
	CreatedAt        *time.Time `json:"created_at,omitempty"`
	// This is the datetime that this object was last updated by Merge
	ModifiedAt    *time.Time     `json:"modified_at,omitempty"`
	FieldMappings map[string]any `json:"field_mappings,omitempty"`
	RemoteData    []*RemoteData  `json:"remote_data,omitempty"`
}

// # The Dependent Object
//
// ### Description
//
// The `Dependent` object is used to represent a dependent (e.g. child, spouse, domestic partner, etc) of an `Employee`
//
// ### Usage Example
//
// Fetch from the `LIST Dependents` endpoint and filter by `ID` to show all dependents.
type Dependent struct {
	Id *string `json:"id,omitempty"`
	// The third-party API ID of the matching object.
	RemoteId *string `json:"remote_id,omitempty"`
	// The dependents's first name.
	FirstName *string `json:"first_name,omitempty"`
	// The dependents's middle name.
	MiddleName *string `json:"middle_name,omitempty"`
	// The dependents's last name.
	LastName *string `json:"last_name,omitempty"`
	// The dependent's relationship to the employee.
	//
	// - `CHILD` - CHILD
	// - `SPOUSE` - SPOUSE
	// - `DOMESTIC_PARTNER` - DOMESTIC_PARTNER
	Relationship *DependentRelationship `json:"relationship,omitempty"`
	// The employee this person is a dependent of.
	Employee *string `json:"employee,omitempty"`
	// The dependent's date of birth.
	DateOfBirth *time.Time `json:"date_of_birth,omitempty"`
	// The dependent's gender.
	//
	// - `MALE` - MALE
	// - `FEMALE` - FEMALE
	// - `NON-BINARY` - NON-BINARY
	// - `OTHER` - OTHER
	// - `PREFER_NOT_TO_DISCLOSE` - PREFER_NOT_TO_DISCLOSE
	Gender *DependentGender `json:"gender,omitempty"`
	// The dependent's phone number.
	PhoneNumber *string `json:"phone_number,omitempty"`
	// The dependents's home address.
	HomeLocation *string `json:"home_location,omitempty"`
	// Whether or not the dependent is a student
	IsStudent *bool `json:"is_student,omitempty"`
	// The dependents's social security number.
	Ssn *string `json:"ssn,omitempty"`
	// Indicates whether or not this object has been deleted in the third party platform.
	RemoteWasDeleted *bool      `json:"remote_was_deleted,omitempty"`
	CreatedAt        *time.Time `json:"created_at,omitempty"`
	// This is the datetime that this object was last updated by Merge
	ModifiedAt    *time.Time     `json:"modified_at,omitempty"`
	FieldMappings map[string]any `json:"field_mappings,omitempty"`
	RemoteData    []*RemoteData  `json:"remote_data,omitempty"`
}

// The dependent's gender.
//
// - `MALE` - MALE
// - `FEMALE` - FEMALE
// - `NON-BINARY` - NON-BINARY
// - `OTHER` - OTHER
// - `PREFER_NOT_TO_DISCLOSE` - PREFER_NOT_TO_DISCLOSE
type DependentGender struct {
	typeName   string
	GenderEnum GenderEnum
	String     string
}

func NewDependentGenderFromGenderEnum(value GenderEnum) *DependentGender {
	return &DependentGender{typeName: "genderEnum", GenderEnum: value}
}

func NewDependentGenderFromString(value string) *DependentGender {
	return &DependentGender{typeName: "string", String: value}
}

func (d *DependentGender) UnmarshalJSON(data []byte) error {
	var valueGenderEnum GenderEnum
	if err := json.Unmarshal(data, &valueGenderEnum); err == nil {
		d.typeName = "genderEnum"
		d.GenderEnum = valueGenderEnum
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		d.typeName = "string"
		d.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, d)
}

func (d DependentGender) MarshalJSON() ([]byte, error) {
	switch d.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", d.typeName, d)
	case "genderEnum":
		return json.Marshal(d.GenderEnum)
	case "string":
		return json.Marshal(d.String)
	}
}

type DependentGenderVisitor interface {
	VisitGenderEnum(GenderEnum) error
	VisitString(string) error
}

func (d *DependentGender) Accept(visitor DependentGenderVisitor) error {
	switch d.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", d.typeName, d)
	case "genderEnum":
		return visitor.VisitGenderEnum(d.GenderEnum)
	case "string":
		return visitor.VisitString(d.String)
	}
}

// The dependent's relationship to the employee.
//
// - `CHILD` - CHILD
// - `SPOUSE` - SPOUSE
// - `DOMESTIC_PARTNER` - DOMESTIC_PARTNER
type DependentRelationship struct {
	typeName         string
	RelationshipEnum RelationshipEnum
	String           string
}

func NewDependentRelationshipFromRelationshipEnum(value RelationshipEnum) *DependentRelationship {
	return &DependentRelationship{typeName: "relationshipEnum", RelationshipEnum: value}
}

func NewDependentRelationshipFromString(value string) *DependentRelationship {
	return &DependentRelationship{typeName: "string", String: value}
}

func (d *DependentRelationship) UnmarshalJSON(data []byte) error {
	var valueRelationshipEnum RelationshipEnum
	if err := json.Unmarshal(data, &valueRelationshipEnum); err == nil {
		d.typeName = "relationshipEnum"
		d.RelationshipEnum = valueRelationshipEnum
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		d.typeName = "string"
		d.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, d)
}

func (d DependentRelationship) MarshalJSON() ([]byte, error) {
	switch d.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", d.typeName, d)
	case "relationshipEnum":
		return json.Marshal(d.RelationshipEnum)
	case "string":
		return json.Marshal(d.String)
	}
}

type DependentRelationshipVisitor interface {
	VisitRelationshipEnum(RelationshipEnum) error
	VisitString(string) error
}

func (d *DependentRelationship) Accept(visitor DependentRelationshipVisitor) error {
	switch d.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", d.typeName, d)
	case "relationshipEnum":
		return visitor.VisitRelationshipEnum(d.RelationshipEnum)
	case "string":
		return visitor.VisitString(d.String)
	}
}

// # The Earning Object
//
// ### Description
//
// The `Earning` object is used to represent an array of different compensations that an employee receives within specific wage categories.
//
// ### Usage Example
//
// Fetch from the `LIST Earnings` endpoint and filter by `ID` to show all earnings.
type Earning struct {
	Id *string `json:"id,omitempty"`
	// The third-party API ID of the matching object.
	RemoteId           *string `json:"remote_id,omitempty"`
	EmployeePayrollRun *string `json:"employee_payroll_run,omitempty"`
	// The amount earned.
	Amount *float64 `json:"amount,omitempty"`
	// The type of earning.
	//
	// - `SALARY` - SALARY
	// - `REIMBURSEMENT` - REIMBURSEMENT
	// - `OVERTIME` - OVERTIME
	// - `BONUS` - BONUS
	Type *EarningType `json:"type,omitempty"`
	// Indicates whether or not this object has been deleted in the third party platform.
	RemoteWasDeleted *bool      `json:"remote_was_deleted,omitempty"`
	CreatedAt        *time.Time `json:"created_at,omitempty"`
	// This is the datetime that this object was last updated by Merge
	ModifiedAt    *time.Time     `json:"modified_at,omitempty"`
	FieldMappings map[string]any `json:"field_mappings,omitempty"`
	RemoteData    []*RemoteData  `json:"remote_data,omitempty"`
}

// The type of earning.
//
// - `SALARY` - SALARY
// - `REIMBURSEMENT` - REIMBURSEMENT
// - `OVERTIME` - OVERTIME
// - `BONUS` - BONUS
type EarningType struct {
	typeName        string
	EarningTypeEnum EarningTypeEnum
	String          string
}

func NewEarningTypeFromEarningTypeEnum(value EarningTypeEnum) *EarningType {
	return &EarningType{typeName: "earningTypeEnum", EarningTypeEnum: value}
}

func NewEarningTypeFromString(value string) *EarningType {
	return &EarningType{typeName: "string", String: value}
}

func (e *EarningType) UnmarshalJSON(data []byte) error {
	var valueEarningTypeEnum EarningTypeEnum
	if err := json.Unmarshal(data, &valueEarningTypeEnum); err == nil {
		e.typeName = "earningTypeEnum"
		e.EarningTypeEnum = valueEarningTypeEnum
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		e.typeName = "string"
		e.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, e)
}

func (e EarningType) MarshalJSON() ([]byte, error) {
	switch e.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", e.typeName, e)
	case "earningTypeEnum":
		return json.Marshal(e.EarningTypeEnum)
	case "string":
		return json.Marshal(e.String)
	}
}

type EarningTypeVisitor interface {
	VisitEarningTypeEnum(EarningTypeEnum) error
	VisitString(string) error
}

func (e *EarningType) Accept(visitor EarningTypeVisitor) error {
	switch e.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", e.typeName, e)
	case "earningTypeEnum":
		return visitor.VisitEarningTypeEnum(e.EarningTypeEnum)
	case "string":
		return visitor.VisitString(e.String)
	}
}

// - `SALARY` - SALARY
// - `REIMBURSEMENT` - REIMBURSEMENT
// - `OVERTIME` - OVERTIME
// - `BONUS` - BONUS
type EarningTypeEnum uint

const (
	EarningTypeEnumSalary EarningTypeEnum = iota + 1
	EarningTypeEnumReimbursement
	EarningTypeEnumOvertime
	EarningTypeEnumBonus
)

func (e EarningTypeEnum) String() string {
	switch e {
	default:
		return strconv.Itoa(int(e))
	case EarningTypeEnumSalary:
		return "SALARY"
	case EarningTypeEnumReimbursement:
		return "REIMBURSEMENT"
	case EarningTypeEnumOvertime:
		return "OVERTIME"
	case EarningTypeEnumBonus:
		return "BONUS"
	}
}

func (e EarningTypeEnum) MarshalJSON() ([]byte, error) {
	return []byte(fmt.Sprintf("%q", e.String())), nil
}

func (e *EarningTypeEnum) UnmarshalJSON(data []byte) error {
	var raw string
	if err := json.Unmarshal(data, &raw); err != nil {
		return err
	}
	switch raw {
	case "SALARY":
		value := EarningTypeEnumSalary
		*e = value
	case "REIMBURSEMENT":
		value := EarningTypeEnumReimbursement
		*e = value
	case "OVERTIME":
		value := EarningTypeEnumOvertime
		*e = value
	case "BONUS":
		value := EarningTypeEnumBonus
		*e = value
	}
	return nil
}

// # The Employee Object
//
// ### Description
//
// The `Employee` object is used to represent any person who has been employed by a company.
//
// ### Usage Example
//
// Fetch from the `LIST Employee` endpoint and filter by `ID` to show all employees.
type Employee struct {
	Id *string `json:"id,omitempty"`
	// The third-party API ID of the matching object.
	RemoteId *string `json:"remote_id,omitempty"`
	// The employee's number that appears in the third-party integration's UI.
	EmployeeNumber *string `json:"employee_number,omitempty"`
	// The ID of the employee's company.
	Company *EmployeeCompany `json:"company,omitempty"`
	// The employee's first name.
	FirstName *string `json:"first_name,omitempty"`
	// The employee's last name.
	LastName *string `json:"last_name,omitempty"`
	// The employee's preferred first name.
	PreferredName *string `json:"preferred_name,omitempty"`
	// The employee's full name, to use for display purposes. If a preferred first name is available, the full name will include the preferred first name.
	DisplayFullName *string `json:"display_full_name,omitempty"`
	// The employee's username that appears in the remote UI.
	Username *string               `json:"username,omitempty"`
	Groups   []*EmployeeGroupsItem `json:"groups,omitempty"`
	// The employee's work email.
	WorkEmail *string `json:"work_email,omitempty"`
	// The employee's personal email.
	PersonalEmail *string `json:"personal_email,omitempty"`
	// The employee's mobile phone number.
	MobilePhoneNumber *string `json:"mobile_phone_number,omitempty"`
	// Array of `Employment` IDs for this Employee.
	Employments []*EmployeeEmploymentsItem `json:"employments,omitempty"`
	// The employee's home address.
	HomeLocation *EmployeeHomeLocation `json:"home_location,omitempty"`
	// The employee's work address.
	WorkLocation *EmployeeWorkLocation `json:"work_location,omitempty"`
	// The employee ID of the employee's manager.
	Manager *EmployeeManager `json:"manager,omitempty"`
	// The employee's team.
	Team *EmployeeTeam `json:"team,omitempty"`
	// The employee's pay group
	PayGroup *EmployeePayGroup `json:"pay_group,omitempty"`
	// The employee's social security number.
	Ssn *string `json:"ssn,omitempty"`
	// The employee's gender.
	//
	// - `MALE` - MALE
	// - `FEMALE` - FEMALE
	// - `NON-BINARY` - NON-BINARY
	// - `OTHER` - OTHER
	// - `PREFER_NOT_TO_DISCLOSE` - PREFER_NOT_TO_DISCLOSE
	Gender *EmployeeGender `json:"gender,omitempty"`
	// The employee's ethnicity.
	//
	// - `AMERICAN_INDIAN_OR_ALASKA_NATIVE` - AMERICAN_INDIAN_OR_ALASKA_NATIVE
	// - `ASIAN_OR_INDIAN_SUBCONTINENT` - ASIAN_OR_INDIAN_SUBCONTINENT
	// - `BLACK_OR_AFRICAN_AMERICAN` - BLACK_OR_AFRICAN_AMERICAN
	// - `HISPANIC_OR_LATINO` - HISPANIC_OR_LATINO
	// - `NATIVE_HAWAIIAN_OR_OTHER_PACIFIC_ISLANDER` - NATIVE_HAWAIIAN_OR_OTHER_PACIFIC_ISLANDER
	// - `TWO_OR_MORE_RACES` - TWO_OR_MORE_RACES
	// - `WHITE` - WHITE
	// - `PREFER_NOT_TO_DISCLOSE` - PREFER_NOT_TO_DISCLOSE
	Ethnicity *EmployeeEthnicity `json:"ethnicity,omitempty"`
	// The employee's filing status as related to marital status.
	//
	// - `SINGLE` - SINGLE
	// - `MARRIED_FILING_JOINTLY` - MARRIED_FILING_JOINTLY
	// - `MARRIED_FILING_SEPARATELY` - MARRIED_FILING_SEPARATELY
	// - `HEAD_OF_HOUSEHOLD` - HEAD_OF_HOUSEHOLD
	// - `QUALIFYING_WIDOW_OR_WIDOWER_WITH_DEPENDENT_CHILD` - QUALIFYING_WIDOW_OR_WIDOWER_WITH_DEPENDENT_CHILD
	MaritalStatus *EmployeeMaritalStatus `json:"marital_status,omitempty"`
	// The employee's date of birth.
	DateOfBirth *time.Time `json:"date_of_birth,omitempty"`
	// The date that the employee was hired, usually the day that an offer letter is signed. If an employee has multiple hire dates from previous employments, this represents the most recent hire date. Note: If you're looking for the employee's start date, refer to the start_date field.
	HireDate *time.Time `json:"hire_date,omitempty"`
	// The date that the employee started working. If an employee was rehired, the most recent start date will be returned.
	StartDate *time.Time `json:"start_date,omitempty"`
	// When the third party's employee was created.
	RemoteCreatedAt *time.Time `json:"remote_created_at,omitempty"`
	// The employment status of the employee.
	//
	// - `ACTIVE` - ACTIVE
	// - `PENDING` - PENDING
	// - `INACTIVE` - INACTIVE
	EmploymentStatus *EmployeeEmploymentStatus `json:"employment_status,omitempty"`
	// The employee's termination date.
	TerminationDate *time.Time `json:"termination_date,omitempty"`
	// The URL of the employee's avatar image.
	Avatar *string `json:"avatar,omitempty"`
	// Custom fields configured for a given model.
	CustomFields     map[string]any `json:"custom_fields,omitempty"`
	RemoteWasDeleted *bool          `json:"remote_was_deleted,omitempty"`
	CreatedAt        *time.Time     `json:"created_at,omitempty"`
	// This is the datetime that this object was last updated by Merge
	ModifiedAt    *time.Time     `json:"modified_at,omitempty"`
	FieldMappings map[string]any `json:"field_mappings,omitempty"`
	RemoteData    []*RemoteData  `json:"remote_data,omitempty"`
}

// The ID of the employee's company.
type EmployeeCompany struct {
	typeName string
	String   string
	Company  *Company
}

func NewEmployeeCompanyFromString(value string) *EmployeeCompany {
	return &EmployeeCompany{typeName: "string", String: value}
}

func NewEmployeeCompanyFromCompany(value *Company) *EmployeeCompany {
	return &EmployeeCompany{typeName: "company", Company: value}
}

func (e *EmployeeCompany) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		e.typeName = "string"
		e.String = valueString
		return nil
	}
	valueCompany := new(Company)
	if err := json.Unmarshal(data, &valueCompany); err == nil {
		e.typeName = "company"
		e.Company = valueCompany
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, e)
}

func (e EmployeeCompany) MarshalJSON() ([]byte, error) {
	switch e.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", e.typeName, e)
	case "string":
		return json.Marshal(e.String)
	case "company":
		return json.Marshal(e.Company)
	}
}

type EmployeeCompanyVisitor interface {
	VisitString(string) error
	VisitCompany(*Company) error
}

func (e *EmployeeCompany) Accept(visitor EmployeeCompanyVisitor) error {
	switch e.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", e.typeName, e)
	case "string":
		return visitor.VisitString(e.String)
	case "company":
		return visitor.VisitCompany(e.Company)
	}
}

// The employment status of the employee.
//
// - `ACTIVE` - ACTIVE
// - `PENDING` - PENDING
// - `INACTIVE` - INACTIVE
type EmployeeEmploymentStatus struct {
	typeName             string
	EmploymentStatusEnum EmploymentStatusEnum
	String               string
}

func NewEmployeeEmploymentStatusFromEmploymentStatusEnum(value EmploymentStatusEnum) *EmployeeEmploymentStatus {
	return &EmployeeEmploymentStatus{typeName: "employmentStatusEnum", EmploymentStatusEnum: value}
}

func NewEmployeeEmploymentStatusFromString(value string) *EmployeeEmploymentStatus {
	return &EmployeeEmploymentStatus{typeName: "string", String: value}
}

func (e *EmployeeEmploymentStatus) UnmarshalJSON(data []byte) error {
	var valueEmploymentStatusEnum EmploymentStatusEnum
	if err := json.Unmarshal(data, &valueEmploymentStatusEnum); err == nil {
		e.typeName = "employmentStatusEnum"
		e.EmploymentStatusEnum = valueEmploymentStatusEnum
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		e.typeName = "string"
		e.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, e)
}

func (e EmployeeEmploymentStatus) MarshalJSON() ([]byte, error) {
	switch e.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", e.typeName, e)
	case "employmentStatusEnum":
		return json.Marshal(e.EmploymentStatusEnum)
	case "string":
		return json.Marshal(e.String)
	}
}

type EmployeeEmploymentStatusVisitor interface {
	VisitEmploymentStatusEnum(EmploymentStatusEnum) error
	VisitString(string) error
}

func (e *EmployeeEmploymentStatus) Accept(visitor EmployeeEmploymentStatusVisitor) error {
	switch e.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", e.typeName, e)
	case "employmentStatusEnum":
		return visitor.VisitEmploymentStatusEnum(e.EmploymentStatusEnum)
	case "string":
		return visitor.VisitString(e.String)
	}
}

type EmployeeEmploymentsItem struct {
	typeName   string
	String     string
	Employment *Employment
}

func NewEmployeeEmploymentsItemFromString(value string) *EmployeeEmploymentsItem {
	return &EmployeeEmploymentsItem{typeName: "string", String: value}
}

func NewEmployeeEmploymentsItemFromEmployment(value *Employment) *EmployeeEmploymentsItem {
	return &EmployeeEmploymentsItem{typeName: "employment", Employment: value}
}

func (e *EmployeeEmploymentsItem) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		e.typeName = "string"
		e.String = valueString
		return nil
	}
	valueEmployment := new(Employment)
	if err := json.Unmarshal(data, &valueEmployment); err == nil {
		e.typeName = "employment"
		e.Employment = valueEmployment
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, e)
}

func (e EmployeeEmploymentsItem) MarshalJSON() ([]byte, error) {
	switch e.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", e.typeName, e)
	case "string":
		return json.Marshal(e.String)
	case "employment":
		return json.Marshal(e.Employment)
	}
}

type EmployeeEmploymentsItemVisitor interface {
	VisitString(string) error
	VisitEmployment(*Employment) error
}

func (e *EmployeeEmploymentsItem) Accept(visitor EmployeeEmploymentsItemVisitor) error {
	switch e.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", e.typeName, e)
	case "string":
		return visitor.VisitString(e.String)
	case "employment":
		return visitor.VisitEmployment(e.Employment)
	}
}

// The employee's ethnicity.
//
// - `AMERICAN_INDIAN_OR_ALASKA_NATIVE` - AMERICAN_INDIAN_OR_ALASKA_NATIVE
// - `ASIAN_OR_INDIAN_SUBCONTINENT` - ASIAN_OR_INDIAN_SUBCONTINENT
// - `BLACK_OR_AFRICAN_AMERICAN` - BLACK_OR_AFRICAN_AMERICAN
// - `HISPANIC_OR_LATINO` - HISPANIC_OR_LATINO
// - `NATIVE_HAWAIIAN_OR_OTHER_PACIFIC_ISLANDER` - NATIVE_HAWAIIAN_OR_OTHER_PACIFIC_ISLANDER
// - `TWO_OR_MORE_RACES` - TWO_OR_MORE_RACES
// - `WHITE` - WHITE
// - `PREFER_NOT_TO_DISCLOSE` - PREFER_NOT_TO_DISCLOSE
type EmployeeEthnicity struct {
	typeName      string
	EthnicityEnum EthnicityEnum
	String        string
}

func NewEmployeeEthnicityFromEthnicityEnum(value EthnicityEnum) *EmployeeEthnicity {
	return &EmployeeEthnicity{typeName: "ethnicityEnum", EthnicityEnum: value}
}

func NewEmployeeEthnicityFromString(value string) *EmployeeEthnicity {
	return &EmployeeEthnicity{typeName: "string", String: value}
}

func (e *EmployeeEthnicity) UnmarshalJSON(data []byte) error {
	var valueEthnicityEnum EthnicityEnum
	if err := json.Unmarshal(data, &valueEthnicityEnum); err == nil {
		e.typeName = "ethnicityEnum"
		e.EthnicityEnum = valueEthnicityEnum
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		e.typeName = "string"
		e.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, e)
}

func (e EmployeeEthnicity) MarshalJSON() ([]byte, error) {
	switch e.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", e.typeName, e)
	case "ethnicityEnum":
		return json.Marshal(e.EthnicityEnum)
	case "string":
		return json.Marshal(e.String)
	}
}

type EmployeeEthnicityVisitor interface {
	VisitEthnicityEnum(EthnicityEnum) error
	VisitString(string) error
}

func (e *EmployeeEthnicity) Accept(visitor EmployeeEthnicityVisitor) error {
	switch e.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", e.typeName, e)
	case "ethnicityEnum":
		return visitor.VisitEthnicityEnum(e.EthnicityEnum)
	case "string":
		return visitor.VisitString(e.String)
	}
}

// The employee's gender.
//
// - `MALE` - MALE
// - `FEMALE` - FEMALE
// - `NON-BINARY` - NON-BINARY
// - `OTHER` - OTHER
// - `PREFER_NOT_TO_DISCLOSE` - PREFER_NOT_TO_DISCLOSE
type EmployeeGender struct {
	typeName   string
	GenderEnum GenderEnum
	String     string
}

func NewEmployeeGenderFromGenderEnum(value GenderEnum) *EmployeeGender {
	return &EmployeeGender{typeName: "genderEnum", GenderEnum: value}
}

func NewEmployeeGenderFromString(value string) *EmployeeGender {
	return &EmployeeGender{typeName: "string", String: value}
}

func (e *EmployeeGender) UnmarshalJSON(data []byte) error {
	var valueGenderEnum GenderEnum
	if err := json.Unmarshal(data, &valueGenderEnum); err == nil {
		e.typeName = "genderEnum"
		e.GenderEnum = valueGenderEnum
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		e.typeName = "string"
		e.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, e)
}

func (e EmployeeGender) MarshalJSON() ([]byte, error) {
	switch e.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", e.typeName, e)
	case "genderEnum":
		return json.Marshal(e.GenderEnum)
	case "string":
		return json.Marshal(e.String)
	}
}

type EmployeeGenderVisitor interface {
	VisitGenderEnum(GenderEnum) error
	VisitString(string) error
}

func (e *EmployeeGender) Accept(visitor EmployeeGenderVisitor) error {
	switch e.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", e.typeName, e)
	case "genderEnum":
		return visitor.VisitGenderEnum(e.GenderEnum)
	case "string":
		return visitor.VisitString(e.String)
	}
}

type EmployeeGroupsItem struct {
	typeName string
	String   string
	Group    *Group
}

func NewEmployeeGroupsItemFromString(value string) *EmployeeGroupsItem {
	return &EmployeeGroupsItem{typeName: "string", String: value}
}

func NewEmployeeGroupsItemFromGroup(value *Group) *EmployeeGroupsItem {
	return &EmployeeGroupsItem{typeName: "group", Group: value}
}

func (e *EmployeeGroupsItem) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		e.typeName = "string"
		e.String = valueString
		return nil
	}
	valueGroup := new(Group)
	if err := json.Unmarshal(data, &valueGroup); err == nil {
		e.typeName = "group"
		e.Group = valueGroup
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, e)
}

func (e EmployeeGroupsItem) MarshalJSON() ([]byte, error) {
	switch e.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", e.typeName, e)
	case "string":
		return json.Marshal(e.String)
	case "group":
		return json.Marshal(e.Group)
	}
}

type EmployeeGroupsItemVisitor interface {
	VisitString(string) error
	VisitGroup(*Group) error
}

func (e *EmployeeGroupsItem) Accept(visitor EmployeeGroupsItemVisitor) error {
	switch e.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", e.typeName, e)
	case "string":
		return visitor.VisitString(e.String)
	case "group":
		return visitor.VisitGroup(e.Group)
	}
}

// The employee's home address.
type EmployeeHomeLocation struct {
	typeName string
	String   string
	Location *Location
}

func NewEmployeeHomeLocationFromString(value string) *EmployeeHomeLocation {
	return &EmployeeHomeLocation{typeName: "string", String: value}
}

func NewEmployeeHomeLocationFromLocation(value *Location) *EmployeeHomeLocation {
	return &EmployeeHomeLocation{typeName: "location", Location: value}
}

func (e *EmployeeHomeLocation) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		e.typeName = "string"
		e.String = valueString
		return nil
	}
	valueLocation := new(Location)
	if err := json.Unmarshal(data, &valueLocation); err == nil {
		e.typeName = "location"
		e.Location = valueLocation
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, e)
}

func (e EmployeeHomeLocation) MarshalJSON() ([]byte, error) {
	switch e.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", e.typeName, e)
	case "string":
		return json.Marshal(e.String)
	case "location":
		return json.Marshal(e.Location)
	}
}

type EmployeeHomeLocationVisitor interface {
	VisitString(string) error
	VisitLocation(*Location) error
}

func (e *EmployeeHomeLocation) Accept(visitor EmployeeHomeLocationVisitor) error {
	switch e.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", e.typeName, e)
	case "string":
		return visitor.VisitString(e.String)
	case "location":
		return visitor.VisitLocation(e.Location)
	}
}

// The employee ID of the employee's manager.
type EmployeeManager struct {
	typeName string
	String   string
	Employee *Employee
}

func NewEmployeeManagerFromString(value string) *EmployeeManager {
	return &EmployeeManager{typeName: "string", String: value}
}

func NewEmployeeManagerFromEmployee(value *Employee) *EmployeeManager {
	return &EmployeeManager{typeName: "employee", Employee: value}
}

func (e *EmployeeManager) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		e.typeName = "string"
		e.String = valueString
		return nil
	}
	valueEmployee := new(Employee)
	if err := json.Unmarshal(data, &valueEmployee); err == nil {
		e.typeName = "employee"
		e.Employee = valueEmployee
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, e)
}

func (e EmployeeManager) MarshalJSON() ([]byte, error) {
	switch e.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", e.typeName, e)
	case "string":
		return json.Marshal(e.String)
	case "employee":
		return json.Marshal(e.Employee)
	}
}

type EmployeeManagerVisitor interface {
	VisitString(string) error
	VisitEmployee(*Employee) error
}

func (e *EmployeeManager) Accept(visitor EmployeeManagerVisitor) error {
	switch e.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", e.typeName, e)
	case "string":
		return visitor.VisitString(e.String)
	case "employee":
		return visitor.VisitEmployee(e.Employee)
	}
}

// The employee's filing status as related to marital status.
//
// - `SINGLE` - SINGLE
// - `MARRIED_FILING_JOINTLY` - MARRIED_FILING_JOINTLY
// - `MARRIED_FILING_SEPARATELY` - MARRIED_FILING_SEPARATELY
// - `HEAD_OF_HOUSEHOLD` - HEAD_OF_HOUSEHOLD
// - `QUALIFYING_WIDOW_OR_WIDOWER_WITH_DEPENDENT_CHILD` - QUALIFYING_WIDOW_OR_WIDOWER_WITH_DEPENDENT_CHILD
type EmployeeMaritalStatus struct {
	typeName          string
	MaritalStatusEnum MaritalStatusEnum
	String            string
}

func NewEmployeeMaritalStatusFromMaritalStatusEnum(value MaritalStatusEnum) *EmployeeMaritalStatus {
	return &EmployeeMaritalStatus{typeName: "maritalStatusEnum", MaritalStatusEnum: value}
}

func NewEmployeeMaritalStatusFromString(value string) *EmployeeMaritalStatus {
	return &EmployeeMaritalStatus{typeName: "string", String: value}
}

func (e *EmployeeMaritalStatus) UnmarshalJSON(data []byte) error {
	var valueMaritalStatusEnum MaritalStatusEnum
	if err := json.Unmarshal(data, &valueMaritalStatusEnum); err == nil {
		e.typeName = "maritalStatusEnum"
		e.MaritalStatusEnum = valueMaritalStatusEnum
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		e.typeName = "string"
		e.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, e)
}

func (e EmployeeMaritalStatus) MarshalJSON() ([]byte, error) {
	switch e.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", e.typeName, e)
	case "maritalStatusEnum":
		return json.Marshal(e.MaritalStatusEnum)
	case "string":
		return json.Marshal(e.String)
	}
}

type EmployeeMaritalStatusVisitor interface {
	VisitMaritalStatusEnum(MaritalStatusEnum) error
	VisitString(string) error
}

func (e *EmployeeMaritalStatus) Accept(visitor EmployeeMaritalStatusVisitor) error {
	switch e.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", e.typeName, e)
	case "maritalStatusEnum":
		return visitor.VisitMaritalStatusEnum(e.MaritalStatusEnum)
	case "string":
		return visitor.VisitString(e.String)
	}
}

// The employee's pay group
type EmployeePayGroup struct {
	typeName string
	String   string
	PayGroup *PayGroup
}

func NewEmployeePayGroupFromString(value string) *EmployeePayGroup {
	return &EmployeePayGroup{typeName: "string", String: value}
}

func NewEmployeePayGroupFromPayGroup(value *PayGroup) *EmployeePayGroup {
	return &EmployeePayGroup{typeName: "payGroup", PayGroup: value}
}

func (e *EmployeePayGroup) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		e.typeName = "string"
		e.String = valueString
		return nil
	}
	valuePayGroup := new(PayGroup)
	if err := json.Unmarshal(data, &valuePayGroup); err == nil {
		e.typeName = "payGroup"
		e.PayGroup = valuePayGroup
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, e)
}

func (e EmployeePayGroup) MarshalJSON() ([]byte, error) {
	switch e.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", e.typeName, e)
	case "string":
		return json.Marshal(e.String)
	case "payGroup":
		return json.Marshal(e.PayGroup)
	}
}

type EmployeePayGroupVisitor interface {
	VisitString(string) error
	VisitPayGroup(*PayGroup) error
}

func (e *EmployeePayGroup) Accept(visitor EmployeePayGroupVisitor) error {
	switch e.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", e.typeName, e)
	case "string":
		return visitor.VisitString(e.String)
	case "payGroup":
		return visitor.VisitPayGroup(e.PayGroup)
	}
}

// # The EmployeePayrollRun Object
//
// ### Description
//
// The `EmployeePayrollRun` object is used to represent an employee's pay statement for a specific payroll run.
//
// ### Usage Example
//
// Fetch from the `LIST EmployeePayrollRun` endpoint and filter by `ID` to show all employee payroll runs.
type EmployeePayrollRun struct {
	Id *string `json:"id,omitempty"`
	// The third-party API ID of the matching object.
	RemoteId *string `json:"remote_id,omitempty"`
	// The employee whose payroll is being run.
	Employee *EmployeePayrollRunEmployee `json:"employee,omitempty"`
	// The payroll being run.
	PayrollRun *EmployeePayrollRunPayrollRun `json:"payroll_run,omitempty"`
	// The total earnings throughout a given period for an employee before any deductions are made.
	GrossPay *float64 `json:"gross_pay,omitempty"`
	// The take-home pay throughout a given period for an employee after deductions are made.
	NetPay *float64 `json:"net_pay,omitempty"`
	// The day and time the payroll run started.
	StartDate *time.Time `json:"start_date,omitempty"`
	// The day and time the payroll run ended.
	EndDate *time.Time `json:"end_date,omitempty"`
	// The day and time the payroll run was checked.
	CheckDate  *time.Time   `json:"check_date,omitempty"`
	Earnings   []*Earning   `json:"earnings,omitempty"`
	Deductions []*Deduction `json:"deductions,omitempty"`
	Taxes      []*Tax       `json:"taxes,omitempty"`
	// Indicates whether or not this object has been deleted in the third party platform.
	RemoteWasDeleted *bool      `json:"remote_was_deleted,omitempty"`
	CreatedAt        *time.Time `json:"created_at,omitempty"`
	// This is the datetime that this object was last updated by Merge
	ModifiedAt    *time.Time     `json:"modified_at,omitempty"`
	FieldMappings map[string]any `json:"field_mappings,omitempty"`
	RemoteData    []*RemoteData  `json:"remote_data,omitempty"`
}

// The employee whose payroll is being run.
type EmployeePayrollRunEmployee struct {
	typeName string
	String   string
	Employee *Employee
}

func NewEmployeePayrollRunEmployeeFromString(value string) *EmployeePayrollRunEmployee {
	return &EmployeePayrollRunEmployee{typeName: "string", String: value}
}

func NewEmployeePayrollRunEmployeeFromEmployee(value *Employee) *EmployeePayrollRunEmployee {
	return &EmployeePayrollRunEmployee{typeName: "employee", Employee: value}
}

func (e *EmployeePayrollRunEmployee) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		e.typeName = "string"
		e.String = valueString
		return nil
	}
	valueEmployee := new(Employee)
	if err := json.Unmarshal(data, &valueEmployee); err == nil {
		e.typeName = "employee"
		e.Employee = valueEmployee
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, e)
}

func (e EmployeePayrollRunEmployee) MarshalJSON() ([]byte, error) {
	switch e.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", e.typeName, e)
	case "string":
		return json.Marshal(e.String)
	case "employee":
		return json.Marshal(e.Employee)
	}
}

type EmployeePayrollRunEmployeeVisitor interface {
	VisitString(string) error
	VisitEmployee(*Employee) error
}

func (e *EmployeePayrollRunEmployee) Accept(visitor EmployeePayrollRunEmployeeVisitor) error {
	switch e.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", e.typeName, e)
	case "string":
		return visitor.VisitString(e.String)
	case "employee":
		return visitor.VisitEmployee(e.Employee)
	}
}

// The payroll being run.
type EmployeePayrollRunPayrollRun struct {
	typeName   string
	String     string
	PayrollRun *PayrollRun
}

func NewEmployeePayrollRunPayrollRunFromString(value string) *EmployeePayrollRunPayrollRun {
	return &EmployeePayrollRunPayrollRun{typeName: "string", String: value}
}

func NewEmployeePayrollRunPayrollRunFromPayrollRun(value *PayrollRun) *EmployeePayrollRunPayrollRun {
	return &EmployeePayrollRunPayrollRun{typeName: "payrollRun", PayrollRun: value}
}

func (e *EmployeePayrollRunPayrollRun) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		e.typeName = "string"
		e.String = valueString
		return nil
	}
	valuePayrollRun := new(PayrollRun)
	if err := json.Unmarshal(data, &valuePayrollRun); err == nil {
		e.typeName = "payrollRun"
		e.PayrollRun = valuePayrollRun
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, e)
}

func (e EmployeePayrollRunPayrollRun) MarshalJSON() ([]byte, error) {
	switch e.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", e.typeName, e)
	case "string":
		return json.Marshal(e.String)
	case "payrollRun":
		return json.Marshal(e.PayrollRun)
	}
}

type EmployeePayrollRunPayrollRunVisitor interface {
	VisitString(string) error
	VisitPayrollRun(*PayrollRun) error
}

func (e *EmployeePayrollRunPayrollRun) Accept(visitor EmployeePayrollRunPayrollRunVisitor) error {
	switch e.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", e.typeName, e)
	case "string":
		return visitor.VisitString(e.String)
	case "payrollRun":
		return visitor.VisitPayrollRun(e.PayrollRun)
	}
}

// # The Employee Object
//
// ### Description
//
// The `Employee` object is used to represent any person who has been employed by a company.
//
// ### Usage Example
//
// Fetch from the `LIST Employee` endpoint and filter by `ID` to show all employees.
type EmployeeRequest struct {
	// The employee's number that appears in the third-party integration's UI.
	EmployeeNumber *string `json:"employee_number,omitempty"`
	// The ID of the employee's company.
	Company *EmployeeRequestCompany `json:"company,omitempty"`
	// The employee's first name.
	FirstName *string `json:"first_name,omitempty"`
	// The employee's last name.
	LastName *string `json:"last_name,omitempty"`
	// The employee's preferred first name.
	PreferredName *string `json:"preferred_name,omitempty"`
	// The employee's full name, to use for display purposes. If a preferred first name is available, the full name will include the preferred first name.
	DisplayFullName *string `json:"display_full_name,omitempty"`
	// The employee's username that appears in the remote UI.
	Username *string                      `json:"username,omitempty"`
	Groups   []*EmployeeRequestGroupsItem `json:"groups,omitempty"`
	// The employee's work email.
	WorkEmail *string `json:"work_email,omitempty"`
	// The employee's personal email.
	PersonalEmail *string `json:"personal_email,omitempty"`
	// The employee's mobile phone number.
	MobilePhoneNumber *string `json:"mobile_phone_number,omitempty"`
	// Array of `Employment` IDs for this Employee.
	Employments []*EmployeeRequestEmploymentsItem `json:"employments,omitempty"`
	// The employee's home address.
	HomeLocation *EmployeeRequestHomeLocation `json:"home_location,omitempty"`
	// The employee's work address.
	WorkLocation *EmployeeRequestWorkLocation `json:"work_location,omitempty"`
	// The employee ID of the employee's manager.
	Manager *EmployeeRequestManager `json:"manager,omitempty"`
	// The employee's team.
	Team *EmployeeRequestTeam `json:"team,omitempty"`
	// The employee's pay group
	PayGroup *EmployeeRequestPayGroup `json:"pay_group,omitempty"`
	// The employee's social security number.
	Ssn *string `json:"ssn,omitempty"`
	// The employee's gender.
	//
	// - `MALE` - MALE
	// - `FEMALE` - FEMALE
	// - `NON-BINARY` - NON-BINARY
	// - `OTHER` - OTHER
	// - `PREFER_NOT_TO_DISCLOSE` - PREFER_NOT_TO_DISCLOSE
	Gender *EmployeeRequestGender `json:"gender,omitempty"`
	// The employee's ethnicity.
	//
	// - `AMERICAN_INDIAN_OR_ALASKA_NATIVE` - AMERICAN_INDIAN_OR_ALASKA_NATIVE
	// - `ASIAN_OR_INDIAN_SUBCONTINENT` - ASIAN_OR_INDIAN_SUBCONTINENT
	// - `BLACK_OR_AFRICAN_AMERICAN` - BLACK_OR_AFRICAN_AMERICAN
	// - `HISPANIC_OR_LATINO` - HISPANIC_OR_LATINO
	// - `NATIVE_HAWAIIAN_OR_OTHER_PACIFIC_ISLANDER` - NATIVE_HAWAIIAN_OR_OTHER_PACIFIC_ISLANDER
	// - `TWO_OR_MORE_RACES` - TWO_OR_MORE_RACES
	// - `WHITE` - WHITE
	// - `PREFER_NOT_TO_DISCLOSE` - PREFER_NOT_TO_DISCLOSE
	Ethnicity *EmployeeRequestEthnicity `json:"ethnicity,omitempty"`
	// The employee's filing status as related to marital status.
	//
	// - `SINGLE` - SINGLE
	// - `MARRIED_FILING_JOINTLY` - MARRIED_FILING_JOINTLY
	// - `MARRIED_FILING_SEPARATELY` - MARRIED_FILING_SEPARATELY
	// - `HEAD_OF_HOUSEHOLD` - HEAD_OF_HOUSEHOLD
	// - `QUALIFYING_WIDOW_OR_WIDOWER_WITH_DEPENDENT_CHILD` - QUALIFYING_WIDOW_OR_WIDOWER_WITH_DEPENDENT_CHILD
	MaritalStatus *EmployeeRequestMaritalStatus `json:"marital_status,omitempty"`
	// The employee's date of birth.
	DateOfBirth *time.Time `json:"date_of_birth,omitempty"`
	// The date that the employee was hired, usually the day that an offer letter is signed. If an employee has multiple hire dates from previous employments, this represents the most recent hire date. Note: If you're looking for the employee's start date, refer to the start_date field.
	HireDate *time.Time `json:"hire_date,omitempty"`
	// The date that the employee started working. If an employee was rehired, the most recent start date will be returned.
	StartDate *time.Time `json:"start_date,omitempty"`
	// The employment status of the employee.
	//
	// - `ACTIVE` - ACTIVE
	// - `PENDING` - PENDING
	// - `INACTIVE` - INACTIVE
	EmploymentStatus *EmployeeRequestEmploymentStatus `json:"employment_status,omitempty"`
	// The employee's termination date.
	TerminationDate *time.Time `json:"termination_date,omitempty"`
	// The URL of the employee's avatar image.
	Avatar              *string        `json:"avatar,omitempty"`
	IntegrationParams   map[string]any `json:"integration_params,omitempty"`
	LinkedAccountParams map[string]any `json:"linked_account_params,omitempty"`
}

// The ID of the employee's company.
type EmployeeRequestCompany struct {
	typeName string
	String   string
	Company  *Company
}

func NewEmployeeRequestCompanyFromString(value string) *EmployeeRequestCompany {
	return &EmployeeRequestCompany{typeName: "string", String: value}
}

func NewEmployeeRequestCompanyFromCompany(value *Company) *EmployeeRequestCompany {
	return &EmployeeRequestCompany{typeName: "company", Company: value}
}

func (e *EmployeeRequestCompany) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		e.typeName = "string"
		e.String = valueString
		return nil
	}
	valueCompany := new(Company)
	if err := json.Unmarshal(data, &valueCompany); err == nil {
		e.typeName = "company"
		e.Company = valueCompany
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, e)
}

func (e EmployeeRequestCompany) MarshalJSON() ([]byte, error) {
	switch e.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", e.typeName, e)
	case "string":
		return json.Marshal(e.String)
	case "company":
		return json.Marshal(e.Company)
	}
}

type EmployeeRequestCompanyVisitor interface {
	VisitString(string) error
	VisitCompany(*Company) error
}

func (e *EmployeeRequestCompany) Accept(visitor EmployeeRequestCompanyVisitor) error {
	switch e.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", e.typeName, e)
	case "string":
		return visitor.VisitString(e.String)
	case "company":
		return visitor.VisitCompany(e.Company)
	}
}

// The employment status of the employee.
//
// - `ACTIVE` - ACTIVE
// - `PENDING` - PENDING
// - `INACTIVE` - INACTIVE
type EmployeeRequestEmploymentStatus struct {
	typeName             string
	EmploymentStatusEnum EmploymentStatusEnum
	String               string
}

func NewEmployeeRequestEmploymentStatusFromEmploymentStatusEnum(value EmploymentStatusEnum) *EmployeeRequestEmploymentStatus {
	return &EmployeeRequestEmploymentStatus{typeName: "employmentStatusEnum", EmploymentStatusEnum: value}
}

func NewEmployeeRequestEmploymentStatusFromString(value string) *EmployeeRequestEmploymentStatus {
	return &EmployeeRequestEmploymentStatus{typeName: "string", String: value}
}

func (e *EmployeeRequestEmploymentStatus) UnmarshalJSON(data []byte) error {
	var valueEmploymentStatusEnum EmploymentStatusEnum
	if err := json.Unmarshal(data, &valueEmploymentStatusEnum); err == nil {
		e.typeName = "employmentStatusEnum"
		e.EmploymentStatusEnum = valueEmploymentStatusEnum
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		e.typeName = "string"
		e.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, e)
}

func (e EmployeeRequestEmploymentStatus) MarshalJSON() ([]byte, error) {
	switch e.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", e.typeName, e)
	case "employmentStatusEnum":
		return json.Marshal(e.EmploymentStatusEnum)
	case "string":
		return json.Marshal(e.String)
	}
}

type EmployeeRequestEmploymentStatusVisitor interface {
	VisitEmploymentStatusEnum(EmploymentStatusEnum) error
	VisitString(string) error
}

func (e *EmployeeRequestEmploymentStatus) Accept(visitor EmployeeRequestEmploymentStatusVisitor) error {
	switch e.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", e.typeName, e)
	case "employmentStatusEnum":
		return visitor.VisitEmploymentStatusEnum(e.EmploymentStatusEnum)
	case "string":
		return visitor.VisitString(e.String)
	}
}

type EmployeeRequestEmploymentsItem struct {
	typeName   string
	String     string
	Employment *Employment
}

func NewEmployeeRequestEmploymentsItemFromString(value string) *EmployeeRequestEmploymentsItem {
	return &EmployeeRequestEmploymentsItem{typeName: "string", String: value}
}

func NewEmployeeRequestEmploymentsItemFromEmployment(value *Employment) *EmployeeRequestEmploymentsItem {
	return &EmployeeRequestEmploymentsItem{typeName: "employment", Employment: value}
}

func (e *EmployeeRequestEmploymentsItem) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		e.typeName = "string"
		e.String = valueString
		return nil
	}
	valueEmployment := new(Employment)
	if err := json.Unmarshal(data, &valueEmployment); err == nil {
		e.typeName = "employment"
		e.Employment = valueEmployment
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, e)
}

func (e EmployeeRequestEmploymentsItem) MarshalJSON() ([]byte, error) {
	switch e.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", e.typeName, e)
	case "string":
		return json.Marshal(e.String)
	case "employment":
		return json.Marshal(e.Employment)
	}
}

type EmployeeRequestEmploymentsItemVisitor interface {
	VisitString(string) error
	VisitEmployment(*Employment) error
}

func (e *EmployeeRequestEmploymentsItem) Accept(visitor EmployeeRequestEmploymentsItemVisitor) error {
	switch e.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", e.typeName, e)
	case "string":
		return visitor.VisitString(e.String)
	case "employment":
		return visitor.VisitEmployment(e.Employment)
	}
}

// The employee's ethnicity.
//
// - `AMERICAN_INDIAN_OR_ALASKA_NATIVE` - AMERICAN_INDIAN_OR_ALASKA_NATIVE
// - `ASIAN_OR_INDIAN_SUBCONTINENT` - ASIAN_OR_INDIAN_SUBCONTINENT
// - `BLACK_OR_AFRICAN_AMERICAN` - BLACK_OR_AFRICAN_AMERICAN
// - `HISPANIC_OR_LATINO` - HISPANIC_OR_LATINO
// - `NATIVE_HAWAIIAN_OR_OTHER_PACIFIC_ISLANDER` - NATIVE_HAWAIIAN_OR_OTHER_PACIFIC_ISLANDER
// - `TWO_OR_MORE_RACES` - TWO_OR_MORE_RACES
// - `WHITE` - WHITE
// - `PREFER_NOT_TO_DISCLOSE` - PREFER_NOT_TO_DISCLOSE
type EmployeeRequestEthnicity struct {
	typeName      string
	EthnicityEnum EthnicityEnum
	String        string
}

func NewEmployeeRequestEthnicityFromEthnicityEnum(value EthnicityEnum) *EmployeeRequestEthnicity {
	return &EmployeeRequestEthnicity{typeName: "ethnicityEnum", EthnicityEnum: value}
}

func NewEmployeeRequestEthnicityFromString(value string) *EmployeeRequestEthnicity {
	return &EmployeeRequestEthnicity{typeName: "string", String: value}
}

func (e *EmployeeRequestEthnicity) UnmarshalJSON(data []byte) error {
	var valueEthnicityEnum EthnicityEnum
	if err := json.Unmarshal(data, &valueEthnicityEnum); err == nil {
		e.typeName = "ethnicityEnum"
		e.EthnicityEnum = valueEthnicityEnum
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		e.typeName = "string"
		e.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, e)
}

func (e EmployeeRequestEthnicity) MarshalJSON() ([]byte, error) {
	switch e.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", e.typeName, e)
	case "ethnicityEnum":
		return json.Marshal(e.EthnicityEnum)
	case "string":
		return json.Marshal(e.String)
	}
}

type EmployeeRequestEthnicityVisitor interface {
	VisitEthnicityEnum(EthnicityEnum) error
	VisitString(string) error
}

func (e *EmployeeRequestEthnicity) Accept(visitor EmployeeRequestEthnicityVisitor) error {
	switch e.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", e.typeName, e)
	case "ethnicityEnum":
		return visitor.VisitEthnicityEnum(e.EthnicityEnum)
	case "string":
		return visitor.VisitString(e.String)
	}
}

// The employee's gender.
//
// - `MALE` - MALE
// - `FEMALE` - FEMALE
// - `NON-BINARY` - NON-BINARY
// - `OTHER` - OTHER
// - `PREFER_NOT_TO_DISCLOSE` - PREFER_NOT_TO_DISCLOSE
type EmployeeRequestGender struct {
	typeName   string
	GenderEnum GenderEnum
	String     string
}

func NewEmployeeRequestGenderFromGenderEnum(value GenderEnum) *EmployeeRequestGender {
	return &EmployeeRequestGender{typeName: "genderEnum", GenderEnum: value}
}

func NewEmployeeRequestGenderFromString(value string) *EmployeeRequestGender {
	return &EmployeeRequestGender{typeName: "string", String: value}
}

func (e *EmployeeRequestGender) UnmarshalJSON(data []byte) error {
	var valueGenderEnum GenderEnum
	if err := json.Unmarshal(data, &valueGenderEnum); err == nil {
		e.typeName = "genderEnum"
		e.GenderEnum = valueGenderEnum
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		e.typeName = "string"
		e.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, e)
}

func (e EmployeeRequestGender) MarshalJSON() ([]byte, error) {
	switch e.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", e.typeName, e)
	case "genderEnum":
		return json.Marshal(e.GenderEnum)
	case "string":
		return json.Marshal(e.String)
	}
}

type EmployeeRequestGenderVisitor interface {
	VisitGenderEnum(GenderEnum) error
	VisitString(string) error
}

func (e *EmployeeRequestGender) Accept(visitor EmployeeRequestGenderVisitor) error {
	switch e.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", e.typeName, e)
	case "genderEnum":
		return visitor.VisitGenderEnum(e.GenderEnum)
	case "string":
		return visitor.VisitString(e.String)
	}
}

type EmployeeRequestGroupsItem struct {
	typeName string
	String   string
	Group    *Group
}

func NewEmployeeRequestGroupsItemFromString(value string) *EmployeeRequestGroupsItem {
	return &EmployeeRequestGroupsItem{typeName: "string", String: value}
}

func NewEmployeeRequestGroupsItemFromGroup(value *Group) *EmployeeRequestGroupsItem {
	return &EmployeeRequestGroupsItem{typeName: "group", Group: value}
}

func (e *EmployeeRequestGroupsItem) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		e.typeName = "string"
		e.String = valueString
		return nil
	}
	valueGroup := new(Group)
	if err := json.Unmarshal(data, &valueGroup); err == nil {
		e.typeName = "group"
		e.Group = valueGroup
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, e)
}

func (e EmployeeRequestGroupsItem) MarshalJSON() ([]byte, error) {
	switch e.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", e.typeName, e)
	case "string":
		return json.Marshal(e.String)
	case "group":
		return json.Marshal(e.Group)
	}
}

type EmployeeRequestGroupsItemVisitor interface {
	VisitString(string) error
	VisitGroup(*Group) error
}

func (e *EmployeeRequestGroupsItem) Accept(visitor EmployeeRequestGroupsItemVisitor) error {
	switch e.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", e.typeName, e)
	case "string":
		return visitor.VisitString(e.String)
	case "group":
		return visitor.VisitGroup(e.Group)
	}
}

// The employee's home address.
type EmployeeRequestHomeLocation struct {
	typeName string
	String   string
	Location *Location
}

func NewEmployeeRequestHomeLocationFromString(value string) *EmployeeRequestHomeLocation {
	return &EmployeeRequestHomeLocation{typeName: "string", String: value}
}

func NewEmployeeRequestHomeLocationFromLocation(value *Location) *EmployeeRequestHomeLocation {
	return &EmployeeRequestHomeLocation{typeName: "location", Location: value}
}

func (e *EmployeeRequestHomeLocation) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		e.typeName = "string"
		e.String = valueString
		return nil
	}
	valueLocation := new(Location)
	if err := json.Unmarshal(data, &valueLocation); err == nil {
		e.typeName = "location"
		e.Location = valueLocation
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, e)
}

func (e EmployeeRequestHomeLocation) MarshalJSON() ([]byte, error) {
	switch e.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", e.typeName, e)
	case "string":
		return json.Marshal(e.String)
	case "location":
		return json.Marshal(e.Location)
	}
}

type EmployeeRequestHomeLocationVisitor interface {
	VisitString(string) error
	VisitLocation(*Location) error
}

func (e *EmployeeRequestHomeLocation) Accept(visitor EmployeeRequestHomeLocationVisitor) error {
	switch e.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", e.typeName, e)
	case "string":
		return visitor.VisitString(e.String)
	case "location":
		return visitor.VisitLocation(e.Location)
	}
}

// The employee ID of the employee's manager.
type EmployeeRequestManager struct {
	typeName string
	String   string
	Employee *Employee
}

func NewEmployeeRequestManagerFromString(value string) *EmployeeRequestManager {
	return &EmployeeRequestManager{typeName: "string", String: value}
}

func NewEmployeeRequestManagerFromEmployee(value *Employee) *EmployeeRequestManager {
	return &EmployeeRequestManager{typeName: "employee", Employee: value}
}

func (e *EmployeeRequestManager) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		e.typeName = "string"
		e.String = valueString
		return nil
	}
	valueEmployee := new(Employee)
	if err := json.Unmarshal(data, &valueEmployee); err == nil {
		e.typeName = "employee"
		e.Employee = valueEmployee
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, e)
}

func (e EmployeeRequestManager) MarshalJSON() ([]byte, error) {
	switch e.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", e.typeName, e)
	case "string":
		return json.Marshal(e.String)
	case "employee":
		return json.Marshal(e.Employee)
	}
}

type EmployeeRequestManagerVisitor interface {
	VisitString(string) error
	VisitEmployee(*Employee) error
}

func (e *EmployeeRequestManager) Accept(visitor EmployeeRequestManagerVisitor) error {
	switch e.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", e.typeName, e)
	case "string":
		return visitor.VisitString(e.String)
	case "employee":
		return visitor.VisitEmployee(e.Employee)
	}
}

// The employee's filing status as related to marital status.
//
// - `SINGLE` - SINGLE
// - `MARRIED_FILING_JOINTLY` - MARRIED_FILING_JOINTLY
// - `MARRIED_FILING_SEPARATELY` - MARRIED_FILING_SEPARATELY
// - `HEAD_OF_HOUSEHOLD` - HEAD_OF_HOUSEHOLD
// - `QUALIFYING_WIDOW_OR_WIDOWER_WITH_DEPENDENT_CHILD` - QUALIFYING_WIDOW_OR_WIDOWER_WITH_DEPENDENT_CHILD
type EmployeeRequestMaritalStatus struct {
	typeName          string
	MaritalStatusEnum MaritalStatusEnum
	String            string
}

func NewEmployeeRequestMaritalStatusFromMaritalStatusEnum(value MaritalStatusEnum) *EmployeeRequestMaritalStatus {
	return &EmployeeRequestMaritalStatus{typeName: "maritalStatusEnum", MaritalStatusEnum: value}
}

func NewEmployeeRequestMaritalStatusFromString(value string) *EmployeeRequestMaritalStatus {
	return &EmployeeRequestMaritalStatus{typeName: "string", String: value}
}

func (e *EmployeeRequestMaritalStatus) UnmarshalJSON(data []byte) error {
	var valueMaritalStatusEnum MaritalStatusEnum
	if err := json.Unmarshal(data, &valueMaritalStatusEnum); err == nil {
		e.typeName = "maritalStatusEnum"
		e.MaritalStatusEnum = valueMaritalStatusEnum
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		e.typeName = "string"
		e.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, e)
}

func (e EmployeeRequestMaritalStatus) MarshalJSON() ([]byte, error) {
	switch e.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", e.typeName, e)
	case "maritalStatusEnum":
		return json.Marshal(e.MaritalStatusEnum)
	case "string":
		return json.Marshal(e.String)
	}
}

type EmployeeRequestMaritalStatusVisitor interface {
	VisitMaritalStatusEnum(MaritalStatusEnum) error
	VisitString(string) error
}

func (e *EmployeeRequestMaritalStatus) Accept(visitor EmployeeRequestMaritalStatusVisitor) error {
	switch e.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", e.typeName, e)
	case "maritalStatusEnum":
		return visitor.VisitMaritalStatusEnum(e.MaritalStatusEnum)
	case "string":
		return visitor.VisitString(e.String)
	}
}

// The employee's pay group
type EmployeeRequestPayGroup struct {
	typeName string
	String   string
	PayGroup *PayGroup
}

func NewEmployeeRequestPayGroupFromString(value string) *EmployeeRequestPayGroup {
	return &EmployeeRequestPayGroup{typeName: "string", String: value}
}

func NewEmployeeRequestPayGroupFromPayGroup(value *PayGroup) *EmployeeRequestPayGroup {
	return &EmployeeRequestPayGroup{typeName: "payGroup", PayGroup: value}
}

func (e *EmployeeRequestPayGroup) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		e.typeName = "string"
		e.String = valueString
		return nil
	}
	valuePayGroup := new(PayGroup)
	if err := json.Unmarshal(data, &valuePayGroup); err == nil {
		e.typeName = "payGroup"
		e.PayGroup = valuePayGroup
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, e)
}

func (e EmployeeRequestPayGroup) MarshalJSON() ([]byte, error) {
	switch e.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", e.typeName, e)
	case "string":
		return json.Marshal(e.String)
	case "payGroup":
		return json.Marshal(e.PayGroup)
	}
}

type EmployeeRequestPayGroupVisitor interface {
	VisitString(string) error
	VisitPayGroup(*PayGroup) error
}

func (e *EmployeeRequestPayGroup) Accept(visitor EmployeeRequestPayGroupVisitor) error {
	switch e.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", e.typeName, e)
	case "string":
		return visitor.VisitString(e.String)
	case "payGroup":
		return visitor.VisitPayGroup(e.PayGroup)
	}
}

// The employee's team.
type EmployeeRequestTeam struct {
	typeName string
	String   string
	Team     *Team
}

func NewEmployeeRequestTeamFromString(value string) *EmployeeRequestTeam {
	return &EmployeeRequestTeam{typeName: "string", String: value}
}

func NewEmployeeRequestTeamFromTeam(value *Team) *EmployeeRequestTeam {
	return &EmployeeRequestTeam{typeName: "team", Team: value}
}

func (e *EmployeeRequestTeam) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		e.typeName = "string"
		e.String = valueString
		return nil
	}
	valueTeam := new(Team)
	if err := json.Unmarshal(data, &valueTeam); err == nil {
		e.typeName = "team"
		e.Team = valueTeam
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, e)
}

func (e EmployeeRequestTeam) MarshalJSON() ([]byte, error) {
	switch e.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", e.typeName, e)
	case "string":
		return json.Marshal(e.String)
	case "team":
		return json.Marshal(e.Team)
	}
}

type EmployeeRequestTeamVisitor interface {
	VisitString(string) error
	VisitTeam(*Team) error
}

func (e *EmployeeRequestTeam) Accept(visitor EmployeeRequestTeamVisitor) error {
	switch e.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", e.typeName, e)
	case "string":
		return visitor.VisitString(e.String)
	case "team":
		return visitor.VisitTeam(e.Team)
	}
}

// The employee's work address.
type EmployeeRequestWorkLocation struct {
	typeName string
	String   string
	Location *Location
}

func NewEmployeeRequestWorkLocationFromString(value string) *EmployeeRequestWorkLocation {
	return &EmployeeRequestWorkLocation{typeName: "string", String: value}
}

func NewEmployeeRequestWorkLocationFromLocation(value *Location) *EmployeeRequestWorkLocation {
	return &EmployeeRequestWorkLocation{typeName: "location", Location: value}
}

func (e *EmployeeRequestWorkLocation) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		e.typeName = "string"
		e.String = valueString
		return nil
	}
	valueLocation := new(Location)
	if err := json.Unmarshal(data, &valueLocation); err == nil {
		e.typeName = "location"
		e.Location = valueLocation
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, e)
}

func (e EmployeeRequestWorkLocation) MarshalJSON() ([]byte, error) {
	switch e.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", e.typeName, e)
	case "string":
		return json.Marshal(e.String)
	case "location":
		return json.Marshal(e.Location)
	}
}

type EmployeeRequestWorkLocationVisitor interface {
	VisitString(string) error
	VisitLocation(*Location) error
}

func (e *EmployeeRequestWorkLocation) Accept(visitor EmployeeRequestWorkLocationVisitor) error {
	switch e.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", e.typeName, e)
	case "string":
		return visitor.VisitString(e.String)
	case "location":
		return visitor.VisitLocation(e.Location)
	}
}

type EmployeeResponse struct {
	Model    *Employee                   `json:"model,omitempty"`
	Warnings []*WarningValidationProblem `json:"warnings,omitempty"`
	Errors   []*ErrorValidationProblem   `json:"errors,omitempty"`
	Logs     []*DebugModeLog             `json:"logs,omitempty"`
}

// The employee's team.
type EmployeeTeam struct {
	typeName string
	String   string
	Team     *Team
}

func NewEmployeeTeamFromString(value string) *EmployeeTeam {
	return &EmployeeTeam{typeName: "string", String: value}
}

func NewEmployeeTeamFromTeam(value *Team) *EmployeeTeam {
	return &EmployeeTeam{typeName: "team", Team: value}
}

func (e *EmployeeTeam) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		e.typeName = "string"
		e.String = valueString
		return nil
	}
	valueTeam := new(Team)
	if err := json.Unmarshal(data, &valueTeam); err == nil {
		e.typeName = "team"
		e.Team = valueTeam
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, e)
}

func (e EmployeeTeam) MarshalJSON() ([]byte, error) {
	switch e.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", e.typeName, e)
	case "string":
		return json.Marshal(e.String)
	case "team":
		return json.Marshal(e.Team)
	}
}

type EmployeeTeamVisitor interface {
	VisitString(string) error
	VisitTeam(*Team) error
}

func (e *EmployeeTeam) Accept(visitor EmployeeTeamVisitor) error {
	switch e.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", e.typeName, e)
	case "string":
		return visitor.VisitString(e.String)
	case "team":
		return visitor.VisitTeam(e.Team)
	}
}

// The employee's work address.
type EmployeeWorkLocation struct {
	typeName string
	String   string
	Location *Location
}

func NewEmployeeWorkLocationFromString(value string) *EmployeeWorkLocation {
	return &EmployeeWorkLocation{typeName: "string", String: value}
}

func NewEmployeeWorkLocationFromLocation(value *Location) *EmployeeWorkLocation {
	return &EmployeeWorkLocation{typeName: "location", Location: value}
}

func (e *EmployeeWorkLocation) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		e.typeName = "string"
		e.String = valueString
		return nil
	}
	valueLocation := new(Location)
	if err := json.Unmarshal(data, &valueLocation); err == nil {
		e.typeName = "location"
		e.Location = valueLocation
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, e)
}

func (e EmployeeWorkLocation) MarshalJSON() ([]byte, error) {
	switch e.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", e.typeName, e)
	case "string":
		return json.Marshal(e.String)
	case "location":
		return json.Marshal(e.Location)
	}
}

type EmployeeWorkLocationVisitor interface {
	VisitString(string) error
	VisitLocation(*Location) error
}

func (e *EmployeeWorkLocation) Accept(visitor EmployeeWorkLocationVisitor) error {
	switch e.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", e.typeName, e)
	case "string":
		return visitor.VisitString(e.String)
	case "location":
		return visitor.VisitLocation(e.Location)
	}
}

// # The EmployerBenefit Object
//
// ### Description
//
// The `Employer Benefit` object is used to represent a benefit plan offered by a company.
//
// ### Usage Example
//
// Fetch from the `LIST EmployerBenefits` endpoint and filter by `ID` to show all EmployerBenefits.
type EmployerBenefit struct {
	Id *string `json:"id,omitempty"`
	// The third-party API ID of the matching object.
	RemoteId *string `json:"remote_id,omitempty"`
	// The type of benefit plan.
	//
	// - `MEDICAL` - MEDICAL
	// - `HEALTH_SAVINGS` - HEALTH_SAVINGS
	// - `INSURANCE` - INSURANCE
	// - `RETIREMENT` - RETIREMENT
	// - `OTHER` - OTHER
	BenefitPlanType *EmployerBenefitBenefitPlanType `json:"benefit_plan_type,omitempty"`
	// The employer benefit's name - typically the carrier or network name.
	Name *string `json:"name,omitempty"`
	// The employer benefit's description.
	Description *string `json:"description,omitempty"`
	// The employer benefit's deduction code.
	DeductionCode *string `json:"deduction_code,omitempty"`
	// Indicates whether or not this object has been deleted in the third party platform.
	RemoteWasDeleted *bool      `json:"remote_was_deleted,omitempty"`
	CreatedAt        *time.Time `json:"created_at,omitempty"`
	// This is the datetime that this object was last updated by Merge
	ModifiedAt    *time.Time       `json:"modified_at,omitempty"`
	FieldMappings map[string]any   `json:"field_mappings,omitempty"`
	RemoteData    []map[string]any `json:"remote_data,omitempty"`
}

// The type of benefit plan.
//
// - `MEDICAL` - MEDICAL
// - `HEALTH_SAVINGS` - HEALTH_SAVINGS
// - `INSURANCE` - INSURANCE
// - `RETIREMENT` - RETIREMENT
// - `OTHER` - OTHER
type EmployerBenefitBenefitPlanType struct {
	typeName            string
	BenefitPlanTypeEnum BenefitPlanTypeEnum
	String              string
}

func NewEmployerBenefitBenefitPlanTypeFromBenefitPlanTypeEnum(value BenefitPlanTypeEnum) *EmployerBenefitBenefitPlanType {
	return &EmployerBenefitBenefitPlanType{typeName: "benefitPlanTypeEnum", BenefitPlanTypeEnum: value}
}

func NewEmployerBenefitBenefitPlanTypeFromString(value string) *EmployerBenefitBenefitPlanType {
	return &EmployerBenefitBenefitPlanType{typeName: "string", String: value}
}

func (e *EmployerBenefitBenefitPlanType) UnmarshalJSON(data []byte) error {
	var valueBenefitPlanTypeEnum BenefitPlanTypeEnum
	if err := json.Unmarshal(data, &valueBenefitPlanTypeEnum); err == nil {
		e.typeName = "benefitPlanTypeEnum"
		e.BenefitPlanTypeEnum = valueBenefitPlanTypeEnum
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		e.typeName = "string"
		e.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, e)
}

func (e EmployerBenefitBenefitPlanType) MarshalJSON() ([]byte, error) {
	switch e.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", e.typeName, e)
	case "benefitPlanTypeEnum":
		return json.Marshal(e.BenefitPlanTypeEnum)
	case "string":
		return json.Marshal(e.String)
	}
}

type EmployerBenefitBenefitPlanTypeVisitor interface {
	VisitBenefitPlanTypeEnum(BenefitPlanTypeEnum) error
	VisitString(string) error
}

func (e *EmployerBenefitBenefitPlanType) Accept(visitor EmployerBenefitBenefitPlanTypeVisitor) error {
	switch e.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", e.typeName, e)
	case "benefitPlanTypeEnum":
		return visitor.VisitBenefitPlanTypeEnum(e.BenefitPlanTypeEnum)
	case "string":
		return visitor.VisitString(e.String)
	}
}

// # The Employment Object
//
// ### Description
//
// The `Employment` object is used to represent a job position at a company.
//
// Please note: When there is a change in pay or title, integrations with historical data will create new Employment objects while integrations without historical data will update existing ones.
//
// ### Usage Example
//
// Fetch from the `LIST Employments` endpoint and filter by `ID` to show all employees.
type Employment struct {
	Id *string `json:"id,omitempty"`
	// The third-party API ID of the matching object.
	RemoteId *string `json:"remote_id,omitempty"`
	// The employee holding this position.
	Employee *EmploymentEmployee `json:"employee,omitempty"`
	// The position's title.
	JobTitle *string `json:"job_title,omitempty"`
	// The position's pay rate in dollars.
	PayRate *float64 `json:"pay_rate,omitempty"`
	// The time period this pay rate encompasses.
	//
	// - `HOUR` - HOUR
	// - `DAY` - DAY
	// - `WEEK` - WEEK
	// - `EVERY_TWO_WEEKS` - EVERY_TWO_WEEKS
	// - `SEMIMONTHLY` - SEMIMONTHLY
	// - `MONTH` - MONTH
	// - `QUARTER` - QUARTER
	// - `EVERY_SIX_MONTHS` - EVERY_SIX_MONTHS
	// - `YEAR` - YEAR
	PayPeriod *EmploymentPayPeriod `json:"pay_period,omitempty"`
	// The position's pay frequency.
	//
	// - `WEEKLY` - WEEKLY
	// - `BIWEEKLY` - BIWEEKLY
	// - `MONTHLY` - MONTHLY
	// - `QUARTERLY` - QUARTERLY
	// - `SEMIANNUALLY` - SEMIANNUALLY
	// - `ANNUALLY` - ANNUALLY
	// - `THIRTEEN-MONTHLY` - THIRTEEN-MONTHLY
	// - `PRO_RATA` - PRO_RATA
	// - `SEMIMONTHLY` - SEMIMONTHLY
	PayFrequency *EmploymentPayFrequency `json:"pay_frequency,omitempty"`
	// The position's currency code.
	//
	// - `XUA` - ADB Unit of Account
	// - `AFN` - Afghan Afghani
	// - `AFA` - Afghan Afghani (1927–2002)
	// - `ALL` - Albanian Lek
	// - `ALK` - Albanian Lek (1946–1965)
	// - `DZD` - Algerian Dinar
	// - `ADP` - Andorran Peseta
	// - `AOA` - Angolan Kwanza
	// - `AOK` - Angolan Kwanza (1977–1991)
	// - `AON` - Angolan New Kwanza (1990–2000)
	// - `AOR` - Angolan Readjusted Kwanza (1995–1999)
	// - `ARA` - Argentine Austral
	// - `ARS` - Argentine Peso
	// - `ARM` - Argentine Peso (1881–1970)
	// - `ARP` - Argentine Peso (1983–1985)
	// - `ARL` - Argentine Peso Ley (1970–1983)
	// - `AMD` - Armenian Dram
	// - `AWG` - Aruban Florin
	// - `AUD` - Australian Dollar
	// - `ATS` - Austrian Schilling
	// - `AZN` - Azerbaijani Manat
	// - `AZM` - Azerbaijani Manat (1993–2006)
	// - `BSD` - Bahamian Dollar
	// - `BHD` - Bahraini Dinar
	// - `BDT` - Bangladeshi Taka
	// - `BBD` - Barbadian Dollar
	// - `BYN` - Belarusian Ruble
	// - `BYB` - Belarusian Ruble (1994–1999)
	// - `BYR` - Belarusian Ruble (2000–2016)
	// - `BEF` - Belgian Franc
	// - `BEC` - Belgian Franc (convertible)
	// - `BEL` - Belgian Franc (financial)
	// - `BZD` - Belize Dollar
	// - `BMD` - Bermudan Dollar
	// - `BTN` - Bhutanese Ngultrum
	// - `BOB` - Bolivian Boliviano
	// - `BOL` - Bolivian Boliviano (1863–1963)
	// - `BOV` - Bolivian Mvdol
	// - `BOP` - Bolivian Peso
	// - `BAM` - Bosnia-Herzegovina Convertible Mark
	// - `BAD` - Bosnia-Herzegovina Dinar (1992–1994)
	// - `BAN` - Bosnia-Herzegovina New Dinar (1994–1997)
	// - `BWP` - Botswanan Pula
	// - `BRC` - Brazilian Cruzado (1986–1989)
	// - `BRZ` - Brazilian Cruzeiro (1942–1967)
	// - `BRE` - Brazilian Cruzeiro (1990–1993)
	// - `BRR` - Brazilian Cruzeiro (1993–1994)
	// - `BRN` - Brazilian New Cruzado (1989–1990)
	// - `BRB` - Brazilian New Cruzeiro (1967–1986)
	// - `BRL` - Brazilian Real
	// - `GBP` - British Pound
	// - `BND` - Brunei Dollar
	// - `BGL` - Bulgarian Hard Lev
	// - `BGN` - Bulgarian Lev
	// - `BGO` - Bulgarian Lev (1879–1952)
	// - `BGM` - Bulgarian Socialist Lev
	// - `BUK` - Burmese Kyat
	// - `BIF` - Burundian Franc
	// - `XPF` - CFP Franc
	// - `KHR` - Cambodian Riel
	// - `CAD` - Canadian Dollar
	// - `CVE` - Cape Verdean Escudo
	// - `KYD` - Cayman Islands Dollar
	// - `XAF` - Central African CFA Franc
	// - `CLE` - Chilean Escudo
	// - `CLP` - Chilean Peso
	// - `CLF` - Chilean Unit of Account (UF)
	// - `CNX` - Chinese People’s Bank Dollar
	// - `CNY` - Chinese Yuan
	// - `CNH` - Chinese Yuan (offshore)
	// - `COP` - Colombian Peso
	// - `COU` - Colombian Real Value Unit
	// - `KMF` - Comorian Franc
	// - `CDF` - Congolese Franc
	// - `CRC` - Costa Rican Colón
	// - `HRD` - Croatian Dinar
	// - `HRK` - Croatian Kuna
	// - `CUC` - Cuban Convertible Peso
	// - `CUP` - Cuban Peso
	// - `CYP` - Cypriot Pound
	// - `CZK` - Czech Koruna
	// - `CSK` - Czechoslovak Hard Koruna
	// - `DKK` - Danish Krone
	// - `DJF` - Djiboutian Franc
	// - `DOP` - Dominican Peso
	// - `NLG` - Dutch Guilder
	// - `XCD` - East Caribbean Dollar
	// - `DDM` - East German Mark
	// - `ECS` - Ecuadorian Sucre
	// - `ECV` - Ecuadorian Unit of Constant Value
	// - `EGP` - Egyptian Pound
	// - `GQE` - Equatorial Guinean Ekwele
	// - `ERN` - Eritrean Nakfa
	// - `EEK` - Estonian Kroon
	// - `ETB` - Ethiopian Birr
	// - `EUR` - Euro
	// - `XBA` - European Composite Unit
	// - `XEU` - European Currency Unit
	// - `XBB` - European Monetary Unit
	// - `XBC` - European Unit of Account (XBC)
	// - `XBD` - European Unit of Account (XBD)
	// - `FKP` - Falkland Islands Pound
	// - `FJD` - Fijian Dollar
	// - `FIM` - Finnish Markka
	// - `FRF` - French Franc
	// - `XFO` - French Gold Franc
	// - `XFU` - French UIC-Franc
	// - `GMD` - Gambian Dalasi
	// - `GEK` - Georgian Kupon Larit
	// - `GEL` - Georgian Lari
	// - `DEM` - German Mark
	// - `GHS` - Ghanaian Cedi
	// - `GHC` - Ghanaian Cedi (1979–2007)
	// - `GIP` - Gibraltar Pound
	// - `XAU` - Gold
	// - `GRD` - Greek Drachma
	// - `GTQ` - Guatemalan Quetzal
	// - `GWP` - Guinea-Bissau Peso
	// - `GNF` - Guinean Franc
	// - `GNS` - Guinean Syli
	// - `GYD` - Guyanaese Dollar
	// - `HTG` - Haitian Gourde
	// - `HNL` - Honduran Lempira
	// - `HKD` - Hong Kong Dollar
	// - `HUF` - Hungarian Forint
	// - `IMP` - IMP
	// - `ISK` - Icelandic Króna
	// - `ISJ` - Icelandic Króna (1918–1981)
	// - `INR` - Indian Rupee
	// - `IDR` - Indonesian Rupiah
	// - `IRR` - Iranian Rial
	// - `IQD` - Iraqi Dinar
	// - `IEP` - Irish Pound
	// - `ILS` - Israeli New Shekel
	// - `ILP` - Israeli Pound
	// - `ILR` - Israeli Shekel (1980–1985)
	// - `ITL` - Italian Lira
	// - `JMD` - Jamaican Dollar
	// - `JPY` - Japanese Yen
	// - `JOD` - Jordanian Dinar
	// - `KZT` - Kazakhstani Tenge
	// - `KES` - Kenyan Shilling
	// - `KWD` - Kuwaiti Dinar
	// - `KGS` - Kyrgystani Som
	// - `LAK` - Laotian Kip
	// - `LVL` - Latvian Lats
	// - `LVR` - Latvian Ruble
	// - `LBP` - Lebanese Pound
	// - `LSL` - Lesotho Loti
	// - `LRD` - Liberian Dollar
	// - `LYD` - Libyan Dinar
	// - `LTL` - Lithuanian Litas
	// - `LTT` - Lithuanian Talonas
	// - `LUL` - Luxembourg Financial Franc
	// - `LUC` - Luxembourgian Convertible Franc
	// - `LUF` - Luxembourgian Franc
	// - `MOP` - Macanese Pataca
	// - `MKD` - Macedonian Denar
	// - `MKN` - Macedonian Denar (1992–1993)
	// - `MGA` - Malagasy Ariary
	// - `MGF` - Malagasy Franc
	// - `MWK` - Malawian Kwacha
	// - `MYR` - Malaysian Ringgit
	// - `MVR` - Maldivian Rufiyaa
	// - `MVP` - Maldivian Rupee (1947–1981)
	// - `MLF` - Malian Franc
	// - `MTL` - Maltese Lira
	// - `MTP` - Maltese Pound
	// - `MRU` - Mauritanian Ouguiya
	// - `MRO` - Mauritanian Ouguiya (1973–2017)
	// - `MUR` - Mauritian Rupee
	// - `MXV` - Mexican Investment Unit
	// - `MXN` - Mexican Peso
	// - `MXP` - Mexican Silver Peso (1861–1992)
	// - `MDC` - Moldovan Cupon
	// - `MDL` - Moldovan Leu
	// - `MCF` - Monegasque Franc
	// - `MNT` - Mongolian Tugrik
	// - `MAD` - Moroccan Dirham
	// - `MAF` - Moroccan Franc
	// - `MZE` - Mozambican Escudo
	// - `MZN` - Mozambican Metical
	// - `MZM` - Mozambican Metical (1980–2006)
	// - `MMK` - Myanmar Kyat
	// - `NAD` - Namibian Dollar
	// - `NPR` - Nepalese Rupee
	// - `ANG` - Netherlands Antillean Guilder
	// - `TWD` - New Taiwan Dollar
	// - `NZD` - New Zealand Dollar
	// - `NIO` - Nicaraguan Córdoba
	// - `NIC` - Nicaraguan Córdoba (1988–1991)
	// - `NGN` - Nigerian Naira
	// - `KPW` - North Korean Won
	// - `NOK` - Norwegian Krone
	// - `OMR` - Omani Rial
	// - `PKR` - Pakistani Rupee
	// - `XPD` - Palladium
	// - `PAB` - Panamanian Balboa
	// - `PGK` - Papua New Guinean Kina
	// - `PYG` - Paraguayan Guarani
	// - `PEI` - Peruvian Inti
	// - `PEN` - Peruvian Sol
	// - `PES` - Peruvian Sol (1863–1965)
	// - `PHP` - Philippine Peso
	// - `XPT` - Platinum
	// - `PLN` - Polish Zloty
	// - `PLZ` - Polish Zloty (1950–1995)
	// - `PTE` - Portuguese Escudo
	// - `GWE` - Portuguese Guinea Escudo
	// - `QAR` - Qatari Rial
	// - `XRE` - RINET Funds
	// - `RHD` - Rhodesian Dollar
	// - `RON` - Romanian Leu
	// - `ROL` - Romanian Leu (1952–2006)
	// - `RUB` - Russian Ruble
	// - `RUR` - Russian Ruble (1991–1998)
	// - `RWF` - Rwandan Franc
	// - `SVC` - Salvadoran Colón
	// - `WST` - Samoan Tala
	// - `SAR` - Saudi Riyal
	// - `RSD` - Serbian Dinar
	// - `CSD` - Serbian Dinar (2002–2006)
	// - `SCR` - Seychellois Rupee
	// - `SLL` - Sierra Leonean Leone
	// - `XAG` - Silver
	// - `SGD` - Singapore Dollar
	// - `SKK` - Slovak Koruna
	// - `SIT` - Slovenian Tolar
	// - `SBD` - Solomon Islands Dollar
	// - `SOS` - Somali Shilling
	// - `ZAR` - South African Rand
	// - `ZAL` - South African Rand (financial)
	// - `KRH` - South Korean Hwan (1953–1962)
	// - `KRW` - South Korean Won
	// - `KRO` - South Korean Won (1945–1953)
	// - `SSP` - South Sudanese Pound
	// - `SUR` - Soviet Rouble
	// - `ESP` - Spanish Peseta
	// - `ESA` - Spanish Peseta (A account)
	// - `ESB` - Spanish Peseta (convertible account)
	// - `XDR` - Special Drawing Rights
	// - `LKR` - Sri Lankan Rupee
	// - `SHP` - St. Helena Pound
	// - `XSU` - Sucre
	// - `SDD` - Sudanese Dinar (1992–2007)
	// - `SDG` - Sudanese Pound
	// - `SDP` - Sudanese Pound (1957–1998)
	// - `SRD` - Surinamese Dollar
	// - `SRG` - Surinamese Guilder
	// - `SZL` - Swazi Lilangeni
	// - `SEK` - Swedish Krona
	// - `CHF` - Swiss Franc
	// - `SYP` - Syrian Pound
	// - `STN` - São Tomé & Príncipe Dobra
	// - `STD` - São Tomé & Príncipe Dobra (1977–2017)
	// - `TVD` - TVD
	// - `TJR` - Tajikistani Ruble
	// - `TJS` - Tajikistani Somoni
	// - `TZS` - Tanzanian Shilling
	// - `XTS` - Testing Currency Code
	// - `THB` - Thai Baht
	// - `XXX` - The codes assigned for transactions where no currency is involved
	// - `TPE` - Timorese Escudo
	// - `TOP` - Tongan Paʻanga
	// - `TTD` - Trinidad & Tobago Dollar
	// - `TND` - Tunisian Dinar
	// - `TRY` - Turkish Lira
	// - `TRL` - Turkish Lira (1922–2005)
	// - `TMT` - Turkmenistani Manat
	// - `TMM` - Turkmenistani Manat (1993–2009)
	// - `USD` - US Dollar
	// - `USN` - US Dollar (Next day)
	// - `USS` - US Dollar (Same day)
	// - `UGX` - Ugandan Shilling
	// - `UGS` - Ugandan Shilling (1966–1987)
	// - `UAH` - Ukrainian Hryvnia
	// - `UAK` - Ukrainian Karbovanets
	// - `AED` - United Arab Emirates Dirham
	// - `UYW` - Uruguayan Nominal Wage Index Unit
	// - `UYU` - Uruguayan Peso
	// - `UYP` - Uruguayan Peso (1975–1993)
	// - `UYI` - Uruguayan Peso (Indexed Units)
	// - `UZS` - Uzbekistani Som
	// - `VUV` - Vanuatu Vatu
	// - `VES` - Venezuelan Bolívar
	// - `VEB` - Venezuelan Bolívar (1871–2008)
	// - `VEF` - Venezuelan Bolívar (2008–2018)
	// - `VND` - Vietnamese Dong
	// - `VNN` - Vietnamese Dong (1978–1985)
	// - `CHE` - WIR Euro
	// - `CHW` - WIR Franc
	// - `XOF` - West African CFA Franc
	// - `YDD` - Yemeni Dinar
	// - `YER` - Yemeni Rial
	// - `YUN` - Yugoslavian Convertible Dinar (1990–1992)
	// - `YUD` - Yugoslavian Hard Dinar (1966–1990)
	// - `YUM` - Yugoslavian New Dinar (1994–2002)
	// - `YUR` - Yugoslavian Reformed Dinar (1992–1993)
	// - `ZWN` - ZWN
	// - `ZRN` - Zairean New Zaire (1993–1998)
	// - `ZRZ` - Zairean Zaire (1971–1993)
	// - `ZMW` - Zambian Kwacha
	// - `ZMK` - Zambian Kwacha (1968–2012)
	// - `ZWD` - Zimbabwean Dollar (1980–2008)
	// - `ZWR` - Zimbabwean Dollar (2008)
	// - `ZWL` - Zimbabwean Dollar (2009)
	PayCurrency *EmploymentPayCurrency `json:"pay_currency,omitempty"`
	// The employment's pay group
	PayGroup *EmploymentPayGroup `json:"pay_group,omitempty"`
	// The position's FLSA status.
	//
	// - `EXEMPT` - EXEMPT
	// - `SALARIED_NONEXEMPT` - SALARIED_NONEXEMPT
	// - `NONEXEMPT` - NONEXEMPT
	// - `OWNER` - OWNER
	FlsaStatus *EmploymentFlsaStatus `json:"flsa_status,omitempty"`
	// The position's effective date.
	EffectiveDate *time.Time `json:"effective_date,omitempty"`
	// The position's type of employment.
	//
	// - `FULL_TIME` - FULL_TIME
	// - `PART_TIME` - PART_TIME
	// - `INTERN` - INTERN
	// - `CONTRACTOR` - CONTRACTOR
	// - `FREELANCE` - FREELANCE
	EmploymentType *EmploymentEmploymentType `json:"employment_type,omitempty"`
	// Indicates whether or not this object has been deleted in the third party platform.
	RemoteWasDeleted *bool      `json:"remote_was_deleted,omitempty"`
	CreatedAt        *time.Time `json:"created_at,omitempty"`
	// This is the datetime that this object was last updated by Merge
	ModifiedAt    *time.Time     `json:"modified_at,omitempty"`
	FieldMappings map[string]any `json:"field_mappings,omitempty"`
	RemoteData    []*RemoteData  `json:"remote_data,omitempty"`
}

// The employee holding this position.
type EmploymentEmployee struct {
	typeName string
	String   string
	Employee *Employee
}

func NewEmploymentEmployeeFromString(value string) *EmploymentEmployee {
	return &EmploymentEmployee{typeName: "string", String: value}
}

func NewEmploymentEmployeeFromEmployee(value *Employee) *EmploymentEmployee {
	return &EmploymentEmployee{typeName: "employee", Employee: value}
}

func (e *EmploymentEmployee) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		e.typeName = "string"
		e.String = valueString
		return nil
	}
	valueEmployee := new(Employee)
	if err := json.Unmarshal(data, &valueEmployee); err == nil {
		e.typeName = "employee"
		e.Employee = valueEmployee
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, e)
}

func (e EmploymentEmployee) MarshalJSON() ([]byte, error) {
	switch e.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", e.typeName, e)
	case "string":
		return json.Marshal(e.String)
	case "employee":
		return json.Marshal(e.Employee)
	}
}

type EmploymentEmployeeVisitor interface {
	VisitString(string) error
	VisitEmployee(*Employee) error
}

func (e *EmploymentEmployee) Accept(visitor EmploymentEmployeeVisitor) error {
	switch e.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", e.typeName, e)
	case "string":
		return visitor.VisitString(e.String)
	case "employee":
		return visitor.VisitEmployee(e.Employee)
	}
}

// The position's type of employment.
//
// - `FULL_TIME` - FULL_TIME
// - `PART_TIME` - PART_TIME
// - `INTERN` - INTERN
// - `CONTRACTOR` - CONTRACTOR
// - `FREELANCE` - FREELANCE
type EmploymentEmploymentType struct {
	typeName           string
	EmploymentTypeEnum EmploymentTypeEnum
	String             string
}

func NewEmploymentEmploymentTypeFromEmploymentTypeEnum(value EmploymentTypeEnum) *EmploymentEmploymentType {
	return &EmploymentEmploymentType{typeName: "employmentTypeEnum", EmploymentTypeEnum: value}
}

func NewEmploymentEmploymentTypeFromString(value string) *EmploymentEmploymentType {
	return &EmploymentEmploymentType{typeName: "string", String: value}
}

func (e *EmploymentEmploymentType) UnmarshalJSON(data []byte) error {
	var valueEmploymentTypeEnum EmploymentTypeEnum
	if err := json.Unmarshal(data, &valueEmploymentTypeEnum); err == nil {
		e.typeName = "employmentTypeEnum"
		e.EmploymentTypeEnum = valueEmploymentTypeEnum
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		e.typeName = "string"
		e.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, e)
}

func (e EmploymentEmploymentType) MarshalJSON() ([]byte, error) {
	switch e.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", e.typeName, e)
	case "employmentTypeEnum":
		return json.Marshal(e.EmploymentTypeEnum)
	case "string":
		return json.Marshal(e.String)
	}
}

type EmploymentEmploymentTypeVisitor interface {
	VisitEmploymentTypeEnum(EmploymentTypeEnum) error
	VisitString(string) error
}

func (e *EmploymentEmploymentType) Accept(visitor EmploymentEmploymentTypeVisitor) error {
	switch e.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", e.typeName, e)
	case "employmentTypeEnum":
		return visitor.VisitEmploymentTypeEnum(e.EmploymentTypeEnum)
	case "string":
		return visitor.VisitString(e.String)
	}
}

// The position's FLSA status.
//
// - `EXEMPT` - EXEMPT
// - `SALARIED_NONEXEMPT` - SALARIED_NONEXEMPT
// - `NONEXEMPT` - NONEXEMPT
// - `OWNER` - OWNER
type EmploymentFlsaStatus struct {
	typeName       string
	FlsaStatusEnum FlsaStatusEnum
	String         string
}

func NewEmploymentFlsaStatusFromFlsaStatusEnum(value FlsaStatusEnum) *EmploymentFlsaStatus {
	return &EmploymentFlsaStatus{typeName: "flsaStatusEnum", FlsaStatusEnum: value}
}

func NewEmploymentFlsaStatusFromString(value string) *EmploymentFlsaStatus {
	return &EmploymentFlsaStatus{typeName: "string", String: value}
}

func (e *EmploymentFlsaStatus) UnmarshalJSON(data []byte) error {
	var valueFlsaStatusEnum FlsaStatusEnum
	if err := json.Unmarshal(data, &valueFlsaStatusEnum); err == nil {
		e.typeName = "flsaStatusEnum"
		e.FlsaStatusEnum = valueFlsaStatusEnum
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		e.typeName = "string"
		e.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, e)
}

func (e EmploymentFlsaStatus) MarshalJSON() ([]byte, error) {
	switch e.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", e.typeName, e)
	case "flsaStatusEnum":
		return json.Marshal(e.FlsaStatusEnum)
	case "string":
		return json.Marshal(e.String)
	}
}

type EmploymentFlsaStatusVisitor interface {
	VisitFlsaStatusEnum(FlsaStatusEnum) error
	VisitString(string) error
}

func (e *EmploymentFlsaStatus) Accept(visitor EmploymentFlsaStatusVisitor) error {
	switch e.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", e.typeName, e)
	case "flsaStatusEnum":
		return visitor.VisitFlsaStatusEnum(e.FlsaStatusEnum)
	case "string":
		return visitor.VisitString(e.String)
	}
}

// The position's currency code.
//
// - `XUA` - ADB Unit of Account
// - `AFN` - Afghan Afghani
// - `AFA` - Afghan Afghani (1927–2002)
// - `ALL` - Albanian Lek
// - `ALK` - Albanian Lek (1946–1965)
// - `DZD` - Algerian Dinar
// - `ADP` - Andorran Peseta
// - `AOA` - Angolan Kwanza
// - `AOK` - Angolan Kwanza (1977–1991)
// - `AON` - Angolan New Kwanza (1990–2000)
// - `AOR` - Angolan Readjusted Kwanza (1995–1999)
// - `ARA` - Argentine Austral
// - `ARS` - Argentine Peso
// - `ARM` - Argentine Peso (1881–1970)
// - `ARP` - Argentine Peso (1983–1985)
// - `ARL` - Argentine Peso Ley (1970–1983)
// - `AMD` - Armenian Dram
// - `AWG` - Aruban Florin
// - `AUD` - Australian Dollar
// - `ATS` - Austrian Schilling
// - `AZN` - Azerbaijani Manat
// - `AZM` - Azerbaijani Manat (1993–2006)
// - `BSD` - Bahamian Dollar
// - `BHD` - Bahraini Dinar
// - `BDT` - Bangladeshi Taka
// - `BBD` - Barbadian Dollar
// - `BYN` - Belarusian Ruble
// - `BYB` - Belarusian Ruble (1994–1999)
// - `BYR` - Belarusian Ruble (2000–2016)
// - `BEF` - Belgian Franc
// - `BEC` - Belgian Franc (convertible)
// - `BEL` - Belgian Franc (financial)
// - `BZD` - Belize Dollar
// - `BMD` - Bermudan Dollar
// - `BTN` - Bhutanese Ngultrum
// - `BOB` - Bolivian Boliviano
// - `BOL` - Bolivian Boliviano (1863–1963)
// - `BOV` - Bolivian Mvdol
// - `BOP` - Bolivian Peso
// - `BAM` - Bosnia-Herzegovina Convertible Mark
// - `BAD` - Bosnia-Herzegovina Dinar (1992–1994)
// - `BAN` - Bosnia-Herzegovina New Dinar (1994–1997)
// - `BWP` - Botswanan Pula
// - `BRC` - Brazilian Cruzado (1986–1989)
// - `BRZ` - Brazilian Cruzeiro (1942–1967)
// - `BRE` - Brazilian Cruzeiro (1990–1993)
// - `BRR` - Brazilian Cruzeiro (1993–1994)
// - `BRN` - Brazilian New Cruzado (1989–1990)
// - `BRB` - Brazilian New Cruzeiro (1967–1986)
// - `BRL` - Brazilian Real
// - `GBP` - British Pound
// - `BND` - Brunei Dollar
// - `BGL` - Bulgarian Hard Lev
// - `BGN` - Bulgarian Lev
// - `BGO` - Bulgarian Lev (1879–1952)
// - `BGM` - Bulgarian Socialist Lev
// - `BUK` - Burmese Kyat
// - `BIF` - Burundian Franc
// - `XPF` - CFP Franc
// - `KHR` - Cambodian Riel
// - `CAD` - Canadian Dollar
// - `CVE` - Cape Verdean Escudo
// - `KYD` - Cayman Islands Dollar
// - `XAF` - Central African CFA Franc
// - `CLE` - Chilean Escudo
// - `CLP` - Chilean Peso
// - `CLF` - Chilean Unit of Account (UF)
// - `CNX` - Chinese People’s Bank Dollar
// - `CNY` - Chinese Yuan
// - `CNH` - Chinese Yuan (offshore)
// - `COP` - Colombian Peso
// - `COU` - Colombian Real Value Unit
// - `KMF` - Comorian Franc
// - `CDF` - Congolese Franc
// - `CRC` - Costa Rican Colón
// - `HRD` - Croatian Dinar
// - `HRK` - Croatian Kuna
// - `CUC` - Cuban Convertible Peso
// - `CUP` - Cuban Peso
// - `CYP` - Cypriot Pound
// - `CZK` - Czech Koruna
// - `CSK` - Czechoslovak Hard Koruna
// - `DKK` - Danish Krone
// - `DJF` - Djiboutian Franc
// - `DOP` - Dominican Peso
// - `NLG` - Dutch Guilder
// - `XCD` - East Caribbean Dollar
// - `DDM` - East German Mark
// - `ECS` - Ecuadorian Sucre
// - `ECV` - Ecuadorian Unit of Constant Value
// - `EGP` - Egyptian Pound
// - `GQE` - Equatorial Guinean Ekwele
// - `ERN` - Eritrean Nakfa
// - `EEK` - Estonian Kroon
// - `ETB` - Ethiopian Birr
// - `EUR` - Euro
// - `XBA` - European Composite Unit
// - `XEU` - European Currency Unit
// - `XBB` - European Monetary Unit
// - `XBC` - European Unit of Account (XBC)
// - `XBD` - European Unit of Account (XBD)
// - `FKP` - Falkland Islands Pound
// - `FJD` - Fijian Dollar
// - `FIM` - Finnish Markka
// - `FRF` - French Franc
// - `XFO` - French Gold Franc
// - `XFU` - French UIC-Franc
// - `GMD` - Gambian Dalasi
// - `GEK` - Georgian Kupon Larit
// - `GEL` - Georgian Lari
// - `DEM` - German Mark
// - `GHS` - Ghanaian Cedi
// - `GHC` - Ghanaian Cedi (1979–2007)
// - `GIP` - Gibraltar Pound
// - `XAU` - Gold
// - `GRD` - Greek Drachma
// - `GTQ` - Guatemalan Quetzal
// - `GWP` - Guinea-Bissau Peso
// - `GNF` - Guinean Franc
// - `GNS` - Guinean Syli
// - `GYD` - Guyanaese Dollar
// - `HTG` - Haitian Gourde
// - `HNL` - Honduran Lempira
// - `HKD` - Hong Kong Dollar
// - `HUF` - Hungarian Forint
// - `IMP` - IMP
// - `ISK` - Icelandic Króna
// - `ISJ` - Icelandic Króna (1918–1981)
// - `INR` - Indian Rupee
// - `IDR` - Indonesian Rupiah
// - `IRR` - Iranian Rial
// - `IQD` - Iraqi Dinar
// - `IEP` - Irish Pound
// - `ILS` - Israeli New Shekel
// - `ILP` - Israeli Pound
// - `ILR` - Israeli Shekel (1980–1985)
// - `ITL` - Italian Lira
// - `JMD` - Jamaican Dollar
// - `JPY` - Japanese Yen
// - `JOD` - Jordanian Dinar
// - `KZT` - Kazakhstani Tenge
// - `KES` - Kenyan Shilling
// - `KWD` - Kuwaiti Dinar
// - `KGS` - Kyrgystani Som
// - `LAK` - Laotian Kip
// - `LVL` - Latvian Lats
// - `LVR` - Latvian Ruble
// - `LBP` - Lebanese Pound
// - `LSL` - Lesotho Loti
// - `LRD` - Liberian Dollar
// - `LYD` - Libyan Dinar
// - `LTL` - Lithuanian Litas
// - `LTT` - Lithuanian Talonas
// - `LUL` - Luxembourg Financial Franc
// - `LUC` - Luxembourgian Convertible Franc
// - `LUF` - Luxembourgian Franc
// - `MOP` - Macanese Pataca
// - `MKD` - Macedonian Denar
// - `MKN` - Macedonian Denar (1992–1993)
// - `MGA` - Malagasy Ariary
// - `MGF` - Malagasy Franc
// - `MWK` - Malawian Kwacha
// - `MYR` - Malaysian Ringgit
// - `MVR` - Maldivian Rufiyaa
// - `MVP` - Maldivian Rupee (1947–1981)
// - `MLF` - Malian Franc
// - `MTL` - Maltese Lira
// - `MTP` - Maltese Pound
// - `MRU` - Mauritanian Ouguiya
// - `MRO` - Mauritanian Ouguiya (1973–2017)
// - `MUR` - Mauritian Rupee
// - `MXV` - Mexican Investment Unit
// - `MXN` - Mexican Peso
// - `MXP` - Mexican Silver Peso (1861–1992)
// - `MDC` - Moldovan Cupon
// - `MDL` - Moldovan Leu
// - `MCF` - Monegasque Franc
// - `MNT` - Mongolian Tugrik
// - `MAD` - Moroccan Dirham
// - `MAF` - Moroccan Franc
// - `MZE` - Mozambican Escudo
// - `MZN` - Mozambican Metical
// - `MZM` - Mozambican Metical (1980–2006)
// - `MMK` - Myanmar Kyat
// - `NAD` - Namibian Dollar
// - `NPR` - Nepalese Rupee
// - `ANG` - Netherlands Antillean Guilder
// - `TWD` - New Taiwan Dollar
// - `NZD` - New Zealand Dollar
// - `NIO` - Nicaraguan Córdoba
// - `NIC` - Nicaraguan Córdoba (1988–1991)
// - `NGN` - Nigerian Naira
// - `KPW` - North Korean Won
// - `NOK` - Norwegian Krone
// - `OMR` - Omani Rial
// - `PKR` - Pakistani Rupee
// - `XPD` - Palladium
// - `PAB` - Panamanian Balboa
// - `PGK` - Papua New Guinean Kina
// - `PYG` - Paraguayan Guarani
// - `PEI` - Peruvian Inti
// - `PEN` - Peruvian Sol
// - `PES` - Peruvian Sol (1863–1965)
// - `PHP` - Philippine Peso
// - `XPT` - Platinum
// - `PLN` - Polish Zloty
// - `PLZ` - Polish Zloty (1950–1995)
// - `PTE` - Portuguese Escudo
// - `GWE` - Portuguese Guinea Escudo
// - `QAR` - Qatari Rial
// - `XRE` - RINET Funds
// - `RHD` - Rhodesian Dollar
// - `RON` - Romanian Leu
// - `ROL` - Romanian Leu (1952–2006)
// - `RUB` - Russian Ruble
// - `RUR` - Russian Ruble (1991–1998)
// - `RWF` - Rwandan Franc
// - `SVC` - Salvadoran Colón
// - `WST` - Samoan Tala
// - `SAR` - Saudi Riyal
// - `RSD` - Serbian Dinar
// - `CSD` - Serbian Dinar (2002–2006)
// - `SCR` - Seychellois Rupee
// - `SLL` - Sierra Leonean Leone
// - `XAG` - Silver
// - `SGD` - Singapore Dollar
// - `SKK` - Slovak Koruna
// - `SIT` - Slovenian Tolar
// - `SBD` - Solomon Islands Dollar
// - `SOS` - Somali Shilling
// - `ZAR` - South African Rand
// - `ZAL` - South African Rand (financial)
// - `KRH` - South Korean Hwan (1953–1962)
// - `KRW` - South Korean Won
// - `KRO` - South Korean Won (1945–1953)
// - `SSP` - South Sudanese Pound
// - `SUR` - Soviet Rouble
// - `ESP` - Spanish Peseta
// - `ESA` - Spanish Peseta (A account)
// - `ESB` - Spanish Peseta (convertible account)
// - `XDR` - Special Drawing Rights
// - `LKR` - Sri Lankan Rupee
// - `SHP` - St. Helena Pound
// - `XSU` - Sucre
// - `SDD` - Sudanese Dinar (1992–2007)
// - `SDG` - Sudanese Pound
// - `SDP` - Sudanese Pound (1957–1998)
// - `SRD` - Surinamese Dollar
// - `SRG` - Surinamese Guilder
// - `SZL` - Swazi Lilangeni
// - `SEK` - Swedish Krona
// - `CHF` - Swiss Franc
// - `SYP` - Syrian Pound
// - `STN` - São Tomé & Príncipe Dobra
// - `STD` - São Tomé & Príncipe Dobra (1977–2017)
// - `TVD` - TVD
// - `TJR` - Tajikistani Ruble
// - `TJS` - Tajikistani Somoni
// - `TZS` - Tanzanian Shilling
// - `XTS` - Testing Currency Code
// - `THB` - Thai Baht
// - `XXX` - The codes assigned for transactions where no currency is involved
// - `TPE` - Timorese Escudo
// - `TOP` - Tongan Paʻanga
// - `TTD` - Trinidad & Tobago Dollar
// - `TND` - Tunisian Dinar
// - `TRY` - Turkish Lira
// - `TRL` - Turkish Lira (1922–2005)
// - `TMT` - Turkmenistani Manat
// - `TMM` - Turkmenistani Manat (1993–2009)
// - `USD` - US Dollar
// - `USN` - US Dollar (Next day)
// - `USS` - US Dollar (Same day)
// - `UGX` - Ugandan Shilling
// - `UGS` - Ugandan Shilling (1966–1987)
// - `UAH` - Ukrainian Hryvnia
// - `UAK` - Ukrainian Karbovanets
// - `AED` - United Arab Emirates Dirham
// - `UYW` - Uruguayan Nominal Wage Index Unit
// - `UYU` - Uruguayan Peso
// - `UYP` - Uruguayan Peso (1975–1993)
// - `UYI` - Uruguayan Peso (Indexed Units)
// - `UZS` - Uzbekistani Som
// - `VUV` - Vanuatu Vatu
// - `VES` - Venezuelan Bolívar
// - `VEB` - Venezuelan Bolívar (1871–2008)
// - `VEF` - Venezuelan Bolívar (2008–2018)
// - `VND` - Vietnamese Dong
// - `VNN` - Vietnamese Dong (1978–1985)
// - `CHE` - WIR Euro
// - `CHW` - WIR Franc
// - `XOF` - West African CFA Franc
// - `YDD` - Yemeni Dinar
// - `YER` - Yemeni Rial
// - `YUN` - Yugoslavian Convertible Dinar (1990–1992)
// - `YUD` - Yugoslavian Hard Dinar (1966–1990)
// - `YUM` - Yugoslavian New Dinar (1994–2002)
// - `YUR` - Yugoslavian Reformed Dinar (1992–1993)
// - `ZWN` - ZWN
// - `ZRN` - Zairean New Zaire (1993–1998)
// - `ZRZ` - Zairean Zaire (1971–1993)
// - `ZMW` - Zambian Kwacha
// - `ZMK` - Zambian Kwacha (1968–2012)
// - `ZWD` - Zimbabwean Dollar (1980–2008)
// - `ZWR` - Zimbabwean Dollar (2008)
// - `ZWL` - Zimbabwean Dollar (2009)
type EmploymentPayCurrency struct {
	typeName        string
	PayCurrencyEnum PayCurrencyEnum
	String          string
}

func NewEmploymentPayCurrencyFromPayCurrencyEnum(value PayCurrencyEnum) *EmploymentPayCurrency {
	return &EmploymentPayCurrency{typeName: "payCurrencyEnum", PayCurrencyEnum: value}
}

func NewEmploymentPayCurrencyFromString(value string) *EmploymentPayCurrency {
	return &EmploymentPayCurrency{typeName: "string", String: value}
}

func (e *EmploymentPayCurrency) UnmarshalJSON(data []byte) error {
	var valuePayCurrencyEnum PayCurrencyEnum
	if err := json.Unmarshal(data, &valuePayCurrencyEnum); err == nil {
		e.typeName = "payCurrencyEnum"
		e.PayCurrencyEnum = valuePayCurrencyEnum
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		e.typeName = "string"
		e.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, e)
}

func (e EmploymentPayCurrency) MarshalJSON() ([]byte, error) {
	switch e.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", e.typeName, e)
	case "payCurrencyEnum":
		return json.Marshal(e.PayCurrencyEnum)
	case "string":
		return json.Marshal(e.String)
	}
}

type EmploymentPayCurrencyVisitor interface {
	VisitPayCurrencyEnum(PayCurrencyEnum) error
	VisitString(string) error
}

func (e *EmploymentPayCurrency) Accept(visitor EmploymentPayCurrencyVisitor) error {
	switch e.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", e.typeName, e)
	case "payCurrencyEnum":
		return visitor.VisitPayCurrencyEnum(e.PayCurrencyEnum)
	case "string":
		return visitor.VisitString(e.String)
	}
}

// The position's pay frequency.
//
// - `WEEKLY` - WEEKLY
// - `BIWEEKLY` - BIWEEKLY
// - `MONTHLY` - MONTHLY
// - `QUARTERLY` - QUARTERLY
// - `SEMIANNUALLY` - SEMIANNUALLY
// - `ANNUALLY` - ANNUALLY
// - `THIRTEEN-MONTHLY` - THIRTEEN-MONTHLY
// - `PRO_RATA` - PRO_RATA
// - `SEMIMONTHLY` - SEMIMONTHLY
type EmploymentPayFrequency struct {
	typeName         string
	PayFrequencyEnum PayFrequencyEnum
	String           string
}

func NewEmploymentPayFrequencyFromPayFrequencyEnum(value PayFrequencyEnum) *EmploymentPayFrequency {
	return &EmploymentPayFrequency{typeName: "payFrequencyEnum", PayFrequencyEnum: value}
}

func NewEmploymentPayFrequencyFromString(value string) *EmploymentPayFrequency {
	return &EmploymentPayFrequency{typeName: "string", String: value}
}

func (e *EmploymentPayFrequency) UnmarshalJSON(data []byte) error {
	var valuePayFrequencyEnum PayFrequencyEnum
	if err := json.Unmarshal(data, &valuePayFrequencyEnum); err == nil {
		e.typeName = "payFrequencyEnum"
		e.PayFrequencyEnum = valuePayFrequencyEnum
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		e.typeName = "string"
		e.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, e)
}

func (e EmploymentPayFrequency) MarshalJSON() ([]byte, error) {
	switch e.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", e.typeName, e)
	case "payFrequencyEnum":
		return json.Marshal(e.PayFrequencyEnum)
	case "string":
		return json.Marshal(e.String)
	}
}

type EmploymentPayFrequencyVisitor interface {
	VisitPayFrequencyEnum(PayFrequencyEnum) error
	VisitString(string) error
}

func (e *EmploymentPayFrequency) Accept(visitor EmploymentPayFrequencyVisitor) error {
	switch e.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", e.typeName, e)
	case "payFrequencyEnum":
		return visitor.VisitPayFrequencyEnum(e.PayFrequencyEnum)
	case "string":
		return visitor.VisitString(e.String)
	}
}

// The employment's pay group
type EmploymentPayGroup struct {
	typeName string
	String   string
	PayGroup *PayGroup
}

func NewEmploymentPayGroupFromString(value string) *EmploymentPayGroup {
	return &EmploymentPayGroup{typeName: "string", String: value}
}

func NewEmploymentPayGroupFromPayGroup(value *PayGroup) *EmploymentPayGroup {
	return &EmploymentPayGroup{typeName: "payGroup", PayGroup: value}
}

func (e *EmploymentPayGroup) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		e.typeName = "string"
		e.String = valueString
		return nil
	}
	valuePayGroup := new(PayGroup)
	if err := json.Unmarshal(data, &valuePayGroup); err == nil {
		e.typeName = "payGroup"
		e.PayGroup = valuePayGroup
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, e)
}

func (e EmploymentPayGroup) MarshalJSON() ([]byte, error) {
	switch e.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", e.typeName, e)
	case "string":
		return json.Marshal(e.String)
	case "payGroup":
		return json.Marshal(e.PayGroup)
	}
}

type EmploymentPayGroupVisitor interface {
	VisitString(string) error
	VisitPayGroup(*PayGroup) error
}

func (e *EmploymentPayGroup) Accept(visitor EmploymentPayGroupVisitor) error {
	switch e.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", e.typeName, e)
	case "string":
		return visitor.VisitString(e.String)
	case "payGroup":
		return visitor.VisitPayGroup(e.PayGroup)
	}
}

// The time period this pay rate encompasses.
//
// - `HOUR` - HOUR
// - `DAY` - DAY
// - `WEEK` - WEEK
// - `EVERY_TWO_WEEKS` - EVERY_TWO_WEEKS
// - `SEMIMONTHLY` - SEMIMONTHLY
// - `MONTH` - MONTH
// - `QUARTER` - QUARTER
// - `EVERY_SIX_MONTHS` - EVERY_SIX_MONTHS
// - `YEAR` - YEAR
type EmploymentPayPeriod struct {
	typeName      string
	PayPeriodEnum PayPeriodEnum
	String        string
}

func NewEmploymentPayPeriodFromPayPeriodEnum(value PayPeriodEnum) *EmploymentPayPeriod {
	return &EmploymentPayPeriod{typeName: "payPeriodEnum", PayPeriodEnum: value}
}

func NewEmploymentPayPeriodFromString(value string) *EmploymentPayPeriod {
	return &EmploymentPayPeriod{typeName: "string", String: value}
}

func (e *EmploymentPayPeriod) UnmarshalJSON(data []byte) error {
	var valuePayPeriodEnum PayPeriodEnum
	if err := json.Unmarshal(data, &valuePayPeriodEnum); err == nil {
		e.typeName = "payPeriodEnum"
		e.PayPeriodEnum = valuePayPeriodEnum
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		e.typeName = "string"
		e.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, e)
}

func (e EmploymentPayPeriod) MarshalJSON() ([]byte, error) {
	switch e.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", e.typeName, e)
	case "payPeriodEnum":
		return json.Marshal(e.PayPeriodEnum)
	case "string":
		return json.Marshal(e.String)
	}
}

type EmploymentPayPeriodVisitor interface {
	VisitPayPeriodEnum(PayPeriodEnum) error
	VisitString(string) error
}

func (e *EmploymentPayPeriod) Accept(visitor EmploymentPayPeriodVisitor) error {
	switch e.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", e.typeName, e)
	case "payPeriodEnum":
		return visitor.VisitPayPeriodEnum(e.PayPeriodEnum)
	case "string":
		return visitor.VisitString(e.String)
	}
}

// - `ACTIVE` - ACTIVE
// - `PENDING` - PENDING
// - `INACTIVE` - INACTIVE
type EmploymentStatusEnum uint

const (
	EmploymentStatusEnumActive EmploymentStatusEnum = iota + 1
	EmploymentStatusEnumPending
	EmploymentStatusEnumInactive
)

func (e EmploymentStatusEnum) String() string {
	switch e {
	default:
		return strconv.Itoa(int(e))
	case EmploymentStatusEnumActive:
		return "ACTIVE"
	case EmploymentStatusEnumPending:
		return "PENDING"
	case EmploymentStatusEnumInactive:
		return "INACTIVE"
	}
}

func (e EmploymentStatusEnum) MarshalJSON() ([]byte, error) {
	return []byte(fmt.Sprintf("%q", e.String())), nil
}

func (e *EmploymentStatusEnum) UnmarshalJSON(data []byte) error {
	var raw string
	if err := json.Unmarshal(data, &raw); err != nil {
		return err
	}
	switch raw {
	case "ACTIVE":
		value := EmploymentStatusEnumActive
		*e = value
	case "PENDING":
		value := EmploymentStatusEnumPending
		*e = value
	case "INACTIVE":
		value := EmploymentStatusEnumInactive
		*e = value
	}
	return nil
}

// - `FULL_TIME` - FULL_TIME
// - `PART_TIME` - PART_TIME
// - `INTERN` - INTERN
// - `CONTRACTOR` - CONTRACTOR
// - `FREELANCE` - FREELANCE
type EmploymentTypeEnum uint

const (
	EmploymentTypeEnumFullTime EmploymentTypeEnum = iota + 1
	EmploymentTypeEnumPartTime
	EmploymentTypeEnumIntern
	EmploymentTypeEnumContractor
	EmploymentTypeEnumFreelance
)

func (e EmploymentTypeEnum) String() string {
	switch e {
	default:
		return strconv.Itoa(int(e))
	case EmploymentTypeEnumFullTime:
		return "FULL_TIME"
	case EmploymentTypeEnumPartTime:
		return "PART_TIME"
	case EmploymentTypeEnumIntern:
		return "INTERN"
	case EmploymentTypeEnumContractor:
		return "CONTRACTOR"
	case EmploymentTypeEnumFreelance:
		return "FREELANCE"
	}
}

func (e EmploymentTypeEnum) MarshalJSON() ([]byte, error) {
	return []byte(fmt.Sprintf("%q", e.String())), nil
}

func (e *EmploymentTypeEnum) UnmarshalJSON(data []byte) error {
	var raw string
	if err := json.Unmarshal(data, &raw); err != nil {
		return err
	}
	switch raw {
	case "FULL_TIME":
		value := EmploymentTypeEnumFullTime
		*e = value
	case "PART_TIME":
		value := EmploymentTypeEnumPartTime
		*e = value
	case "INTERN":
		value := EmploymentTypeEnumIntern
		*e = value
	case "CONTRACTOR":
		value := EmploymentTypeEnumContractor
		*e = value
	case "FREELANCE":
		value := EmploymentTypeEnumFreelance
		*e = value
	}
	return nil
}

// - `READ` - READ
// - `WRITE` - WRITE
type EnabledActionsEnum uint

const (
	EnabledActionsEnumRead EnabledActionsEnum = iota + 1
	EnabledActionsEnumWrite
)

func (e EnabledActionsEnum) String() string {
	switch e {
	default:
		return strconv.Itoa(int(e))
	case EnabledActionsEnumRead:
		return "READ"
	case EnabledActionsEnumWrite:
		return "WRITE"
	}
}

func (e EnabledActionsEnum) MarshalJSON() ([]byte, error) {
	return []byte(fmt.Sprintf("%q", e.String())), nil
}

func (e *EnabledActionsEnum) UnmarshalJSON(data []byte) error {
	var raw string
	if err := json.Unmarshal(data, &raw); err != nil {
		return err
	}
	switch raw {
	case "READ":
		value := EnabledActionsEnumRead
		*e = value
	case "WRITE":
		value := EnabledActionsEnumWrite
		*e = value
	}
	return nil
}

// - `RAW` - RAW
// - `BASE64` - BASE64
// - `GZIP_BASE64` - GZIP_BASE64
type EncodingEnum uint

const (
	EncodingEnumRaw EncodingEnum = iota + 1
	EncodingEnumBase64
	EncodingEnumGzipBase64
)

func (e EncodingEnum) String() string {
	switch e {
	default:
		return strconv.Itoa(int(e))
	case EncodingEnumRaw:
		return "RAW"
	case EncodingEnumBase64:
		return "BASE64"
	case EncodingEnumGzipBase64:
		return "GZIP_BASE64"
	}
}

func (e EncodingEnum) MarshalJSON() ([]byte, error) {
	return []byte(fmt.Sprintf("%q", e.String())), nil
}

func (e *EncodingEnum) UnmarshalJSON(data []byte) error {
	var raw string
	if err := json.Unmarshal(data, &raw); err != nil {
		return err
	}
	switch raw {
	case "RAW":
		value := EncodingEnumRaw
		*e = value
	case "BASE64":
		value := EncodingEnumBase64
		*e = value
	case "GZIP_BASE64":
		value := EncodingEnumGzipBase64
		*e = value
	}
	return nil
}

type ErrorValidationProblem struct {
	Source      *ValidationProblemSource `json:"source,omitempty"`
	Title       string                   `json:"title"`
	Detail      string                   `json:"detail"`
	ProblemType string                   `json:"problem_type"`
}

// - `AMERICAN_INDIAN_OR_ALASKA_NATIVE` - AMERICAN_INDIAN_OR_ALASKA_NATIVE
// - `ASIAN_OR_INDIAN_SUBCONTINENT` - ASIAN_OR_INDIAN_SUBCONTINENT
// - `BLACK_OR_AFRICAN_AMERICAN` - BLACK_OR_AFRICAN_AMERICAN
// - `HISPANIC_OR_LATINO` - HISPANIC_OR_LATINO
// - `NATIVE_HAWAIIAN_OR_OTHER_PACIFIC_ISLANDER` - NATIVE_HAWAIIAN_OR_OTHER_PACIFIC_ISLANDER
// - `TWO_OR_MORE_RACES` - TWO_OR_MORE_RACES
// - `WHITE` - WHITE
// - `PREFER_NOT_TO_DISCLOSE` - PREFER_NOT_TO_DISCLOSE
type EthnicityEnum uint

const (
	EthnicityEnumAmericanIndianOrAlaskaNative EthnicityEnum = iota + 1
	EthnicityEnumAsianOrIndianSubcontinent
	EthnicityEnumBlackOrAfricanAmerican
	EthnicityEnumHispanicOrLatino
	EthnicityEnumNativeHawaiianOrOtherPacificIslander
	EthnicityEnumTwoOrMoreRaces
	EthnicityEnumWhite
	EthnicityEnumPreferNotToDisclose
)

func (e EthnicityEnum) String() string {
	switch e {
	default:
		return strconv.Itoa(int(e))
	case EthnicityEnumAmericanIndianOrAlaskaNative:
		return "AMERICAN_INDIAN_OR_ALASKA_NATIVE"
	case EthnicityEnumAsianOrIndianSubcontinent:
		return "ASIAN_OR_INDIAN_SUBCONTINENT"
	case EthnicityEnumBlackOrAfricanAmerican:
		return "BLACK_OR_AFRICAN_AMERICAN"
	case EthnicityEnumHispanicOrLatino:
		return "HISPANIC_OR_LATINO"
	case EthnicityEnumNativeHawaiianOrOtherPacificIslander:
		return "NATIVE_HAWAIIAN_OR_OTHER_PACIFIC_ISLANDER"
	case EthnicityEnumTwoOrMoreRaces:
		return "TWO_OR_MORE_RACES"
	case EthnicityEnumWhite:
		return "WHITE"
	case EthnicityEnumPreferNotToDisclose:
		return "PREFER_NOT_TO_DISCLOSE"
	}
}

func (e EthnicityEnum) MarshalJSON() ([]byte, error) {
	return []byte(fmt.Sprintf("%q", e.String())), nil
}

func (e *EthnicityEnum) UnmarshalJSON(data []byte) error {
	var raw string
	if err := json.Unmarshal(data, &raw); err != nil {
		return err
	}
	switch raw {
	case "AMERICAN_INDIAN_OR_ALASKA_NATIVE":
		value := EthnicityEnumAmericanIndianOrAlaskaNative
		*e = value
	case "ASIAN_OR_INDIAN_SUBCONTINENT":
		value := EthnicityEnumAsianOrIndianSubcontinent
		*e = value
	case "BLACK_OR_AFRICAN_AMERICAN":
		value := EthnicityEnumBlackOrAfricanAmerican
		*e = value
	case "HISPANIC_OR_LATINO":
		value := EthnicityEnumHispanicOrLatino
		*e = value
	case "NATIVE_HAWAIIAN_OR_OTHER_PACIFIC_ISLANDER":
		value := EthnicityEnumNativeHawaiianOrOtherPacificIslander
		*e = value
	case "TWO_OR_MORE_RACES":
		value := EthnicityEnumTwoOrMoreRaces
		*e = value
	case "WHITE":
		value := EthnicityEnumWhite
		*e = value
	case "PREFER_NOT_TO_DISCLOSE":
		value := EthnicityEnumPreferNotToDisclose
		*e = value
	}
	return nil
}

// - `CREATED_REMOTE_PRODUCTION_API_KEY` - CREATED_REMOTE_PRODUCTION_API_KEY
// - `DELETED_REMOTE_PRODUCTION_API_KEY` - DELETED_REMOTE_PRODUCTION_API_KEY
// - `CREATED_TEST_API_KEY` - CREATED_TEST_API_KEY
// - `DELETED_TEST_API_KEY` - DELETED_TEST_API_KEY
// - `REGENERATED_PRODUCTION_API_KEY` - REGENERATED_PRODUCTION_API_KEY
// - `INVITED_USER` - INVITED_USER
// - `TWO_FACTOR_AUTH_ENABLED` - TWO_FACTOR_AUTH_ENABLED
// - `TWO_FACTOR_AUTH_DISABLED` - TWO_FACTOR_AUTH_DISABLED
// - `DELETED_LINKED_ACCOUNT` - DELETED_LINKED_ACCOUNT
// - `CREATED_DESTINATION` - CREATED_DESTINATION
// - `DELETED_DESTINATION` - DELETED_DESTINATION
// - `CHANGED_SCOPES` - CHANGED_SCOPES
// - `CHANGED_PERSONAL_INFORMATION` - CHANGED_PERSONAL_INFORMATION
// - `CHANGED_ORGANIZATION_SETTINGS` - CHANGED_ORGANIZATION_SETTINGS
// - `ENABLED_INTEGRATION` - ENABLED_INTEGRATION
// - `DISABLED_INTEGRATION` - DISABLED_INTEGRATION
// - `ENABLED_CATEGORY` - ENABLED_CATEGORY
// - `DISABLED_CATEGORY` - DISABLED_CATEGORY
// - `CHANGED_PASSWORD` - CHANGED_PASSWORD
// - `RESET_PASSWORD` - RESET_PASSWORD
// - `ENABLED_REDACT_UNMAPPED_DATA_FOR_ORGANIZATION` - ENABLED_REDACT_UNMAPPED_DATA_FOR_ORGANIZATION
// - `ENABLED_REDACT_UNMAPPED_DATA_FOR_LINKED_ACCOUNT` - ENABLED_REDACT_UNMAPPED_DATA_FOR_LINKED_ACCOUNT
// - `DISABLED_REDACT_UNMAPPED_DATA_FOR_ORGANIZATION` - DISABLED_REDACT_UNMAPPED_DATA_FOR_ORGANIZATION
// - `DISABLED_REDACT_UNMAPPED_DATA_FOR_LINKED_ACCOUNT` - DISABLED_REDACT_UNMAPPED_DATA_FOR_LINKED_ACCOUNT
// - `CREATED_INTEGRATION_WIDE_FIELD_MAPPING` - CREATED_INTEGRATION_WIDE_FIELD_MAPPING
// - `CREATED_LINKED_ACCOUNT_FIELD_MAPPING` - CREATED_LINKED_ACCOUNT_FIELD_MAPPING
// - `CHANGED_INTEGRATION_WIDE_FIELD_MAPPING` - CHANGED_INTEGRATION_WIDE_FIELD_MAPPING
// - `CHANGED_LINKED_ACCOUNT_FIELD_MAPPING` - CHANGED_LINKED_ACCOUNT_FIELD_MAPPING
// - `DELETED_INTEGRATION_WIDE_FIELD_MAPPING` - DELETED_INTEGRATION_WIDE_FIELD_MAPPING
// - `DELETED_LINKED_ACCOUNT_FIELD_MAPPING` - DELETED_LINKED_ACCOUNT_FIELD_MAPPING
type EventTypeEnum uint

const (
	EventTypeEnumCreatedRemoteProductionApiKey EventTypeEnum = iota + 1
	EventTypeEnumDeletedRemoteProductionApiKey
	EventTypeEnumCreatedTestApiKey
	EventTypeEnumDeletedTestApiKey
	EventTypeEnumRegeneratedProductionApiKey
	EventTypeEnumInvitedUser
	EventTypeEnumTwoFactorAuthEnabled
	EventTypeEnumTwoFactorAuthDisabled
	EventTypeEnumDeletedLinkedAccount
	EventTypeEnumCreatedDestination
	EventTypeEnumDeletedDestination
	EventTypeEnumChangedScopes
	EventTypeEnumChangedPersonalInformation
	EventTypeEnumChangedOrganizationSettings
	EventTypeEnumEnabledIntegration
	EventTypeEnumDisabledIntegration
	EventTypeEnumEnabledCategory
	EventTypeEnumDisabledCategory
	EventTypeEnumChangedPassword
	EventTypeEnumResetPassword
	EventTypeEnumEnabledRedactUnmappedDataForOrganization
	EventTypeEnumEnabledRedactUnmappedDataForLinkedAccount
	EventTypeEnumDisabledRedactUnmappedDataForOrganization
	EventTypeEnumDisabledRedactUnmappedDataForLinkedAccount
	EventTypeEnumCreatedIntegrationWideFieldMapping
	EventTypeEnumCreatedLinkedAccountFieldMapping
	EventTypeEnumChangedIntegrationWideFieldMapping
	EventTypeEnumChangedLinkedAccountFieldMapping
	EventTypeEnumDeletedIntegrationWideFieldMapping
	EventTypeEnumDeletedLinkedAccountFieldMapping
)

func (e EventTypeEnum) String() string {
	switch e {
	default:
		return strconv.Itoa(int(e))
	case EventTypeEnumCreatedRemoteProductionApiKey:
		return "CREATED_REMOTE_PRODUCTION_API_KEY"
	case EventTypeEnumDeletedRemoteProductionApiKey:
		return "DELETED_REMOTE_PRODUCTION_API_KEY"
	case EventTypeEnumCreatedTestApiKey:
		return "CREATED_TEST_API_KEY"
	case EventTypeEnumDeletedTestApiKey:
		return "DELETED_TEST_API_KEY"
	case EventTypeEnumRegeneratedProductionApiKey:
		return "REGENERATED_PRODUCTION_API_KEY"
	case EventTypeEnumInvitedUser:
		return "INVITED_USER"
	case EventTypeEnumTwoFactorAuthEnabled:
		return "TWO_FACTOR_AUTH_ENABLED"
	case EventTypeEnumTwoFactorAuthDisabled:
		return "TWO_FACTOR_AUTH_DISABLED"
	case EventTypeEnumDeletedLinkedAccount:
		return "DELETED_LINKED_ACCOUNT"
	case EventTypeEnumCreatedDestination:
		return "CREATED_DESTINATION"
	case EventTypeEnumDeletedDestination:
		return "DELETED_DESTINATION"
	case EventTypeEnumChangedScopes:
		return "CHANGED_SCOPES"
	case EventTypeEnumChangedPersonalInformation:
		return "CHANGED_PERSONAL_INFORMATION"
	case EventTypeEnumChangedOrganizationSettings:
		return "CHANGED_ORGANIZATION_SETTINGS"
	case EventTypeEnumEnabledIntegration:
		return "ENABLED_INTEGRATION"
	case EventTypeEnumDisabledIntegration:
		return "DISABLED_INTEGRATION"
	case EventTypeEnumEnabledCategory:
		return "ENABLED_CATEGORY"
	case EventTypeEnumDisabledCategory:
		return "DISABLED_CATEGORY"
	case EventTypeEnumChangedPassword:
		return "CHANGED_PASSWORD"
	case EventTypeEnumResetPassword:
		return "RESET_PASSWORD"
	case EventTypeEnumEnabledRedactUnmappedDataForOrganization:
		return "ENABLED_REDACT_UNMAPPED_DATA_FOR_ORGANIZATION"
	case EventTypeEnumEnabledRedactUnmappedDataForLinkedAccount:
		return "ENABLED_REDACT_UNMAPPED_DATA_FOR_LINKED_ACCOUNT"
	case EventTypeEnumDisabledRedactUnmappedDataForOrganization:
		return "DISABLED_REDACT_UNMAPPED_DATA_FOR_ORGANIZATION"
	case EventTypeEnumDisabledRedactUnmappedDataForLinkedAccount:
		return "DISABLED_REDACT_UNMAPPED_DATA_FOR_LINKED_ACCOUNT"
	case EventTypeEnumCreatedIntegrationWideFieldMapping:
		return "CREATED_INTEGRATION_WIDE_FIELD_MAPPING"
	case EventTypeEnumCreatedLinkedAccountFieldMapping:
		return "CREATED_LINKED_ACCOUNT_FIELD_MAPPING"
	case EventTypeEnumChangedIntegrationWideFieldMapping:
		return "CHANGED_INTEGRATION_WIDE_FIELD_MAPPING"
	case EventTypeEnumChangedLinkedAccountFieldMapping:
		return "CHANGED_LINKED_ACCOUNT_FIELD_MAPPING"
	case EventTypeEnumDeletedIntegrationWideFieldMapping:
		return "DELETED_INTEGRATION_WIDE_FIELD_MAPPING"
	case EventTypeEnumDeletedLinkedAccountFieldMapping:
		return "DELETED_LINKED_ACCOUNT_FIELD_MAPPING"
	}
}

func (e EventTypeEnum) MarshalJSON() ([]byte, error) {
	return []byte(fmt.Sprintf("%q", e.String())), nil
}

func (e *EventTypeEnum) UnmarshalJSON(data []byte) error {
	var raw string
	if err := json.Unmarshal(data, &raw); err != nil {
		return err
	}
	switch raw {
	case "CREATED_REMOTE_PRODUCTION_API_KEY":
		value := EventTypeEnumCreatedRemoteProductionApiKey
		*e = value
	case "DELETED_REMOTE_PRODUCTION_API_KEY":
		value := EventTypeEnumDeletedRemoteProductionApiKey
		*e = value
	case "CREATED_TEST_API_KEY":
		value := EventTypeEnumCreatedTestApiKey
		*e = value
	case "DELETED_TEST_API_KEY":
		value := EventTypeEnumDeletedTestApiKey
		*e = value
	case "REGENERATED_PRODUCTION_API_KEY":
		value := EventTypeEnumRegeneratedProductionApiKey
		*e = value
	case "INVITED_USER":
		value := EventTypeEnumInvitedUser
		*e = value
	case "TWO_FACTOR_AUTH_ENABLED":
		value := EventTypeEnumTwoFactorAuthEnabled
		*e = value
	case "TWO_FACTOR_AUTH_DISABLED":
		value := EventTypeEnumTwoFactorAuthDisabled
		*e = value
	case "DELETED_LINKED_ACCOUNT":
		value := EventTypeEnumDeletedLinkedAccount
		*e = value
	case "CREATED_DESTINATION":
		value := EventTypeEnumCreatedDestination
		*e = value
	case "DELETED_DESTINATION":
		value := EventTypeEnumDeletedDestination
		*e = value
	case "CHANGED_SCOPES":
		value := EventTypeEnumChangedScopes
		*e = value
	case "CHANGED_PERSONAL_INFORMATION":
		value := EventTypeEnumChangedPersonalInformation
		*e = value
	case "CHANGED_ORGANIZATION_SETTINGS":
		value := EventTypeEnumChangedOrganizationSettings
		*e = value
	case "ENABLED_INTEGRATION":
		value := EventTypeEnumEnabledIntegration
		*e = value
	case "DISABLED_INTEGRATION":
		value := EventTypeEnumDisabledIntegration
		*e = value
	case "ENABLED_CATEGORY":
		value := EventTypeEnumEnabledCategory
		*e = value
	case "DISABLED_CATEGORY":
		value := EventTypeEnumDisabledCategory
		*e = value
	case "CHANGED_PASSWORD":
		value := EventTypeEnumChangedPassword
		*e = value
	case "RESET_PASSWORD":
		value := EventTypeEnumResetPassword
		*e = value
	case "ENABLED_REDACT_UNMAPPED_DATA_FOR_ORGANIZATION":
		value := EventTypeEnumEnabledRedactUnmappedDataForOrganization
		*e = value
	case "ENABLED_REDACT_UNMAPPED_DATA_FOR_LINKED_ACCOUNT":
		value := EventTypeEnumEnabledRedactUnmappedDataForLinkedAccount
		*e = value
	case "DISABLED_REDACT_UNMAPPED_DATA_FOR_ORGANIZATION":
		value := EventTypeEnumDisabledRedactUnmappedDataForOrganization
		*e = value
	case "DISABLED_REDACT_UNMAPPED_DATA_FOR_LINKED_ACCOUNT":
		value := EventTypeEnumDisabledRedactUnmappedDataForLinkedAccount
		*e = value
	case "CREATED_INTEGRATION_WIDE_FIELD_MAPPING":
		value := EventTypeEnumCreatedIntegrationWideFieldMapping
		*e = value
	case "CREATED_LINKED_ACCOUNT_FIELD_MAPPING":
		value := EventTypeEnumCreatedLinkedAccountFieldMapping
		*e = value
	case "CHANGED_INTEGRATION_WIDE_FIELD_MAPPING":
		value := EventTypeEnumChangedIntegrationWideFieldMapping
		*e = value
	case "CHANGED_LINKED_ACCOUNT_FIELD_MAPPING":
		value := EventTypeEnumChangedLinkedAccountFieldMapping
		*e = value
	case "DELETED_INTEGRATION_WIDE_FIELD_MAPPING":
		value := EventTypeEnumDeletedIntegrationWideFieldMapping
		*e = value
	case "DELETED_LINKED_ACCOUNT_FIELD_MAPPING":
		value := EventTypeEnumDeletedLinkedAccountFieldMapping
		*e = value
	}
	return nil
}

// - `EXEMPT` - EXEMPT
// - `SALARIED_NONEXEMPT` - SALARIED_NONEXEMPT
// - `NONEXEMPT` - NONEXEMPT
// - `OWNER` - OWNER
type FlsaStatusEnum uint

const (
	FlsaStatusEnumExempt FlsaStatusEnum = iota + 1
	FlsaStatusEnumSalariedNonexempt
	FlsaStatusEnumNonexempt
	FlsaStatusEnumOwner
)

func (f FlsaStatusEnum) String() string {
	switch f {
	default:
		return strconv.Itoa(int(f))
	case FlsaStatusEnumExempt:
		return "EXEMPT"
	case FlsaStatusEnumSalariedNonexempt:
		return "SALARIED_NONEXEMPT"
	case FlsaStatusEnumNonexempt:
		return "NONEXEMPT"
	case FlsaStatusEnumOwner:
		return "OWNER"
	}
}

func (f FlsaStatusEnum) MarshalJSON() ([]byte, error) {
	return []byte(fmt.Sprintf("%q", f.String())), nil
}

func (f *FlsaStatusEnum) UnmarshalJSON(data []byte) error {
	var raw string
	if err := json.Unmarshal(data, &raw); err != nil {
		return err
	}
	switch raw {
	case "EXEMPT":
		value := FlsaStatusEnumExempt
		*f = value
	case "SALARIED_NONEXEMPT":
		value := FlsaStatusEnumSalariedNonexempt
		*f = value
	case "NONEXEMPT":
		value := FlsaStatusEnumNonexempt
		*f = value
	case "OWNER":
		value := FlsaStatusEnumOwner
		*f = value
	}
	return nil
}

// - `MALE` - MALE
// - `FEMALE` - FEMALE
// - `NON-BINARY` - NON-BINARY
// - `OTHER` - OTHER
// - `PREFER_NOT_TO_DISCLOSE` - PREFER_NOT_TO_DISCLOSE
type GenderEnum uint

const (
	GenderEnumMale GenderEnum = iota + 1
	GenderEnumFemale
	GenderEnumNonBinary
	GenderEnumOther
	GenderEnumPreferNotToDisclose
)

func (g GenderEnum) String() string {
	switch g {
	default:
		return strconv.Itoa(int(g))
	case GenderEnumMale:
		return "MALE"
	case GenderEnumFemale:
		return "FEMALE"
	case GenderEnumNonBinary:
		return "NON-BINARY"
	case GenderEnumOther:
		return "OTHER"
	case GenderEnumPreferNotToDisclose:
		return "PREFER_NOT_TO_DISCLOSE"
	}
}

func (g GenderEnum) MarshalJSON() ([]byte, error) {
	return []byte(fmt.Sprintf("%q", g.String())), nil
}

func (g *GenderEnum) UnmarshalJSON(data []byte) error {
	var raw string
	if err := json.Unmarshal(data, &raw); err != nil {
		return err
	}
	switch raw {
	case "MALE":
		value := GenderEnumMale
		*g = value
	case "FEMALE":
		value := GenderEnumFemale
		*g = value
	case "NON-BINARY":
		value := GenderEnumNonBinary
		*g = value
	case "OTHER":
		value := GenderEnumOther
		*g = value
	case "PREFER_NOT_TO_DISCLOSE":
		value := GenderEnumPreferNotToDisclose
		*g = value
	}
	return nil
}

// # The Group Object
//
// ### Description
//
// The `Group` object is used to represent any subset of employees, such as `PayGroup` or `Team`. Employees can be in multiple Groups.
//
// ### Usage Example
//
// Fetch from the `LIST Employee` endpoint and expand groups to view an employee's groups.
type Group struct {
	Id *string `json:"id,omitempty"`
	// The third-party API ID of the matching object.
	RemoteId *string `json:"remote_id,omitempty"`
	// The parent group for this group.
	ParentGroup *string `json:"parent_group,omitempty"`
	// The group name.
	Name *string `json:"name,omitempty"`
	// The group type
	//
	// - `TEAM` - TEAM
	// - `DEPARTMENT` - DEPARTMENT
	// - `COST_CENTER` - COST_CENTER
	// - `BUSINESS_UNIT` - BUSINESS_UNIT
	// - `GROUP` - GROUP
	Type *GroupType `json:"type,omitempty"`
	// Indicates whether or not this object has been deleted in the third party platform.
	RemoteWasDeleted *bool      `json:"remote_was_deleted,omitempty"`
	CreatedAt        *time.Time `json:"created_at,omitempty"`
	// This is the datetime that this object was last updated by Merge
	ModifiedAt    *time.Time     `json:"modified_at,omitempty"`
	FieldMappings map[string]any `json:"field_mappings,omitempty"`
	RemoteData    []*RemoteData  `json:"remote_data,omitempty"`
}

// The group type
//
// - `TEAM` - TEAM
// - `DEPARTMENT` - DEPARTMENT
// - `COST_CENTER` - COST_CENTER
// - `BUSINESS_UNIT` - BUSINESS_UNIT
// - `GROUP` - GROUP
type GroupType struct {
	typeName      string
	GroupTypeEnum GroupTypeEnum
	String        string
}

func NewGroupTypeFromGroupTypeEnum(value GroupTypeEnum) *GroupType {
	return &GroupType{typeName: "groupTypeEnum", GroupTypeEnum: value}
}

func NewGroupTypeFromString(value string) *GroupType {
	return &GroupType{typeName: "string", String: value}
}

func (g *GroupType) UnmarshalJSON(data []byte) error {
	var valueGroupTypeEnum GroupTypeEnum
	if err := json.Unmarshal(data, &valueGroupTypeEnum); err == nil {
		g.typeName = "groupTypeEnum"
		g.GroupTypeEnum = valueGroupTypeEnum
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		g.typeName = "string"
		g.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, g)
}

func (g GroupType) MarshalJSON() ([]byte, error) {
	switch g.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", g.typeName, g)
	case "groupTypeEnum":
		return json.Marshal(g.GroupTypeEnum)
	case "string":
		return json.Marshal(g.String)
	}
}

type GroupTypeVisitor interface {
	VisitGroupTypeEnum(GroupTypeEnum) error
	VisitString(string) error
}

func (g *GroupType) Accept(visitor GroupTypeVisitor) error {
	switch g.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", g.typeName, g)
	case "groupTypeEnum":
		return visitor.VisitGroupTypeEnum(g.GroupTypeEnum)
	case "string":
		return visitor.VisitString(g.String)
	}
}

// - `TEAM` - TEAM
// - `DEPARTMENT` - DEPARTMENT
// - `COST_CENTER` - COST_CENTER
// - `BUSINESS_UNIT` - BUSINESS_UNIT
// - `GROUP` - GROUP
type GroupTypeEnum uint

const (
	GroupTypeEnumTeam GroupTypeEnum = iota + 1
	GroupTypeEnumDepartment
	GroupTypeEnumCostCenter
	GroupTypeEnumBusinessUnit
	GroupTypeEnumGroup
)

func (g GroupTypeEnum) String() string {
	switch g {
	default:
		return strconv.Itoa(int(g))
	case GroupTypeEnumTeam:
		return "TEAM"
	case GroupTypeEnumDepartment:
		return "DEPARTMENT"
	case GroupTypeEnumCostCenter:
		return "COST_CENTER"
	case GroupTypeEnumBusinessUnit:
		return "BUSINESS_UNIT"
	case GroupTypeEnumGroup:
		return "GROUP"
	}
}

func (g GroupTypeEnum) MarshalJSON() ([]byte, error) {
	return []byte(fmt.Sprintf("%q", g.String())), nil
}

func (g *GroupTypeEnum) UnmarshalJSON(data []byte) error {
	var raw string
	if err := json.Unmarshal(data, &raw); err != nil {
		return err
	}
	switch raw {
	case "TEAM":
		value := GroupTypeEnumTeam
		*g = value
	case "DEPARTMENT":
		value := GroupTypeEnumDepartment
		*g = value
	case "COST_CENTER":
		value := GroupTypeEnumCostCenter
		*g = value
	case "BUSINESS_UNIT":
		value := GroupTypeEnumBusinessUnit
		*g = value
	case "GROUP":
		value := GroupTypeEnumGroup
		*g = value
	}
	return nil
}

type Issue struct {
	Id *string `json:"id,omitempty"`
	// Status of the issue. Options: ('ONGOING', 'RESOLVED')
	//
	// - `ONGOING` - ONGOING
	// - `RESOLVED` - RESOLVED
	Status            *IssueStatus   `json:"status,omitempty"`
	ErrorDescription  string         `json:"error_description"`
	EndUser           map[string]any `json:"end_user,omitempty"`
	FirstIncidentTime *time.Time     `json:"first_incident_time,omitempty"`
	LastIncidentTime  *time.Time     `json:"last_incident_time,omitempty"`
	IsMuted           *bool          `json:"is_muted,omitempty"`
	ErrorDetails      []string       `json:"error_details,omitempty"`
}

// Status of the issue. Options: ('ONGOING', 'RESOLVED')
//
// - `ONGOING` - ONGOING
// - `RESOLVED` - RESOLVED
type IssueStatus struct {
	typeName        string
	IssueStatusEnum IssueStatusEnum
	String          string
}

func NewIssueStatusFromIssueStatusEnum(value IssueStatusEnum) *IssueStatus {
	return &IssueStatus{typeName: "issueStatusEnum", IssueStatusEnum: value}
}

func NewIssueStatusFromString(value string) *IssueStatus {
	return &IssueStatus{typeName: "string", String: value}
}

func (i *IssueStatus) UnmarshalJSON(data []byte) error {
	var valueIssueStatusEnum IssueStatusEnum
	if err := json.Unmarshal(data, &valueIssueStatusEnum); err == nil {
		i.typeName = "issueStatusEnum"
		i.IssueStatusEnum = valueIssueStatusEnum
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		i.typeName = "string"
		i.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, i)
}

func (i IssueStatus) MarshalJSON() ([]byte, error) {
	switch i.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", i.typeName, i)
	case "issueStatusEnum":
		return json.Marshal(i.IssueStatusEnum)
	case "string":
		return json.Marshal(i.String)
	}
}

type IssueStatusVisitor interface {
	VisitIssueStatusEnum(IssueStatusEnum) error
	VisitString(string) error
}

func (i *IssueStatus) Accept(visitor IssueStatusVisitor) error {
	switch i.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", i.typeName, i)
	case "issueStatusEnum":
		return visitor.VisitIssueStatusEnum(i.IssueStatusEnum)
	case "string":
		return visitor.VisitString(i.String)
	}
}

// - `ONGOING` - ONGOING
// - `RESOLVED` - RESOLVED
type IssueStatusEnum uint

const (
	IssueStatusEnumOngoing IssueStatusEnum = iota + 1
	IssueStatusEnumResolved
)

func (i IssueStatusEnum) String() string {
	switch i {
	default:
		return strconv.Itoa(int(i))
	case IssueStatusEnumOngoing:
		return "ONGOING"
	case IssueStatusEnumResolved:
		return "RESOLVED"
	}
}

func (i IssueStatusEnum) MarshalJSON() ([]byte, error) {
	return []byte(fmt.Sprintf("%q", i.String())), nil
}

func (i *IssueStatusEnum) UnmarshalJSON(data []byte) error {
	var raw string
	if err := json.Unmarshal(data, &raw); err != nil {
		return err
	}
	switch raw {
	case "ONGOING":
		value := IssueStatusEnumOngoing
		*i = value
	case "RESOLVED":
		value := IssueStatusEnumResolved
		*i = value
	}
	return nil
}

type LinkToken struct {
	LinkToken       string  `json:"link_token"`
	IntegrationName *string `json:"integration_name,omitempty"`
	MagicLinkUrl    *string `json:"magic_link_url,omitempty"`
}

type LinkedAccountCondition struct {
	// The ID indicating which condition schema to use for a specific condition.
	ConditionSchemaId string `json:"condition_schema_id"`
	// The common model for a specific condition.
	CommonModel *string `json:"common_model,omitempty"`
	// User-facing _native condition_ name. e.g. "Skip Manager".
	NativeName *string `json:"native_name,omitempty"`
	// The operator for a specific condition.
	Operator string `json:"operator"`
	Value    *any   `json:"value,omitempty"`
	// The name of the field on the common model that this condition corresponds to, if they conceptually match. e.g. "location_type".
	FieldName *string `json:"field_name,omitempty"`
}

type LinkedAccountConditionRequest struct {
	// The ID indicating which condition schema to use for a specific condition.
	ConditionSchemaId string `json:"condition_schema_id"`
	// The operator for a specific condition.
	Operator string `json:"operator"`
	Value    any    `json:"value,omitempty"`
}

type LinkedAccountSelectiveSyncConfiguration struct {
	// The conditions belonging to a selective sync.
	LinkedAccountConditions []*LinkedAccountCondition `json:"linked_account_conditions,omitempty"`
}

type LinkedAccountSelectiveSyncConfigurationRequest struct {
	// The conditions belonging to a selective sync.
	LinkedAccountConditions []*LinkedAccountConditionRequest `json:"linked_account_conditions,omitempty"`
}

type LinkedAccountStatus struct {
	LinkedAccountStatus string `json:"linked_account_status"`
	CanMakeRequest      bool   `json:"can_make_request"`
}

// # The Location Object
//
// ### Description
//
// The `Location` object is used to represent an address that can be associated with an employee.
//
// ### Usage Example
//
// Fetch from the `LIST Locations` endpoint and filter by `ID` to show all office locations.
type Location struct {
	Id *string `json:"id,omitempty"`
	// The third-party API ID of the matching object.
	RemoteId *string `json:"remote_id,omitempty"`
	// The location's name.
	Name *string `json:"name,omitempty"`
	// The location's phone number.
	PhoneNumber *string `json:"phone_number,omitempty"`
	// Line 1 of the location's street address.
	Street1 *string `json:"street_1,omitempty"`
	// Line 2 of the location's street address.
	Street2 *string `json:"street_2,omitempty"`
	// The location's city.
	City *string `json:"city,omitempty"`
	// The location's state. Represents a region if outside of the US.
	State *string `json:"state,omitempty"`
	// The location's zip code or postal code.
	ZipCode *string `json:"zip_code,omitempty"`
	// The location's country.
	//
	// - `AF` - Afghanistan
	// - `AX` - Åland Islands
	// - `AL` - Albania
	// - `DZ` - Algeria
	// - `AS` - American Samoa
	// - `AD` - Andorra
	// - `AO` - Angola
	// - `AI` - Anguilla
	// - `AQ` - Antarctica
	// - `AG` - Antigua and Barbuda
	// - `AR` - Argentina
	// - `AM` - Armenia
	// - `AW` - Aruba
	// - `AU` - Australia
	// - `AT` - Austria
	// - `AZ` - Azerbaijan
	// - `BS` - Bahamas
	// - `BH` - Bahrain
	// - `BD` - Bangladesh
	// - `BB` - Barbados
	// - `BY` - Belarus
	// - `BE` - Belgium
	// - `BZ` - Belize
	// - `BJ` - Benin
	// - `BM` - Bermuda
	// - `BT` - Bhutan
	// - `BO` - Bolivia
	// - `BQ` - Bonaire, Sint Eustatius and Saba
	// - `BA` - Bosnia and Herzegovina
	// - `BW` - Botswana
	// - `BV` - Bouvet Island
	// - `BR` - Brazil
	// - `IO` - British Indian Ocean Territory
	// - `BN` - Brunei
	// - `BG` - Bulgaria
	// - `BF` - Burkina Faso
	// - `BI` - Burundi
	// - `CV` - Cabo Verde
	// - `KH` - Cambodia
	// - `CM` - Cameroon
	// - `CA` - Canada
	// - `KY` - Cayman Islands
	// - `CF` - Central African Republic
	// - `TD` - Chad
	// - `CL` - Chile
	// - `CN` - China
	// - `CX` - Christmas Island
	// - `CC` - Cocos (Keeling) Islands
	// - `CO` - Colombia
	// - `KM` - Comoros
	// - `CG` - Congo
	// - `CD` - Congo (the Democratic Republic of the)
	// - `CK` - Cook Islands
	// - `CR` - Costa Rica
	// - `CI` - Côte d'Ivoire
	// - `HR` - Croatia
	// - `CU` - Cuba
	// - `CW` - Curaçao
	// - `CY` - Cyprus
	// - `CZ` - Czechia
	// - `DK` - Denmark
	// - `DJ` - Djibouti
	// - `DM` - Dominica
	// - `DO` - Dominican Republic
	// - `EC` - Ecuador
	// - `EG` - Egypt
	// - `SV` - El Salvador
	// - `GQ` - Equatorial Guinea
	// - `ER` - Eritrea
	// - `EE` - Estonia
	// - `SZ` - Eswatini
	// - `ET` - Ethiopia
	// - `FK` - Falkland Islands (Malvinas)
	// - `FO` - Faroe Islands
	// - `FJ` - Fiji
	// - `FI` - Finland
	// - `FR` - France
	// - `GF` - French Guiana
	// - `PF` - French Polynesia
	// - `TF` - French Southern Territories
	// - `GA` - Gabon
	// - `GM` - Gambia
	// - `GE` - Georgia
	// - `DE` - Germany
	// - `GH` - Ghana
	// - `GI` - Gibraltar
	// - `GR` - Greece
	// - `GL` - Greenland
	// - `GD` - Grenada
	// - `GP` - Guadeloupe
	// - `GU` - Guam
	// - `GT` - Guatemala
	// - `GG` - Guernsey
	// - `GN` - Guinea
	// - `GW` - Guinea-Bissau
	// - `GY` - Guyana
	// - `HT` - Haiti
	// - `HM` - Heard Island and McDonald Islands
	// - `VA` - Holy See
	// - `HN` - Honduras
	// - `HK` - Hong Kong
	// - `HU` - Hungary
	// - `IS` - Iceland
	// - `IN` - India
	// - `ID` - Indonesia
	// - `IR` - Iran
	// - `IQ` - Iraq
	// - `IE` - Ireland
	// - `IM` - Isle of Man
	// - `IL` - Israel
	// - `IT` - Italy
	// - `JM` - Jamaica
	// - `JP` - Japan
	// - `JE` - Jersey
	// - `JO` - Jordan
	// - `KZ` - Kazakhstan
	// - `KE` - Kenya
	// - `KI` - Kiribati
	// - `KW` - Kuwait
	// - `KG` - Kyrgyzstan
	// - `LA` - Laos
	// - `LV` - Latvia
	// - `LB` - Lebanon
	// - `LS` - Lesotho
	// - `LR` - Liberia
	// - `LY` - Libya
	// - `LI` - Liechtenstein
	// - `LT` - Lithuania
	// - `LU` - Luxembourg
	// - `MO` - Macao
	// - `MG` - Madagascar
	// - `MW` - Malawi
	// - `MY` - Malaysia
	// - `MV` - Maldives
	// - `ML` - Mali
	// - `MT` - Malta
	// - `MH` - Marshall Islands
	// - `MQ` - Martinique
	// - `MR` - Mauritania
	// - `MU` - Mauritius
	// - `YT` - Mayotte
	// - `MX` - Mexico
	// - `FM` - Micronesia (Federated States of)
	// - `MD` - Moldova
	// - `MC` - Monaco
	// - `MN` - Mongolia
	// - `ME` - Montenegro
	// - `MS` - Montserrat
	// - `MA` - Morocco
	// - `MZ` - Mozambique
	// - `MM` - Myanmar
	// - `NA` - Namibia
	// - `NR` - Nauru
	// - `NP` - Nepal
	// - `NL` - Netherlands
	// - `NC` - New Caledonia
	// - `NZ` - New Zealand
	// - `NI` - Nicaragua
	// - `NE` - Niger
	// - `NG` - Nigeria
	// - `NU` - Niue
	// - `NF` - Norfolk Island
	// - `KP` - North Korea
	// - `MK` - North Macedonia
	// - `MP` - Northern Mariana Islands
	// - `NO` - Norway
	// - `OM` - Oman
	// - `PK` - Pakistan
	// - `PW` - Palau
	// - `PS` - Palestine, State of
	// - `PA` - Panama
	// - `PG` - Papua New Guinea
	// - `PY` - Paraguay
	// - `PE` - Peru
	// - `PH` - Philippines
	// - `PN` - Pitcairn
	// - `PL` - Poland
	// - `PT` - Portugal
	// - `PR` - Puerto Rico
	// - `QA` - Qatar
	// - `RE` - Réunion
	// - `RO` - Romania
	// - `RU` - Russia
	// - `RW` - Rwanda
	// - `BL` - Saint Barthélemy
	// - `SH` - Saint Helena, Ascension and Tristan da Cunha
	// - `KN` - Saint Kitts and Nevis
	// - `LC` - Saint Lucia
	// - `MF` - Saint Martin (French part)
	// - `PM` - Saint Pierre and Miquelon
	// - `VC` - Saint Vincent and the Grenadines
	// - `WS` - Samoa
	// - `SM` - San Marino
	// - `ST` - Sao Tome and Principe
	// - `SA` - Saudi Arabia
	// - `SN` - Senegal
	// - `RS` - Serbia
	// - `SC` - Seychelles
	// - `SL` - Sierra Leone
	// - `SG` - Singapore
	// - `SX` - Sint Maarten (Dutch part)
	// - `SK` - Slovakia
	// - `SI` - Slovenia
	// - `SB` - Solomon Islands
	// - `SO` - Somalia
	// - `ZA` - South Africa
	// - `GS` - South Georgia and the South Sandwich Islands
	// - `KR` - South Korea
	// - `SS` - South Sudan
	// - `ES` - Spain
	// - `LK` - Sri Lanka
	// - `SD` - Sudan
	// - `SR` - Suriname
	// - `SJ` - Svalbard and Jan Mayen
	// - `SE` - Sweden
	// - `CH` - Switzerland
	// - `SY` - Syria
	// - `TW` - Taiwan
	// - `TJ` - Tajikistan
	// - `TZ` - Tanzania
	// - `TH` - Thailand
	// - `TL` - Timor-Leste
	// - `TG` - Togo
	// - `TK` - Tokelau
	// - `TO` - Tonga
	// - `TT` - Trinidad and Tobago
	// - `TN` - Tunisia
	// - `TR` - Turkey
	// - `TM` - Turkmenistan
	// - `TC` - Turks and Caicos Islands
	// - `TV` - Tuvalu
	// - `UG` - Uganda
	// - `UA` - Ukraine
	// - `AE` - United Arab Emirates
	// - `GB` - United Kingdom
	// - `UM` - United States Minor Outlying Islands
	// - `US` - United States of America
	// - `UY` - Uruguay
	// - `UZ` - Uzbekistan
	// - `VU` - Vanuatu
	// - `VE` - Venezuela
	// - `VN` - Vietnam
	// - `VG` - Virgin Islands (British)
	// - `VI` - Virgin Islands (U.S.)
	// - `WF` - Wallis and Futuna
	// - `EH` - Western Sahara
	// - `YE` - Yemen
	// - `ZM` - Zambia
	// - `ZW` - Zimbabwe
	Country *LocationCountry `json:"country,omitempty"`
	// The location's type. Can be either WORK or HOME
	//
	// - `HOME` - HOME
	// - `WORK` - WORK
	LocationType *LocationLocationType `json:"location_type,omitempty"`
	// Indicates whether or not this object has been deleted in the third party platform.
	RemoteWasDeleted *bool      `json:"remote_was_deleted,omitempty"`
	CreatedAt        *time.Time `json:"created_at,omitempty"`
	// This is the datetime that this object was last updated by Merge
	ModifiedAt    *time.Time     `json:"modified_at,omitempty"`
	FieldMappings map[string]any `json:"field_mappings,omitempty"`
	RemoteData    []*RemoteData  `json:"remote_data,omitempty"`
}

// The location's country.
//
// - `AF` - Afghanistan
// - `AX` - Åland Islands
// - `AL` - Albania
// - `DZ` - Algeria
// - `AS` - American Samoa
// - `AD` - Andorra
// - `AO` - Angola
// - `AI` - Anguilla
// - `AQ` - Antarctica
// - `AG` - Antigua and Barbuda
// - `AR` - Argentina
// - `AM` - Armenia
// - `AW` - Aruba
// - `AU` - Australia
// - `AT` - Austria
// - `AZ` - Azerbaijan
// - `BS` - Bahamas
// - `BH` - Bahrain
// - `BD` - Bangladesh
// - `BB` - Barbados
// - `BY` - Belarus
// - `BE` - Belgium
// - `BZ` - Belize
// - `BJ` - Benin
// - `BM` - Bermuda
// - `BT` - Bhutan
// - `BO` - Bolivia
// - `BQ` - Bonaire, Sint Eustatius and Saba
// - `BA` - Bosnia and Herzegovina
// - `BW` - Botswana
// - `BV` - Bouvet Island
// - `BR` - Brazil
// - `IO` - British Indian Ocean Territory
// - `BN` - Brunei
// - `BG` - Bulgaria
// - `BF` - Burkina Faso
// - `BI` - Burundi
// - `CV` - Cabo Verde
// - `KH` - Cambodia
// - `CM` - Cameroon
// - `CA` - Canada
// - `KY` - Cayman Islands
// - `CF` - Central African Republic
// - `TD` - Chad
// - `CL` - Chile
// - `CN` - China
// - `CX` - Christmas Island
// - `CC` - Cocos (Keeling) Islands
// - `CO` - Colombia
// - `KM` - Comoros
// - `CG` - Congo
// - `CD` - Congo (the Democratic Republic of the)
// - `CK` - Cook Islands
// - `CR` - Costa Rica
// - `CI` - Côte d'Ivoire
// - `HR` - Croatia
// - `CU` - Cuba
// - `CW` - Curaçao
// - `CY` - Cyprus
// - `CZ` - Czechia
// - `DK` - Denmark
// - `DJ` - Djibouti
// - `DM` - Dominica
// - `DO` - Dominican Republic
// - `EC` - Ecuador
// - `EG` - Egypt
// - `SV` - El Salvador
// - `GQ` - Equatorial Guinea
// - `ER` - Eritrea
// - `EE` - Estonia
// - `SZ` - Eswatini
// - `ET` - Ethiopia
// - `FK` - Falkland Islands (Malvinas)
// - `FO` - Faroe Islands
// - `FJ` - Fiji
// - `FI` - Finland
// - `FR` - France
// - `GF` - French Guiana
// - `PF` - French Polynesia
// - `TF` - French Southern Territories
// - `GA` - Gabon
// - `GM` - Gambia
// - `GE` - Georgia
// - `DE` - Germany
// - `GH` - Ghana
// - `GI` - Gibraltar
// - `GR` - Greece
// - `GL` - Greenland
// - `GD` - Grenada
// - `GP` - Guadeloupe
// - `GU` - Guam
// - `GT` - Guatemala
// - `GG` - Guernsey
// - `GN` - Guinea
// - `GW` - Guinea-Bissau
// - `GY` - Guyana
// - `HT` - Haiti
// - `HM` - Heard Island and McDonald Islands
// - `VA` - Holy See
// - `HN` - Honduras
// - `HK` - Hong Kong
// - `HU` - Hungary
// - `IS` - Iceland
// - `IN` - India
// - `ID` - Indonesia
// - `IR` - Iran
// - `IQ` - Iraq
// - `IE` - Ireland
// - `IM` - Isle of Man
// - `IL` - Israel
// - `IT` - Italy
// - `JM` - Jamaica
// - `JP` - Japan
// - `JE` - Jersey
// - `JO` - Jordan
// - `KZ` - Kazakhstan
// - `KE` - Kenya
// - `KI` - Kiribati
// - `KW` - Kuwait
// - `KG` - Kyrgyzstan
// - `LA` - Laos
// - `LV` - Latvia
// - `LB` - Lebanon
// - `LS` - Lesotho
// - `LR` - Liberia
// - `LY` - Libya
// - `LI` - Liechtenstein
// - `LT` - Lithuania
// - `LU` - Luxembourg
// - `MO` - Macao
// - `MG` - Madagascar
// - `MW` - Malawi
// - `MY` - Malaysia
// - `MV` - Maldives
// - `ML` - Mali
// - `MT` - Malta
// - `MH` - Marshall Islands
// - `MQ` - Martinique
// - `MR` - Mauritania
// - `MU` - Mauritius
// - `YT` - Mayotte
// - `MX` - Mexico
// - `FM` - Micronesia (Federated States of)
// - `MD` - Moldova
// - `MC` - Monaco
// - `MN` - Mongolia
// - `ME` - Montenegro
// - `MS` - Montserrat
// - `MA` - Morocco
// - `MZ` - Mozambique
// - `MM` - Myanmar
// - `NA` - Namibia
// - `NR` - Nauru
// - `NP` - Nepal
// - `NL` - Netherlands
// - `NC` - New Caledonia
// - `NZ` - New Zealand
// - `NI` - Nicaragua
// - `NE` - Niger
// - `NG` - Nigeria
// - `NU` - Niue
// - `NF` - Norfolk Island
// - `KP` - North Korea
// - `MK` - North Macedonia
// - `MP` - Northern Mariana Islands
// - `NO` - Norway
// - `OM` - Oman
// - `PK` - Pakistan
// - `PW` - Palau
// - `PS` - Palestine, State of
// - `PA` - Panama
// - `PG` - Papua New Guinea
// - `PY` - Paraguay
// - `PE` - Peru
// - `PH` - Philippines
// - `PN` - Pitcairn
// - `PL` - Poland
// - `PT` - Portugal
// - `PR` - Puerto Rico
// - `QA` - Qatar
// - `RE` - Réunion
// - `RO` - Romania
// - `RU` - Russia
// - `RW` - Rwanda
// - `BL` - Saint Barthélemy
// - `SH` - Saint Helena, Ascension and Tristan da Cunha
// - `KN` - Saint Kitts and Nevis
// - `LC` - Saint Lucia
// - `MF` - Saint Martin (French part)
// - `PM` - Saint Pierre and Miquelon
// - `VC` - Saint Vincent and the Grenadines
// - `WS` - Samoa
// - `SM` - San Marino
// - `ST` - Sao Tome and Principe
// - `SA` - Saudi Arabia
// - `SN` - Senegal
// - `RS` - Serbia
// - `SC` - Seychelles
// - `SL` - Sierra Leone
// - `SG` - Singapore
// - `SX` - Sint Maarten (Dutch part)
// - `SK` - Slovakia
// - `SI` - Slovenia
// - `SB` - Solomon Islands
// - `SO` - Somalia
// - `ZA` - South Africa
// - `GS` - South Georgia and the South Sandwich Islands
// - `KR` - South Korea
// - `SS` - South Sudan
// - `ES` - Spain
// - `LK` - Sri Lanka
// - `SD` - Sudan
// - `SR` - Suriname
// - `SJ` - Svalbard and Jan Mayen
// - `SE` - Sweden
// - `CH` - Switzerland
// - `SY` - Syria
// - `TW` - Taiwan
// - `TJ` - Tajikistan
// - `TZ` - Tanzania
// - `TH` - Thailand
// - `TL` - Timor-Leste
// - `TG` - Togo
// - `TK` - Tokelau
// - `TO` - Tonga
// - `TT` - Trinidad and Tobago
// - `TN` - Tunisia
// - `TR` - Turkey
// - `TM` - Turkmenistan
// - `TC` - Turks and Caicos Islands
// - `TV` - Tuvalu
// - `UG` - Uganda
// - `UA` - Ukraine
// - `AE` - United Arab Emirates
// - `GB` - United Kingdom
// - `UM` - United States Minor Outlying Islands
// - `US` - United States of America
// - `UY` - Uruguay
// - `UZ` - Uzbekistan
// - `VU` - Vanuatu
// - `VE` - Venezuela
// - `VN` - Vietnam
// - `VG` - Virgin Islands (British)
// - `VI` - Virgin Islands (U.S.)
// - `WF` - Wallis and Futuna
// - `EH` - Western Sahara
// - `YE` - Yemen
// - `ZM` - Zambia
// - `ZW` - Zimbabwe
type LocationCountry struct {
	typeName    string
	CountryEnum CountryEnum
	String      string
}

func NewLocationCountryFromCountryEnum(value CountryEnum) *LocationCountry {
	return &LocationCountry{typeName: "countryEnum", CountryEnum: value}
}

func NewLocationCountryFromString(value string) *LocationCountry {
	return &LocationCountry{typeName: "string", String: value}
}

func (l *LocationCountry) UnmarshalJSON(data []byte) error {
	var valueCountryEnum CountryEnum
	if err := json.Unmarshal(data, &valueCountryEnum); err == nil {
		l.typeName = "countryEnum"
		l.CountryEnum = valueCountryEnum
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		l.typeName = "string"
		l.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, l)
}

func (l LocationCountry) MarshalJSON() ([]byte, error) {
	switch l.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", l.typeName, l)
	case "countryEnum":
		return json.Marshal(l.CountryEnum)
	case "string":
		return json.Marshal(l.String)
	}
}

type LocationCountryVisitor interface {
	VisitCountryEnum(CountryEnum) error
	VisitString(string) error
}

func (l *LocationCountry) Accept(visitor LocationCountryVisitor) error {
	switch l.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", l.typeName, l)
	case "countryEnum":
		return visitor.VisitCountryEnum(l.CountryEnum)
	case "string":
		return visitor.VisitString(l.String)
	}
}

// The location's type. Can be either WORK or HOME
//
// - `HOME` - HOME
// - `WORK` - WORK
type LocationLocationType struct {
	typeName         string
	LocationTypeEnum LocationTypeEnum
	String           string
}

func NewLocationLocationTypeFromLocationTypeEnum(value LocationTypeEnum) *LocationLocationType {
	return &LocationLocationType{typeName: "locationTypeEnum", LocationTypeEnum: value}
}

func NewLocationLocationTypeFromString(value string) *LocationLocationType {
	return &LocationLocationType{typeName: "string", String: value}
}

func (l *LocationLocationType) UnmarshalJSON(data []byte) error {
	var valueLocationTypeEnum LocationTypeEnum
	if err := json.Unmarshal(data, &valueLocationTypeEnum); err == nil {
		l.typeName = "locationTypeEnum"
		l.LocationTypeEnum = valueLocationTypeEnum
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		l.typeName = "string"
		l.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, l)
}

func (l LocationLocationType) MarshalJSON() ([]byte, error) {
	switch l.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", l.typeName, l)
	case "locationTypeEnum":
		return json.Marshal(l.LocationTypeEnum)
	case "string":
		return json.Marshal(l.String)
	}
}

type LocationLocationTypeVisitor interface {
	VisitLocationTypeEnum(LocationTypeEnum) error
	VisitString(string) error
}

func (l *LocationLocationType) Accept(visitor LocationLocationTypeVisitor) error {
	switch l.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", l.typeName, l)
	case "locationTypeEnum":
		return visitor.VisitLocationTypeEnum(l.LocationTypeEnum)
	case "string":
		return visitor.VisitString(l.String)
	}
}

// - `HOME` - HOME
// - `WORK` - WORK
type LocationTypeEnum uint

const (
	LocationTypeEnumHome LocationTypeEnum = iota + 1
	LocationTypeEnumWork
)

func (l LocationTypeEnum) String() string {
	switch l {
	default:
		return strconv.Itoa(int(l))
	case LocationTypeEnumHome:
		return "HOME"
	case LocationTypeEnumWork:
		return "WORK"
	}
}

func (l LocationTypeEnum) MarshalJSON() ([]byte, error) {
	return []byte(fmt.Sprintf("%q", l.String())), nil
}

func (l *LocationTypeEnum) UnmarshalJSON(data []byte) error {
	var raw string
	if err := json.Unmarshal(data, &raw); err != nil {
		return err
	}
	switch raw {
	case "HOME":
		value := LocationTypeEnumHome
		*l = value
	case "WORK":
		value := LocationTypeEnumWork
		*l = value
	}
	return nil
}

// - `SINGLE` - SINGLE
// - `MARRIED_FILING_JOINTLY` - MARRIED_FILING_JOINTLY
// - `MARRIED_FILING_SEPARATELY` - MARRIED_FILING_SEPARATELY
// - `HEAD_OF_HOUSEHOLD` - HEAD_OF_HOUSEHOLD
// - `QUALIFYING_WIDOW_OR_WIDOWER_WITH_DEPENDENT_CHILD` - QUALIFYING_WIDOW_OR_WIDOWER_WITH_DEPENDENT_CHILD
type MaritalStatusEnum uint

const (
	MaritalStatusEnumSingle MaritalStatusEnum = iota + 1
	MaritalStatusEnumMarriedFilingJointly
	MaritalStatusEnumMarriedFilingSeparately
	MaritalStatusEnumHeadOfHousehold
	MaritalStatusEnumQualifyingWidowOrWidowerWithDependentChild
)

func (m MaritalStatusEnum) String() string {
	switch m {
	default:
		return strconv.Itoa(int(m))
	case MaritalStatusEnumSingle:
		return "SINGLE"
	case MaritalStatusEnumMarriedFilingJointly:
		return "MARRIED_FILING_JOINTLY"
	case MaritalStatusEnumMarriedFilingSeparately:
		return "MARRIED_FILING_SEPARATELY"
	case MaritalStatusEnumHeadOfHousehold:
		return "HEAD_OF_HOUSEHOLD"
	case MaritalStatusEnumQualifyingWidowOrWidowerWithDependentChild:
		return "QUALIFYING_WIDOW_OR_WIDOWER_WITH_DEPENDENT_CHILD"
	}
}

func (m MaritalStatusEnum) MarshalJSON() ([]byte, error) {
	return []byte(fmt.Sprintf("%q", m.String())), nil
}

func (m *MaritalStatusEnum) UnmarshalJSON(data []byte) error {
	var raw string
	if err := json.Unmarshal(data, &raw); err != nil {
		return err
	}
	switch raw {
	case "SINGLE":
		value := MaritalStatusEnumSingle
		*m = value
	case "MARRIED_FILING_JOINTLY":
		value := MaritalStatusEnumMarriedFilingJointly
		*m = value
	case "MARRIED_FILING_SEPARATELY":
		value := MaritalStatusEnumMarriedFilingSeparately
		*m = value
	case "HEAD_OF_HOUSEHOLD":
		value := MaritalStatusEnumHeadOfHousehold
		*m = value
	case "QUALIFYING_WIDOW_OR_WIDOWER_WITH_DEPENDENT_CHILD":
		value := MaritalStatusEnumQualifyingWidowOrWidowerWithDependentChild
		*m = value
	}
	return nil
}

type MetaResponse struct {
	RequestSchema                  map[string]any       `json:"request_schema,omitempty"`
	RemoteFieldClasses             map[string]any       `json:"remote_field_classes,omitempty"`
	Status                         *LinkedAccountStatus `json:"status,omitempty"`
	HasConditionalParams           bool                 `json:"has_conditional_params"`
	HasRequiredLinkedAccountParams bool                 `json:"has_required_linked_account_params"`
}

// - `GET` - GET
// - `OPTIONS` - OPTIONS
// - `HEAD` - HEAD
// - `POST` - POST
// - `PUT` - PUT
// - `PATCH` - PATCH
// - `DELETE` - DELETE
type MethodEnum uint

const (
	MethodEnumGet MethodEnum = iota + 1
	MethodEnumOptions
	MethodEnumHead
	MethodEnumPost
	MethodEnumPut
	MethodEnumPatch
	MethodEnumDelete
)

func (m MethodEnum) String() string {
	switch m {
	default:
		return strconv.Itoa(int(m))
	case MethodEnumGet:
		return "GET"
	case MethodEnumOptions:
		return "OPTIONS"
	case MethodEnumHead:
		return "HEAD"
	case MethodEnumPost:
		return "POST"
	case MethodEnumPut:
		return "PUT"
	case MethodEnumPatch:
		return "PATCH"
	case MethodEnumDelete:
		return "DELETE"
	}
}

func (m MethodEnum) MarshalJSON() ([]byte, error) {
	return []byte(fmt.Sprintf("%q", m.String())), nil
}

func (m *MethodEnum) UnmarshalJSON(data []byte) error {
	var raw string
	if err := json.Unmarshal(data, &raw); err != nil {
		return err
	}
	switch raw {
	case "GET":
		value := MethodEnumGet
		*m = value
	case "OPTIONS":
		value := MethodEnumOptions
		*m = value
	case "HEAD":
		value := MethodEnumHead
		*m = value
	case "POST":
		value := MethodEnumPost
		*m = value
	case "PUT":
		value := MethodEnumPut
		*m = value
	case "PATCH":
		value := MethodEnumPatch
		*m = value
	case "DELETE":
		value := MethodEnumDelete
		*m = value
	}
	return nil
}

// # The ModelOperation Object
//
// ### Description
//
// The `ModelOperation` object is used to represent the operations that are currently supported for a given model.
//
// ### Usage Example
//
// View what operations are supported for the `Candidate` endpoint.
type ModelOperation struct {
	ModelName              string   `json:"model_name"`
	AvailableOperations    []string `json:"available_operations,omitempty"`
	RequiredPostParameters []string `json:"required_post_parameters,omitempty"`
	SupportedFields        []string `json:"supported_fields,omitempty"`
}

// # The MultipartFormField Object
//
// ### Description
//
// The `MultipartFormField` object is used to represent fields in an HTTP request using `multipart/form-data`.
//
// ### Usage Example
//
// Create a `MultipartFormField` to define a multipart form entry.
type MultipartFormFieldRequest struct {
	// The name of the form field
	Name string `json:"name"`
	// The data for the form field.
	Data string `json:"data"`
	// The encoding of the value of `data`. Defaults to `RAW` if not defined.
	//
	// - `RAW` - RAW
	// - `BASE64` - BASE64
	// - `GZIP_BASE64` - GZIP_BASE64
	Encoding *MultipartFormFieldRequestEncoding `json:"encoding,omitempty"`
	// The file name of the form field, if the field is for a file.
	FileName *string `json:"file_name,omitempty"`
	// The MIME type of the file, if the field is for a file.
	ContentType *string `json:"content_type,omitempty"`
}

// The encoding of the value of `data`. Defaults to `RAW` if not defined.
//
// - `RAW` - RAW
// - `BASE64` - BASE64
// - `GZIP_BASE64` - GZIP_BASE64
type MultipartFormFieldRequestEncoding struct {
	typeName     string
	EncodingEnum EncodingEnum
	String       string
}

func NewMultipartFormFieldRequestEncodingFromEncodingEnum(value EncodingEnum) *MultipartFormFieldRequestEncoding {
	return &MultipartFormFieldRequestEncoding{typeName: "encodingEnum", EncodingEnum: value}
}

func NewMultipartFormFieldRequestEncodingFromString(value string) *MultipartFormFieldRequestEncoding {
	return &MultipartFormFieldRequestEncoding{typeName: "string", String: value}
}

func (m *MultipartFormFieldRequestEncoding) UnmarshalJSON(data []byte) error {
	var valueEncodingEnum EncodingEnum
	if err := json.Unmarshal(data, &valueEncodingEnum); err == nil {
		m.typeName = "encodingEnum"
		m.EncodingEnum = valueEncodingEnum
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		m.typeName = "string"
		m.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, m)
}

func (m MultipartFormFieldRequestEncoding) MarshalJSON() ([]byte, error) {
	switch m.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", m.typeName, m)
	case "encodingEnum":
		return json.Marshal(m.EncodingEnum)
	case "string":
		return json.Marshal(m.String)
	}
}

type MultipartFormFieldRequestEncodingVisitor interface {
	VisitEncodingEnum(EncodingEnum) error
	VisitString(string) error
}

func (m *MultipartFormFieldRequestEncoding) Accept(visitor MultipartFormFieldRequestEncodingVisitor) error {
	switch m.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", m.typeName, m)
	case "encodingEnum":
		return visitor.VisitEncodingEnum(m.EncodingEnum)
	case "string":
		return visitor.VisitString(m.String)
	}
}

type OperatorSchema struct {
	// The operator for which an operator schema is defined.
	Operator *string `json:"operator,omitempty"`
	// Whether the operator can be repeated multiple times.
	IsUnique *bool `json:"is_unique,omitempty"`
}

type PaginatedAccountDetailsAndActionsList struct {
	Next     *string                     `json:"next,omitempty"`
	Previous *string                     `json:"previous,omitempty"`
	Results  []*AccountDetailsAndActions `json:"results,omitempty"`
}

type PaginatedAuditLogEventList struct {
	Next     *string          `json:"next,omitempty"`
	Previous *string          `json:"previous,omitempty"`
	Results  []*AuditLogEvent `json:"results,omitempty"`
}

type PaginatedBankInfoList struct {
	Next     *string     `json:"next,omitempty"`
	Previous *string     `json:"previous,omitempty"`
	Results  []*BankInfo `json:"results,omitempty"`
}

type PaginatedBenefitList struct {
	Next     *string    `json:"next,omitempty"`
	Previous *string    `json:"previous,omitempty"`
	Results  []*Benefit `json:"results,omitempty"`
}

type PaginatedCompanyList struct {
	Next     *string    `json:"next,omitempty"`
	Previous *string    `json:"previous,omitempty"`
	Results  []*Company `json:"results,omitempty"`
}

type PaginatedConditionSchemaList struct {
	Next     *string            `json:"next,omitempty"`
	Previous *string            `json:"previous,omitempty"`
	Results  []*ConditionSchema `json:"results,omitempty"`
}

type PaginatedDependentList struct {
	Next     *string      `json:"next,omitempty"`
	Previous *string      `json:"previous,omitempty"`
	Results  []*Dependent `json:"results,omitempty"`
}

type PaginatedEmployeeList struct {
	Next     *string     `json:"next,omitempty"`
	Previous *string     `json:"previous,omitempty"`
	Results  []*Employee `json:"results,omitempty"`
}

type PaginatedEmployeePayrollRunList struct {
	Next     *string               `json:"next,omitempty"`
	Previous *string               `json:"previous,omitempty"`
	Results  []*EmployeePayrollRun `json:"results,omitempty"`
}

type PaginatedEmployerBenefitList struct {
	Next     *string            `json:"next,omitempty"`
	Previous *string            `json:"previous,omitempty"`
	Results  []*EmployerBenefit `json:"results,omitempty"`
}

type PaginatedEmploymentList struct {
	Next     *string       `json:"next,omitempty"`
	Previous *string       `json:"previous,omitempty"`
	Results  []*Employment `json:"results,omitempty"`
}

type PaginatedGroupList struct {
	Next     *string  `json:"next,omitempty"`
	Previous *string  `json:"previous,omitempty"`
	Results  []*Group `json:"results,omitempty"`
}

type PaginatedIssueList struct {
	Next     *string  `json:"next,omitempty"`
	Previous *string  `json:"previous,omitempty"`
	Results  []*Issue `json:"results,omitempty"`
}

type PaginatedLocationList struct {
	Next     *string     `json:"next,omitempty"`
	Previous *string     `json:"previous,omitempty"`
	Results  []*Location `json:"results,omitempty"`
}

type PaginatedPayGroupList struct {
	Next     *string     `json:"next,omitempty"`
	Previous *string     `json:"previous,omitempty"`
	Results  []*PayGroup `json:"results,omitempty"`
}

type PaginatedPayrollRunList struct {
	Next     *string       `json:"next,omitempty"`
	Previous *string       `json:"previous,omitempty"`
	Results  []*PayrollRun `json:"results,omitempty"`
}

type PaginatedSyncStatusList struct {
	Next     *string       `json:"next,omitempty"`
	Previous *string       `json:"previous,omitempty"`
	Results  []*SyncStatus `json:"results,omitempty"`
}

type PaginatedTeamList struct {
	Next     *string `json:"next,omitempty"`
	Previous *string `json:"previous,omitempty"`
	Results  []*Team `json:"results,omitempty"`
}

type PaginatedTimeOffBalanceList struct {
	Next     *string           `json:"next,omitempty"`
	Previous *string           `json:"previous,omitempty"`
	Results  []*TimeOffBalance `json:"results,omitempty"`
}

type PaginatedTimeOffList struct {
	Next     *string    `json:"next,omitempty"`
	Previous *string    `json:"previous,omitempty"`
	Results  []*TimeOff `json:"results,omitempty"`
}

type PaginatedTimesheetEntryList struct {
	Next     *string           `json:"next,omitempty"`
	Previous *string           `json:"previous,omitempty"`
	Results  []*TimesheetEntry `json:"results,omitempty"`
}

// - `XUA` - ADB Unit of Account
// - `AFN` - Afghan Afghani
// - `AFA` - Afghan Afghani (1927–2002)
// - `ALL` - Albanian Lek
// - `ALK` - Albanian Lek (1946–1965)
// - `DZD` - Algerian Dinar
// - `ADP` - Andorran Peseta
// - `AOA` - Angolan Kwanza
// - `AOK` - Angolan Kwanza (1977–1991)
// - `AON` - Angolan New Kwanza (1990–2000)
// - `AOR` - Angolan Readjusted Kwanza (1995–1999)
// - `ARA` - Argentine Austral
// - `ARS` - Argentine Peso
// - `ARM` - Argentine Peso (1881–1970)
// - `ARP` - Argentine Peso (1983–1985)
// - `ARL` - Argentine Peso Ley (1970–1983)
// - `AMD` - Armenian Dram
// - `AWG` - Aruban Florin
// - `AUD` - Australian Dollar
// - `ATS` - Austrian Schilling
// - `AZN` - Azerbaijani Manat
// - `AZM` - Azerbaijani Manat (1993–2006)
// - `BSD` - Bahamian Dollar
// - `BHD` - Bahraini Dinar
// - `BDT` - Bangladeshi Taka
// - `BBD` - Barbadian Dollar
// - `BYN` - Belarusian Ruble
// - `BYB` - Belarusian Ruble (1994–1999)
// - `BYR` - Belarusian Ruble (2000–2016)
// - `BEF` - Belgian Franc
// - `BEC` - Belgian Franc (convertible)
// - `BEL` - Belgian Franc (financial)
// - `BZD` - Belize Dollar
// - `BMD` - Bermudan Dollar
// - `BTN` - Bhutanese Ngultrum
// - `BOB` - Bolivian Boliviano
// - `BOL` - Bolivian Boliviano (1863–1963)
// - `BOV` - Bolivian Mvdol
// - `BOP` - Bolivian Peso
// - `BAM` - Bosnia-Herzegovina Convertible Mark
// - `BAD` - Bosnia-Herzegovina Dinar (1992–1994)
// - `BAN` - Bosnia-Herzegovina New Dinar (1994–1997)
// - `BWP` - Botswanan Pula
// - `BRC` - Brazilian Cruzado (1986–1989)
// - `BRZ` - Brazilian Cruzeiro (1942–1967)
// - `BRE` - Brazilian Cruzeiro (1990–1993)
// - `BRR` - Brazilian Cruzeiro (1993–1994)
// - `BRN` - Brazilian New Cruzado (1989–1990)
// - `BRB` - Brazilian New Cruzeiro (1967–1986)
// - `BRL` - Brazilian Real
// - `GBP` - British Pound
// - `BND` - Brunei Dollar
// - `BGL` - Bulgarian Hard Lev
// - `BGN` - Bulgarian Lev
// - `BGO` - Bulgarian Lev (1879–1952)
// - `BGM` - Bulgarian Socialist Lev
// - `BUK` - Burmese Kyat
// - `BIF` - Burundian Franc
// - `XPF` - CFP Franc
// - `KHR` - Cambodian Riel
// - `CAD` - Canadian Dollar
// - `CVE` - Cape Verdean Escudo
// - `KYD` - Cayman Islands Dollar
// - `XAF` - Central African CFA Franc
// - `CLE` - Chilean Escudo
// - `CLP` - Chilean Peso
// - `CLF` - Chilean Unit of Account (UF)
// - `CNX` - Chinese People’s Bank Dollar
// - `CNY` - Chinese Yuan
// - `CNH` - Chinese Yuan (offshore)
// - `COP` - Colombian Peso
// - `COU` - Colombian Real Value Unit
// - `KMF` - Comorian Franc
// - `CDF` - Congolese Franc
// - `CRC` - Costa Rican Colón
// - `HRD` - Croatian Dinar
// - `HRK` - Croatian Kuna
// - `CUC` - Cuban Convertible Peso
// - `CUP` - Cuban Peso
// - `CYP` - Cypriot Pound
// - `CZK` - Czech Koruna
// - `CSK` - Czechoslovak Hard Koruna
// - `DKK` - Danish Krone
// - `DJF` - Djiboutian Franc
// - `DOP` - Dominican Peso
// - `NLG` - Dutch Guilder
// - `XCD` - East Caribbean Dollar
// - `DDM` - East German Mark
// - `ECS` - Ecuadorian Sucre
// - `ECV` - Ecuadorian Unit of Constant Value
// - `EGP` - Egyptian Pound
// - `GQE` - Equatorial Guinean Ekwele
// - `ERN` - Eritrean Nakfa
// - `EEK` - Estonian Kroon
// - `ETB` - Ethiopian Birr
// - `EUR` - Euro
// - `XBA` - European Composite Unit
// - `XEU` - European Currency Unit
// - `XBB` - European Monetary Unit
// - `XBC` - European Unit of Account (XBC)
// - `XBD` - European Unit of Account (XBD)
// - `FKP` - Falkland Islands Pound
// - `FJD` - Fijian Dollar
// - `FIM` - Finnish Markka
// - `FRF` - French Franc
// - `XFO` - French Gold Franc
// - `XFU` - French UIC-Franc
// - `GMD` - Gambian Dalasi
// - `GEK` - Georgian Kupon Larit
// - `GEL` - Georgian Lari
// - `DEM` - German Mark
// - `GHS` - Ghanaian Cedi
// - `GHC` - Ghanaian Cedi (1979–2007)
// - `GIP` - Gibraltar Pound
// - `XAU` - Gold
// - `GRD` - Greek Drachma
// - `GTQ` - Guatemalan Quetzal
// - `GWP` - Guinea-Bissau Peso
// - `GNF` - Guinean Franc
// - `GNS` - Guinean Syli
// - `GYD` - Guyanaese Dollar
// - `HTG` - Haitian Gourde
// - `HNL` - Honduran Lempira
// - `HKD` - Hong Kong Dollar
// - `HUF` - Hungarian Forint
// - `IMP` - IMP
// - `ISK` - Icelandic Króna
// - `ISJ` - Icelandic Króna (1918–1981)
// - `INR` - Indian Rupee
// - `IDR` - Indonesian Rupiah
// - `IRR` - Iranian Rial
// - `IQD` - Iraqi Dinar
// - `IEP` - Irish Pound
// - `ILS` - Israeli New Shekel
// - `ILP` - Israeli Pound
// - `ILR` - Israeli Shekel (1980–1985)
// - `ITL` - Italian Lira
// - `JMD` - Jamaican Dollar
// - `JPY` - Japanese Yen
// - `JOD` - Jordanian Dinar
// - `KZT` - Kazakhstani Tenge
// - `KES` - Kenyan Shilling
// - `KWD` - Kuwaiti Dinar
// - `KGS` - Kyrgystani Som
// - `LAK` - Laotian Kip
// - `LVL` - Latvian Lats
// - `LVR` - Latvian Ruble
// - `LBP` - Lebanese Pound
// - `LSL` - Lesotho Loti
// - `LRD` - Liberian Dollar
// - `LYD` - Libyan Dinar
// - `LTL` - Lithuanian Litas
// - `LTT` - Lithuanian Talonas
// - `LUL` - Luxembourg Financial Franc
// - `LUC` - Luxembourgian Convertible Franc
// - `LUF` - Luxembourgian Franc
// - `MOP` - Macanese Pataca
// - `MKD` - Macedonian Denar
// - `MKN` - Macedonian Denar (1992–1993)
// - `MGA` - Malagasy Ariary
// - `MGF` - Malagasy Franc
// - `MWK` - Malawian Kwacha
// - `MYR` - Malaysian Ringgit
// - `MVR` - Maldivian Rufiyaa
// - `MVP` - Maldivian Rupee (1947–1981)
// - `MLF` - Malian Franc
// - `MTL` - Maltese Lira
// - `MTP` - Maltese Pound
// - `MRU` - Mauritanian Ouguiya
// - `MRO` - Mauritanian Ouguiya (1973–2017)
// - `MUR` - Mauritian Rupee
// - `MXV` - Mexican Investment Unit
// - `MXN` - Mexican Peso
// - `MXP` - Mexican Silver Peso (1861–1992)
// - `MDC` - Moldovan Cupon
// - `MDL` - Moldovan Leu
// - `MCF` - Monegasque Franc
// - `MNT` - Mongolian Tugrik
// - `MAD` - Moroccan Dirham
// - `MAF` - Moroccan Franc
// - `MZE` - Mozambican Escudo
// - `MZN` - Mozambican Metical
// - `MZM` - Mozambican Metical (1980–2006)
// - `MMK` - Myanmar Kyat
// - `NAD` - Namibian Dollar
// - `NPR` - Nepalese Rupee
// - `ANG` - Netherlands Antillean Guilder
// - `TWD` - New Taiwan Dollar
// - `NZD` - New Zealand Dollar
// - `NIO` - Nicaraguan Córdoba
// - `NIC` - Nicaraguan Córdoba (1988–1991)
// - `NGN` - Nigerian Naira
// - `KPW` - North Korean Won
// - `NOK` - Norwegian Krone
// - `OMR` - Omani Rial
// - `PKR` - Pakistani Rupee
// - `XPD` - Palladium
// - `PAB` - Panamanian Balboa
// - `PGK` - Papua New Guinean Kina
// - `PYG` - Paraguayan Guarani
// - `PEI` - Peruvian Inti
// - `PEN` - Peruvian Sol
// - `PES` - Peruvian Sol (1863–1965)
// - `PHP` - Philippine Peso
// - `XPT` - Platinum
// - `PLN` - Polish Zloty
// - `PLZ` - Polish Zloty (1950–1995)
// - `PTE` - Portuguese Escudo
// - `GWE` - Portuguese Guinea Escudo
// - `QAR` - Qatari Rial
// - `XRE` - RINET Funds
// - `RHD` - Rhodesian Dollar
// - `RON` - Romanian Leu
// - `ROL` - Romanian Leu (1952–2006)
// - `RUB` - Russian Ruble
// - `RUR` - Russian Ruble (1991–1998)
// - `RWF` - Rwandan Franc
// - `SVC` - Salvadoran Colón
// - `WST` - Samoan Tala
// - `SAR` - Saudi Riyal
// - `RSD` - Serbian Dinar
// - `CSD` - Serbian Dinar (2002–2006)
// - `SCR` - Seychellois Rupee
// - `SLL` - Sierra Leonean Leone
// - `XAG` - Silver
// - `SGD` - Singapore Dollar
// - `SKK` - Slovak Koruna
// - `SIT` - Slovenian Tolar
// - `SBD` - Solomon Islands Dollar
// - `SOS` - Somali Shilling
// - `ZAR` - South African Rand
// - `ZAL` - South African Rand (financial)
// - `KRH` - South Korean Hwan (1953–1962)
// - `KRW` - South Korean Won
// - `KRO` - South Korean Won (1945–1953)
// - `SSP` - South Sudanese Pound
// - `SUR` - Soviet Rouble
// - `ESP` - Spanish Peseta
// - `ESA` - Spanish Peseta (A account)
// - `ESB` - Spanish Peseta (convertible account)
// - `XDR` - Special Drawing Rights
// - `LKR` - Sri Lankan Rupee
// - `SHP` - St. Helena Pound
// - `XSU` - Sucre
// - `SDD` - Sudanese Dinar (1992–2007)
// - `SDG` - Sudanese Pound
// - `SDP` - Sudanese Pound (1957–1998)
// - `SRD` - Surinamese Dollar
// - `SRG` - Surinamese Guilder
// - `SZL` - Swazi Lilangeni
// - `SEK` - Swedish Krona
// - `CHF` - Swiss Franc
// - `SYP` - Syrian Pound
// - `STN` - São Tomé & Príncipe Dobra
// - `STD` - São Tomé & Príncipe Dobra (1977–2017)
// - `TVD` - TVD
// - `TJR` - Tajikistani Ruble
// - `TJS` - Tajikistani Somoni
// - `TZS` - Tanzanian Shilling
// - `XTS` - Testing Currency Code
// - `THB` - Thai Baht
// - `XXX` - The codes assigned for transactions where no currency is involved
// - `TPE` - Timorese Escudo
// - `TOP` - Tongan Paʻanga
// - `TTD` - Trinidad & Tobago Dollar
// - `TND` - Tunisian Dinar
// - `TRY` - Turkish Lira
// - `TRL` - Turkish Lira (1922–2005)
// - `TMT` - Turkmenistani Manat
// - `TMM` - Turkmenistani Manat (1993–2009)
// - `USD` - US Dollar
// - `USN` - US Dollar (Next day)
// - `USS` - US Dollar (Same day)
// - `UGX` - Ugandan Shilling
// - `UGS` - Ugandan Shilling (1966–1987)
// - `UAH` - Ukrainian Hryvnia
// - `UAK` - Ukrainian Karbovanets
// - `AED` - United Arab Emirates Dirham
// - `UYW` - Uruguayan Nominal Wage Index Unit
// - `UYU` - Uruguayan Peso
// - `UYP` - Uruguayan Peso (1975–1993)
// - `UYI` - Uruguayan Peso (Indexed Units)
// - `UZS` - Uzbekistani Som
// - `VUV` - Vanuatu Vatu
// - `VES` - Venezuelan Bolívar
// - `VEB` - Venezuelan Bolívar (1871–2008)
// - `VEF` - Venezuelan Bolívar (2008–2018)
// - `VND` - Vietnamese Dong
// - `VNN` - Vietnamese Dong (1978–1985)
// - `CHE` - WIR Euro
// - `CHW` - WIR Franc
// - `XOF` - West African CFA Franc
// - `YDD` - Yemeni Dinar
// - `YER` - Yemeni Rial
// - `YUN` - Yugoslavian Convertible Dinar (1990–1992)
// - `YUD` - Yugoslavian Hard Dinar (1966–1990)
// - `YUM` - Yugoslavian New Dinar (1994–2002)
// - `YUR` - Yugoslavian Reformed Dinar (1992–1993)
// - `ZWN` - ZWN
// - `ZRN` - Zairean New Zaire (1993–1998)
// - `ZRZ` - Zairean Zaire (1971–1993)
// - `ZMW` - Zambian Kwacha
// - `ZMK` - Zambian Kwacha (1968–2012)
// - `ZWD` - Zimbabwean Dollar (1980–2008)
// - `ZWR` - Zimbabwean Dollar (2008)
// - `ZWL` - Zimbabwean Dollar (2009)
type PayCurrencyEnum uint

const (
	PayCurrencyEnumXua PayCurrencyEnum = iota + 1
	PayCurrencyEnumAfn
	PayCurrencyEnumAfa
	PayCurrencyEnumAll
	PayCurrencyEnumAlk
	PayCurrencyEnumDzd
	PayCurrencyEnumAdp
	PayCurrencyEnumAoa
	PayCurrencyEnumAok
	PayCurrencyEnumAon
	PayCurrencyEnumAor
	PayCurrencyEnumAra
	PayCurrencyEnumArs
	PayCurrencyEnumArm
	PayCurrencyEnumArp
	PayCurrencyEnumArl
	PayCurrencyEnumAmd
	PayCurrencyEnumAwg
	PayCurrencyEnumAud
	PayCurrencyEnumAts
	PayCurrencyEnumAzn
	PayCurrencyEnumAzm
	PayCurrencyEnumBsd
	PayCurrencyEnumBhd
	PayCurrencyEnumBdt
	PayCurrencyEnumBbd
	PayCurrencyEnumByn
	PayCurrencyEnumByb
	PayCurrencyEnumByr
	PayCurrencyEnumBef
	PayCurrencyEnumBec
	PayCurrencyEnumBel
	PayCurrencyEnumBzd
	PayCurrencyEnumBmd
	PayCurrencyEnumBtn
	PayCurrencyEnumBob
	PayCurrencyEnumBol
	PayCurrencyEnumBov
	PayCurrencyEnumBop
	PayCurrencyEnumBam
	PayCurrencyEnumBad
	PayCurrencyEnumBan
	PayCurrencyEnumBwp
	PayCurrencyEnumBrc
	PayCurrencyEnumBrz
	PayCurrencyEnumBre
	PayCurrencyEnumBrr
	PayCurrencyEnumBrn
	PayCurrencyEnumBrb
	PayCurrencyEnumBrl
	PayCurrencyEnumGbp
	PayCurrencyEnumBnd
	PayCurrencyEnumBgl
	PayCurrencyEnumBgn
	PayCurrencyEnumBgo
	PayCurrencyEnumBgm
	PayCurrencyEnumBuk
	PayCurrencyEnumBif
	PayCurrencyEnumXpf
	PayCurrencyEnumKhr
	PayCurrencyEnumCad
	PayCurrencyEnumCve
	PayCurrencyEnumKyd
	PayCurrencyEnumXaf
	PayCurrencyEnumCle
	PayCurrencyEnumClp
	PayCurrencyEnumClf
	PayCurrencyEnumCnx
	PayCurrencyEnumCny
	PayCurrencyEnumCnh
	PayCurrencyEnumCop
	PayCurrencyEnumCou
	PayCurrencyEnumKmf
	PayCurrencyEnumCdf
	PayCurrencyEnumCrc
	PayCurrencyEnumHrd
	PayCurrencyEnumHrk
	PayCurrencyEnumCuc
	PayCurrencyEnumCup
	PayCurrencyEnumCyp
	PayCurrencyEnumCzk
	PayCurrencyEnumCsk
	PayCurrencyEnumDkk
	PayCurrencyEnumDjf
	PayCurrencyEnumDop
	PayCurrencyEnumNlg
	PayCurrencyEnumXcd
	PayCurrencyEnumDdm
	PayCurrencyEnumEcs
	PayCurrencyEnumEcv
	PayCurrencyEnumEgp
	PayCurrencyEnumGqe
	PayCurrencyEnumErn
	PayCurrencyEnumEek
	PayCurrencyEnumEtb
	PayCurrencyEnumEur
	PayCurrencyEnumXba
	PayCurrencyEnumXeu
	PayCurrencyEnumXbb
	PayCurrencyEnumXbc
	PayCurrencyEnumXbd
	PayCurrencyEnumFkp
	PayCurrencyEnumFjd
	PayCurrencyEnumFim
	PayCurrencyEnumFrf
	PayCurrencyEnumXfo
	PayCurrencyEnumXfu
	PayCurrencyEnumGmd
	PayCurrencyEnumGek
	PayCurrencyEnumGel
	PayCurrencyEnumDem
	PayCurrencyEnumGhs
	PayCurrencyEnumGhc
	PayCurrencyEnumGip
	PayCurrencyEnumXau
	PayCurrencyEnumGrd
	PayCurrencyEnumGtq
	PayCurrencyEnumGwp
	PayCurrencyEnumGnf
	PayCurrencyEnumGns
	PayCurrencyEnumGyd
	PayCurrencyEnumHtg
	PayCurrencyEnumHnl
	PayCurrencyEnumHkd
	PayCurrencyEnumHuf
	PayCurrencyEnumImp
	PayCurrencyEnumIsk
	PayCurrencyEnumIsj
	PayCurrencyEnumInr
	PayCurrencyEnumIdr
	PayCurrencyEnumIrr
	PayCurrencyEnumIqd
	PayCurrencyEnumIep
	PayCurrencyEnumIls
	PayCurrencyEnumIlp
	PayCurrencyEnumIlr
	PayCurrencyEnumItl
	PayCurrencyEnumJmd
	PayCurrencyEnumJpy
	PayCurrencyEnumJod
	PayCurrencyEnumKzt
	PayCurrencyEnumKes
	PayCurrencyEnumKwd
	PayCurrencyEnumKgs
	PayCurrencyEnumLak
	PayCurrencyEnumLvl
	PayCurrencyEnumLvr
	PayCurrencyEnumLbp
	PayCurrencyEnumLsl
	PayCurrencyEnumLrd
	PayCurrencyEnumLyd
	PayCurrencyEnumLtl
	PayCurrencyEnumLtt
	PayCurrencyEnumLul
	PayCurrencyEnumLuc
	PayCurrencyEnumLuf
	PayCurrencyEnumMop
	PayCurrencyEnumMkd
	PayCurrencyEnumMkn
	PayCurrencyEnumMga
	PayCurrencyEnumMgf
	PayCurrencyEnumMwk
	PayCurrencyEnumMyr
	PayCurrencyEnumMvr
	PayCurrencyEnumMvp
	PayCurrencyEnumMlf
	PayCurrencyEnumMtl
	PayCurrencyEnumMtp
	PayCurrencyEnumMru
	PayCurrencyEnumMro
	PayCurrencyEnumMur
	PayCurrencyEnumMxv
	PayCurrencyEnumMxn
	PayCurrencyEnumMxp
	PayCurrencyEnumMdc
	PayCurrencyEnumMdl
	PayCurrencyEnumMcf
	PayCurrencyEnumMnt
	PayCurrencyEnumMad
	PayCurrencyEnumMaf
	PayCurrencyEnumMze
	PayCurrencyEnumMzn
	PayCurrencyEnumMzm
	PayCurrencyEnumMmk
	PayCurrencyEnumNad
	PayCurrencyEnumNpr
	PayCurrencyEnumAng
	PayCurrencyEnumTwd
	PayCurrencyEnumNzd
	PayCurrencyEnumNio
	PayCurrencyEnumNic
	PayCurrencyEnumNgn
	PayCurrencyEnumKpw
	PayCurrencyEnumNok
	PayCurrencyEnumOmr
	PayCurrencyEnumPkr
	PayCurrencyEnumXpd
	PayCurrencyEnumPab
	PayCurrencyEnumPgk
	PayCurrencyEnumPyg
	PayCurrencyEnumPei
	PayCurrencyEnumPen
	PayCurrencyEnumPes
	PayCurrencyEnumPhp
	PayCurrencyEnumXpt
	PayCurrencyEnumPln
	PayCurrencyEnumPlz
	PayCurrencyEnumPte
	PayCurrencyEnumGwe
	PayCurrencyEnumQar
	PayCurrencyEnumXre
	PayCurrencyEnumRhd
	PayCurrencyEnumRon
	PayCurrencyEnumRol
	PayCurrencyEnumRub
	PayCurrencyEnumRur
	PayCurrencyEnumRwf
	PayCurrencyEnumSvc
	PayCurrencyEnumWst
	PayCurrencyEnumSar
	PayCurrencyEnumRsd
	PayCurrencyEnumCsd
	PayCurrencyEnumScr
	PayCurrencyEnumSll
	PayCurrencyEnumXag
	PayCurrencyEnumSgd
	PayCurrencyEnumSkk
	PayCurrencyEnumSit
	PayCurrencyEnumSbd
	PayCurrencyEnumSos
	PayCurrencyEnumZar
	PayCurrencyEnumZal
	PayCurrencyEnumKrh
	PayCurrencyEnumKrw
	PayCurrencyEnumKro
	PayCurrencyEnumSsp
	PayCurrencyEnumSur
	PayCurrencyEnumEsp
	PayCurrencyEnumEsa
	PayCurrencyEnumEsb
	PayCurrencyEnumXdr
	PayCurrencyEnumLkr
	PayCurrencyEnumShp
	PayCurrencyEnumXsu
	PayCurrencyEnumSdd
	PayCurrencyEnumSdg
	PayCurrencyEnumSdp
	PayCurrencyEnumSrd
	PayCurrencyEnumSrg
	PayCurrencyEnumSzl
	PayCurrencyEnumSek
	PayCurrencyEnumChf
	PayCurrencyEnumSyp
	PayCurrencyEnumStn
	PayCurrencyEnumStd
	PayCurrencyEnumTvd
	PayCurrencyEnumTjr
	PayCurrencyEnumTjs
	PayCurrencyEnumTzs
	PayCurrencyEnumXts
	PayCurrencyEnumThb
	PayCurrencyEnumXxx
	PayCurrencyEnumTpe
	PayCurrencyEnumTop
	PayCurrencyEnumTtd
	PayCurrencyEnumTnd
	PayCurrencyEnumTry
	PayCurrencyEnumTrl
	PayCurrencyEnumTmt
	PayCurrencyEnumTmm
	PayCurrencyEnumUsd
	PayCurrencyEnumUsn
	PayCurrencyEnumUss
	PayCurrencyEnumUgx
	PayCurrencyEnumUgs
	PayCurrencyEnumUah
	PayCurrencyEnumUak
	PayCurrencyEnumAed
	PayCurrencyEnumUyw
	PayCurrencyEnumUyu
	PayCurrencyEnumUyp
	PayCurrencyEnumUyi
	PayCurrencyEnumUzs
	PayCurrencyEnumVuv
	PayCurrencyEnumVes
	PayCurrencyEnumVeb
	PayCurrencyEnumVef
	PayCurrencyEnumVnd
	PayCurrencyEnumVnn
	PayCurrencyEnumChe
	PayCurrencyEnumChw
	PayCurrencyEnumXof
	PayCurrencyEnumYdd
	PayCurrencyEnumYer
	PayCurrencyEnumYun
	PayCurrencyEnumYud
	PayCurrencyEnumYum
	PayCurrencyEnumYur
	PayCurrencyEnumZwn
	PayCurrencyEnumZrn
	PayCurrencyEnumZrz
	PayCurrencyEnumZmw
	PayCurrencyEnumZmk
	PayCurrencyEnumZwd
	PayCurrencyEnumZwr
	PayCurrencyEnumZwl
)

func (p PayCurrencyEnum) String() string {
	switch p {
	default:
		return strconv.Itoa(int(p))
	case PayCurrencyEnumXua:
		return "XUA"
	case PayCurrencyEnumAfn:
		return "AFN"
	case PayCurrencyEnumAfa:
		return "AFA"
	case PayCurrencyEnumAll:
		return "ALL"
	case PayCurrencyEnumAlk:
		return "ALK"
	case PayCurrencyEnumDzd:
		return "DZD"
	case PayCurrencyEnumAdp:
		return "ADP"
	case PayCurrencyEnumAoa:
		return "AOA"
	case PayCurrencyEnumAok:
		return "AOK"
	case PayCurrencyEnumAon:
		return "AON"
	case PayCurrencyEnumAor:
		return "AOR"
	case PayCurrencyEnumAra:
		return "ARA"
	case PayCurrencyEnumArs:
		return "ARS"
	case PayCurrencyEnumArm:
		return "ARM"
	case PayCurrencyEnumArp:
		return "ARP"
	case PayCurrencyEnumArl:
		return "ARL"
	case PayCurrencyEnumAmd:
		return "AMD"
	case PayCurrencyEnumAwg:
		return "AWG"
	case PayCurrencyEnumAud:
		return "AUD"
	case PayCurrencyEnumAts:
		return "ATS"
	case PayCurrencyEnumAzn:
		return "AZN"
	case PayCurrencyEnumAzm:
		return "AZM"
	case PayCurrencyEnumBsd:
		return "BSD"
	case PayCurrencyEnumBhd:
		return "BHD"
	case PayCurrencyEnumBdt:
		return "BDT"
	case PayCurrencyEnumBbd:
		return "BBD"
	case PayCurrencyEnumByn:
		return "BYN"
	case PayCurrencyEnumByb:
		return "BYB"
	case PayCurrencyEnumByr:
		return "BYR"
	case PayCurrencyEnumBef:
		return "BEF"
	case PayCurrencyEnumBec:
		return "BEC"
	case PayCurrencyEnumBel:
		return "BEL"
	case PayCurrencyEnumBzd:
		return "BZD"
	case PayCurrencyEnumBmd:
		return "BMD"
	case PayCurrencyEnumBtn:
		return "BTN"
	case PayCurrencyEnumBob:
		return "BOB"
	case PayCurrencyEnumBol:
		return "BOL"
	case PayCurrencyEnumBov:
		return "BOV"
	case PayCurrencyEnumBop:
		return "BOP"
	case PayCurrencyEnumBam:
		return "BAM"
	case PayCurrencyEnumBad:
		return "BAD"
	case PayCurrencyEnumBan:
		return "BAN"
	case PayCurrencyEnumBwp:
		return "BWP"
	case PayCurrencyEnumBrc:
		return "BRC"
	case PayCurrencyEnumBrz:
		return "BRZ"
	case PayCurrencyEnumBre:
		return "BRE"
	case PayCurrencyEnumBrr:
		return "BRR"
	case PayCurrencyEnumBrn:
		return "BRN"
	case PayCurrencyEnumBrb:
		return "BRB"
	case PayCurrencyEnumBrl:
		return "BRL"
	case PayCurrencyEnumGbp:
		return "GBP"
	case PayCurrencyEnumBnd:
		return "BND"
	case PayCurrencyEnumBgl:
		return "BGL"
	case PayCurrencyEnumBgn:
		return "BGN"
	case PayCurrencyEnumBgo:
		return "BGO"
	case PayCurrencyEnumBgm:
		return "BGM"
	case PayCurrencyEnumBuk:
		return "BUK"
	case PayCurrencyEnumBif:
		return "BIF"
	case PayCurrencyEnumXpf:
		return "XPF"
	case PayCurrencyEnumKhr:
		return "KHR"
	case PayCurrencyEnumCad:
		return "CAD"
	case PayCurrencyEnumCve:
		return "CVE"
	case PayCurrencyEnumKyd:
		return "KYD"
	case PayCurrencyEnumXaf:
		return "XAF"
	case PayCurrencyEnumCle:
		return "CLE"
	case PayCurrencyEnumClp:
		return "CLP"
	case PayCurrencyEnumClf:
		return "CLF"
	case PayCurrencyEnumCnx:
		return "CNX"
	case PayCurrencyEnumCny:
		return "CNY"
	case PayCurrencyEnumCnh:
		return "CNH"
	case PayCurrencyEnumCop:
		return "COP"
	case PayCurrencyEnumCou:
		return "COU"
	case PayCurrencyEnumKmf:
		return "KMF"
	case PayCurrencyEnumCdf:
		return "CDF"
	case PayCurrencyEnumCrc:
		return "CRC"
	case PayCurrencyEnumHrd:
		return "HRD"
	case PayCurrencyEnumHrk:
		return "HRK"
	case PayCurrencyEnumCuc:
		return "CUC"
	case PayCurrencyEnumCup:
		return "CUP"
	case PayCurrencyEnumCyp:
		return "CYP"
	case PayCurrencyEnumCzk:
		return "CZK"
	case PayCurrencyEnumCsk:
		return "CSK"
	case PayCurrencyEnumDkk:
		return "DKK"
	case PayCurrencyEnumDjf:
		return "DJF"
	case PayCurrencyEnumDop:
		return "DOP"
	case PayCurrencyEnumNlg:
		return "NLG"
	case PayCurrencyEnumXcd:
		return "XCD"
	case PayCurrencyEnumDdm:
		return "DDM"
	case PayCurrencyEnumEcs:
		return "ECS"
	case PayCurrencyEnumEcv:
		return "ECV"
	case PayCurrencyEnumEgp:
		return "EGP"
	case PayCurrencyEnumGqe:
		return "GQE"
	case PayCurrencyEnumErn:
		return "ERN"
	case PayCurrencyEnumEek:
		return "EEK"
	case PayCurrencyEnumEtb:
		return "ETB"
	case PayCurrencyEnumEur:
		return "EUR"
	case PayCurrencyEnumXba:
		return "XBA"
	case PayCurrencyEnumXeu:
		return "XEU"
	case PayCurrencyEnumXbb:
		return "XBB"
	case PayCurrencyEnumXbc:
		return "XBC"
	case PayCurrencyEnumXbd:
		return "XBD"
	case PayCurrencyEnumFkp:
		return "FKP"
	case PayCurrencyEnumFjd:
		return "FJD"
	case PayCurrencyEnumFim:
		return "FIM"
	case PayCurrencyEnumFrf:
		return "FRF"
	case PayCurrencyEnumXfo:
		return "XFO"
	case PayCurrencyEnumXfu:
		return "XFU"
	case PayCurrencyEnumGmd:
		return "GMD"
	case PayCurrencyEnumGek:
		return "GEK"
	case PayCurrencyEnumGel:
		return "GEL"
	case PayCurrencyEnumDem:
		return "DEM"
	case PayCurrencyEnumGhs:
		return "GHS"
	case PayCurrencyEnumGhc:
		return "GHC"
	case PayCurrencyEnumGip:
		return "GIP"
	case PayCurrencyEnumXau:
		return "XAU"
	case PayCurrencyEnumGrd:
		return "GRD"
	case PayCurrencyEnumGtq:
		return "GTQ"
	case PayCurrencyEnumGwp:
		return "GWP"
	case PayCurrencyEnumGnf:
		return "GNF"
	case PayCurrencyEnumGns:
		return "GNS"
	case PayCurrencyEnumGyd:
		return "GYD"
	case PayCurrencyEnumHtg:
		return "HTG"
	case PayCurrencyEnumHnl:
		return "HNL"
	case PayCurrencyEnumHkd:
		return "HKD"
	case PayCurrencyEnumHuf:
		return "HUF"
	case PayCurrencyEnumImp:
		return "IMP"
	case PayCurrencyEnumIsk:
		return "ISK"
	case PayCurrencyEnumIsj:
		return "ISJ"
	case PayCurrencyEnumInr:
		return "INR"
	case PayCurrencyEnumIdr:
		return "IDR"
	case PayCurrencyEnumIrr:
		return "IRR"
	case PayCurrencyEnumIqd:
		return "IQD"
	case PayCurrencyEnumIep:
		return "IEP"
	case PayCurrencyEnumIls:
		return "ILS"
	case PayCurrencyEnumIlp:
		return "ILP"
	case PayCurrencyEnumIlr:
		return "ILR"
	case PayCurrencyEnumItl:
		return "ITL"
	case PayCurrencyEnumJmd:
		return "JMD"
	case PayCurrencyEnumJpy:
		return "JPY"
	case PayCurrencyEnumJod:
		return "JOD"
	case PayCurrencyEnumKzt:
		return "KZT"
	case PayCurrencyEnumKes:
		return "KES"
	case PayCurrencyEnumKwd:
		return "KWD"
	case PayCurrencyEnumKgs:
		return "KGS"
	case PayCurrencyEnumLak:
		return "LAK"
	case PayCurrencyEnumLvl:
		return "LVL"
	case PayCurrencyEnumLvr:
		return "LVR"
	case PayCurrencyEnumLbp:
		return "LBP"
	case PayCurrencyEnumLsl:
		return "LSL"
	case PayCurrencyEnumLrd:
		return "LRD"
	case PayCurrencyEnumLyd:
		return "LYD"
	case PayCurrencyEnumLtl:
		return "LTL"
	case PayCurrencyEnumLtt:
		return "LTT"
	case PayCurrencyEnumLul:
		return "LUL"
	case PayCurrencyEnumLuc:
		return "LUC"
	case PayCurrencyEnumLuf:
		return "LUF"
	case PayCurrencyEnumMop:
		return "MOP"
	case PayCurrencyEnumMkd:
		return "MKD"
	case PayCurrencyEnumMkn:
		return "MKN"
	case PayCurrencyEnumMga:
		return "MGA"
	case PayCurrencyEnumMgf:
		return "MGF"
	case PayCurrencyEnumMwk:
		return "MWK"
	case PayCurrencyEnumMyr:
		return "MYR"
	case PayCurrencyEnumMvr:
		return "MVR"
	case PayCurrencyEnumMvp:
		return "MVP"
	case PayCurrencyEnumMlf:
		return "MLF"
	case PayCurrencyEnumMtl:
		return "MTL"
	case PayCurrencyEnumMtp:
		return "MTP"
	case PayCurrencyEnumMru:
		return "MRU"
	case PayCurrencyEnumMro:
		return "MRO"
	case PayCurrencyEnumMur:
		return "MUR"
	case PayCurrencyEnumMxv:
		return "MXV"
	case PayCurrencyEnumMxn:
		return "MXN"
	case PayCurrencyEnumMxp:
		return "MXP"
	case PayCurrencyEnumMdc:
		return "MDC"
	case PayCurrencyEnumMdl:
		return "MDL"
	case PayCurrencyEnumMcf:
		return "MCF"
	case PayCurrencyEnumMnt:
		return "MNT"
	case PayCurrencyEnumMad:
		return "MAD"
	case PayCurrencyEnumMaf:
		return "MAF"
	case PayCurrencyEnumMze:
		return "MZE"
	case PayCurrencyEnumMzn:
		return "MZN"
	case PayCurrencyEnumMzm:
		return "MZM"
	case PayCurrencyEnumMmk:
		return "MMK"
	case PayCurrencyEnumNad:
		return "NAD"
	case PayCurrencyEnumNpr:
		return "NPR"
	case PayCurrencyEnumAng:
		return "ANG"
	case PayCurrencyEnumTwd:
		return "TWD"
	case PayCurrencyEnumNzd:
		return "NZD"
	case PayCurrencyEnumNio:
		return "NIO"
	case PayCurrencyEnumNic:
		return "NIC"
	case PayCurrencyEnumNgn:
		return "NGN"
	case PayCurrencyEnumKpw:
		return "KPW"
	case PayCurrencyEnumNok:
		return "NOK"
	case PayCurrencyEnumOmr:
		return "OMR"
	case PayCurrencyEnumPkr:
		return "PKR"
	case PayCurrencyEnumXpd:
		return "XPD"
	case PayCurrencyEnumPab:
		return "PAB"
	case PayCurrencyEnumPgk:
		return "PGK"
	case PayCurrencyEnumPyg:
		return "PYG"
	case PayCurrencyEnumPei:
		return "PEI"
	case PayCurrencyEnumPen:
		return "PEN"
	case PayCurrencyEnumPes:
		return "PES"
	case PayCurrencyEnumPhp:
		return "PHP"
	case PayCurrencyEnumXpt:
		return "XPT"
	case PayCurrencyEnumPln:
		return "PLN"
	case PayCurrencyEnumPlz:
		return "PLZ"
	case PayCurrencyEnumPte:
		return "PTE"
	case PayCurrencyEnumGwe:
		return "GWE"
	case PayCurrencyEnumQar:
		return "QAR"
	case PayCurrencyEnumXre:
		return "XRE"
	case PayCurrencyEnumRhd:
		return "RHD"
	case PayCurrencyEnumRon:
		return "RON"
	case PayCurrencyEnumRol:
		return "ROL"
	case PayCurrencyEnumRub:
		return "RUB"
	case PayCurrencyEnumRur:
		return "RUR"
	case PayCurrencyEnumRwf:
		return "RWF"
	case PayCurrencyEnumSvc:
		return "SVC"
	case PayCurrencyEnumWst:
		return "WST"
	case PayCurrencyEnumSar:
		return "SAR"
	case PayCurrencyEnumRsd:
		return "RSD"
	case PayCurrencyEnumCsd:
		return "CSD"
	case PayCurrencyEnumScr:
		return "SCR"
	case PayCurrencyEnumSll:
		return "SLL"
	case PayCurrencyEnumXag:
		return "XAG"
	case PayCurrencyEnumSgd:
		return "SGD"
	case PayCurrencyEnumSkk:
		return "SKK"
	case PayCurrencyEnumSit:
		return "SIT"
	case PayCurrencyEnumSbd:
		return "SBD"
	case PayCurrencyEnumSos:
		return "SOS"
	case PayCurrencyEnumZar:
		return "ZAR"
	case PayCurrencyEnumZal:
		return "ZAL"
	case PayCurrencyEnumKrh:
		return "KRH"
	case PayCurrencyEnumKrw:
		return "KRW"
	case PayCurrencyEnumKro:
		return "KRO"
	case PayCurrencyEnumSsp:
		return "SSP"
	case PayCurrencyEnumSur:
		return "SUR"
	case PayCurrencyEnumEsp:
		return "ESP"
	case PayCurrencyEnumEsa:
		return "ESA"
	case PayCurrencyEnumEsb:
		return "ESB"
	case PayCurrencyEnumXdr:
		return "XDR"
	case PayCurrencyEnumLkr:
		return "LKR"
	case PayCurrencyEnumShp:
		return "SHP"
	case PayCurrencyEnumXsu:
		return "XSU"
	case PayCurrencyEnumSdd:
		return "SDD"
	case PayCurrencyEnumSdg:
		return "SDG"
	case PayCurrencyEnumSdp:
		return "SDP"
	case PayCurrencyEnumSrd:
		return "SRD"
	case PayCurrencyEnumSrg:
		return "SRG"
	case PayCurrencyEnumSzl:
		return "SZL"
	case PayCurrencyEnumSek:
		return "SEK"
	case PayCurrencyEnumChf:
		return "CHF"
	case PayCurrencyEnumSyp:
		return "SYP"
	case PayCurrencyEnumStn:
		return "STN"
	case PayCurrencyEnumStd:
		return "STD"
	case PayCurrencyEnumTvd:
		return "TVD"
	case PayCurrencyEnumTjr:
		return "TJR"
	case PayCurrencyEnumTjs:
		return "TJS"
	case PayCurrencyEnumTzs:
		return "TZS"
	case PayCurrencyEnumXts:
		return "XTS"
	case PayCurrencyEnumThb:
		return "THB"
	case PayCurrencyEnumXxx:
		return "XXX"
	case PayCurrencyEnumTpe:
		return "TPE"
	case PayCurrencyEnumTop:
		return "TOP"
	case PayCurrencyEnumTtd:
		return "TTD"
	case PayCurrencyEnumTnd:
		return "TND"
	case PayCurrencyEnumTry:
		return "TRY"
	case PayCurrencyEnumTrl:
		return "TRL"
	case PayCurrencyEnumTmt:
		return "TMT"
	case PayCurrencyEnumTmm:
		return "TMM"
	case PayCurrencyEnumUsd:
		return "USD"
	case PayCurrencyEnumUsn:
		return "USN"
	case PayCurrencyEnumUss:
		return "USS"
	case PayCurrencyEnumUgx:
		return "UGX"
	case PayCurrencyEnumUgs:
		return "UGS"
	case PayCurrencyEnumUah:
		return "UAH"
	case PayCurrencyEnumUak:
		return "UAK"
	case PayCurrencyEnumAed:
		return "AED"
	case PayCurrencyEnumUyw:
		return "UYW"
	case PayCurrencyEnumUyu:
		return "UYU"
	case PayCurrencyEnumUyp:
		return "UYP"
	case PayCurrencyEnumUyi:
		return "UYI"
	case PayCurrencyEnumUzs:
		return "UZS"
	case PayCurrencyEnumVuv:
		return "VUV"
	case PayCurrencyEnumVes:
		return "VES"
	case PayCurrencyEnumVeb:
		return "VEB"
	case PayCurrencyEnumVef:
		return "VEF"
	case PayCurrencyEnumVnd:
		return "VND"
	case PayCurrencyEnumVnn:
		return "VNN"
	case PayCurrencyEnumChe:
		return "CHE"
	case PayCurrencyEnumChw:
		return "CHW"
	case PayCurrencyEnumXof:
		return "XOF"
	case PayCurrencyEnumYdd:
		return "YDD"
	case PayCurrencyEnumYer:
		return "YER"
	case PayCurrencyEnumYun:
		return "YUN"
	case PayCurrencyEnumYud:
		return "YUD"
	case PayCurrencyEnumYum:
		return "YUM"
	case PayCurrencyEnumYur:
		return "YUR"
	case PayCurrencyEnumZwn:
		return "ZWN"
	case PayCurrencyEnumZrn:
		return "ZRN"
	case PayCurrencyEnumZrz:
		return "ZRZ"
	case PayCurrencyEnumZmw:
		return "ZMW"
	case PayCurrencyEnumZmk:
		return "ZMK"
	case PayCurrencyEnumZwd:
		return "ZWD"
	case PayCurrencyEnumZwr:
		return "ZWR"
	case PayCurrencyEnumZwl:
		return "ZWL"
	}
}

func (p PayCurrencyEnum) MarshalJSON() ([]byte, error) {
	return []byte(fmt.Sprintf("%q", p.String())), nil
}

func (p *PayCurrencyEnum) UnmarshalJSON(data []byte) error {
	var raw string
	if err := json.Unmarshal(data, &raw); err != nil {
		return err
	}
	switch raw {
	case "XUA":
		value := PayCurrencyEnumXua
		*p = value
	case "AFN":
		value := PayCurrencyEnumAfn
		*p = value
	case "AFA":
		value := PayCurrencyEnumAfa
		*p = value
	case "ALL":
		value := PayCurrencyEnumAll
		*p = value
	case "ALK":
		value := PayCurrencyEnumAlk
		*p = value
	case "DZD":
		value := PayCurrencyEnumDzd
		*p = value
	case "ADP":
		value := PayCurrencyEnumAdp
		*p = value
	case "AOA":
		value := PayCurrencyEnumAoa
		*p = value
	case "AOK":
		value := PayCurrencyEnumAok
		*p = value
	case "AON":
		value := PayCurrencyEnumAon
		*p = value
	case "AOR":
		value := PayCurrencyEnumAor
		*p = value
	case "ARA":
		value := PayCurrencyEnumAra
		*p = value
	case "ARS":
		value := PayCurrencyEnumArs
		*p = value
	case "ARM":
		value := PayCurrencyEnumArm
		*p = value
	case "ARP":
		value := PayCurrencyEnumArp
		*p = value
	case "ARL":
		value := PayCurrencyEnumArl
		*p = value
	case "AMD":
		value := PayCurrencyEnumAmd
		*p = value
	case "AWG":
		value := PayCurrencyEnumAwg
		*p = value
	case "AUD":
		value := PayCurrencyEnumAud
		*p = value
	case "ATS":
		value := PayCurrencyEnumAts
		*p = value
	case "AZN":
		value := PayCurrencyEnumAzn
		*p = value
	case "AZM":
		value := PayCurrencyEnumAzm
		*p = value
	case "BSD":
		value := PayCurrencyEnumBsd
		*p = value
	case "BHD":
		value := PayCurrencyEnumBhd
		*p = value
	case "BDT":
		value := PayCurrencyEnumBdt
		*p = value
	case "BBD":
		value := PayCurrencyEnumBbd
		*p = value
	case "BYN":
		value := PayCurrencyEnumByn
		*p = value
	case "BYB":
		value := PayCurrencyEnumByb
		*p = value
	case "BYR":
		value := PayCurrencyEnumByr
		*p = value
	case "BEF":
		value := PayCurrencyEnumBef
		*p = value
	case "BEC":
		value := PayCurrencyEnumBec
		*p = value
	case "BEL":
		value := PayCurrencyEnumBel
		*p = value
	case "BZD":
		value := PayCurrencyEnumBzd
		*p = value
	case "BMD":
		value := PayCurrencyEnumBmd
		*p = value
	case "BTN":
		value := PayCurrencyEnumBtn
		*p = value
	case "BOB":
		value := PayCurrencyEnumBob
		*p = value
	case "BOL":
		value := PayCurrencyEnumBol
		*p = value
	case "BOV":
		value := PayCurrencyEnumBov
		*p = value
	case "BOP":
		value := PayCurrencyEnumBop
		*p = value
	case "BAM":
		value := PayCurrencyEnumBam
		*p = value
	case "BAD":
		value := PayCurrencyEnumBad
		*p = value
	case "BAN":
		value := PayCurrencyEnumBan
		*p = value
	case "BWP":
		value := PayCurrencyEnumBwp
		*p = value
	case "BRC":
		value := PayCurrencyEnumBrc
		*p = value
	case "BRZ":
		value := PayCurrencyEnumBrz
		*p = value
	case "BRE":
		value := PayCurrencyEnumBre
		*p = value
	case "BRR":
		value := PayCurrencyEnumBrr
		*p = value
	case "BRN":
		value := PayCurrencyEnumBrn
		*p = value
	case "BRB":
		value := PayCurrencyEnumBrb
		*p = value
	case "BRL":
		value := PayCurrencyEnumBrl
		*p = value
	case "GBP":
		value := PayCurrencyEnumGbp
		*p = value
	case "BND":
		value := PayCurrencyEnumBnd
		*p = value
	case "BGL":
		value := PayCurrencyEnumBgl
		*p = value
	case "BGN":
		value := PayCurrencyEnumBgn
		*p = value
	case "BGO":
		value := PayCurrencyEnumBgo
		*p = value
	case "BGM":
		value := PayCurrencyEnumBgm
		*p = value
	case "BUK":
		value := PayCurrencyEnumBuk
		*p = value
	case "BIF":
		value := PayCurrencyEnumBif
		*p = value
	case "XPF":
		value := PayCurrencyEnumXpf
		*p = value
	case "KHR":
		value := PayCurrencyEnumKhr
		*p = value
	case "CAD":
		value := PayCurrencyEnumCad
		*p = value
	case "CVE":
		value := PayCurrencyEnumCve
		*p = value
	case "KYD":
		value := PayCurrencyEnumKyd
		*p = value
	case "XAF":
		value := PayCurrencyEnumXaf
		*p = value
	case "CLE":
		value := PayCurrencyEnumCle
		*p = value
	case "CLP":
		value := PayCurrencyEnumClp
		*p = value
	case "CLF":
		value := PayCurrencyEnumClf
		*p = value
	case "CNX":
		value := PayCurrencyEnumCnx
		*p = value
	case "CNY":
		value := PayCurrencyEnumCny
		*p = value
	case "CNH":
		value := PayCurrencyEnumCnh
		*p = value
	case "COP":
		value := PayCurrencyEnumCop
		*p = value
	case "COU":
		value := PayCurrencyEnumCou
		*p = value
	case "KMF":
		value := PayCurrencyEnumKmf
		*p = value
	case "CDF":
		value := PayCurrencyEnumCdf
		*p = value
	case "CRC":
		value := PayCurrencyEnumCrc
		*p = value
	case "HRD":
		value := PayCurrencyEnumHrd
		*p = value
	case "HRK":
		value := PayCurrencyEnumHrk
		*p = value
	case "CUC":
		value := PayCurrencyEnumCuc
		*p = value
	case "CUP":
		value := PayCurrencyEnumCup
		*p = value
	case "CYP":
		value := PayCurrencyEnumCyp
		*p = value
	case "CZK":
		value := PayCurrencyEnumCzk
		*p = value
	case "CSK":
		value := PayCurrencyEnumCsk
		*p = value
	case "DKK":
		value := PayCurrencyEnumDkk
		*p = value
	case "DJF":
		value := PayCurrencyEnumDjf
		*p = value
	case "DOP":
		value := PayCurrencyEnumDop
		*p = value
	case "NLG":
		value := PayCurrencyEnumNlg
		*p = value
	case "XCD":
		value := PayCurrencyEnumXcd
		*p = value
	case "DDM":
		value := PayCurrencyEnumDdm
		*p = value
	case "ECS":
		value := PayCurrencyEnumEcs
		*p = value
	case "ECV":
		value := PayCurrencyEnumEcv
		*p = value
	case "EGP":
		value := PayCurrencyEnumEgp
		*p = value
	case "GQE":
		value := PayCurrencyEnumGqe
		*p = value
	case "ERN":
		value := PayCurrencyEnumErn
		*p = value
	case "EEK":
		value := PayCurrencyEnumEek
		*p = value
	case "ETB":
		value := PayCurrencyEnumEtb
		*p = value
	case "EUR":
		value := PayCurrencyEnumEur
		*p = value
	case "XBA":
		value := PayCurrencyEnumXba
		*p = value
	case "XEU":
		value := PayCurrencyEnumXeu
		*p = value
	case "XBB":
		value := PayCurrencyEnumXbb
		*p = value
	case "XBC":
		value := PayCurrencyEnumXbc
		*p = value
	case "XBD":
		value := PayCurrencyEnumXbd
		*p = value
	case "FKP":
		value := PayCurrencyEnumFkp
		*p = value
	case "FJD":
		value := PayCurrencyEnumFjd
		*p = value
	case "FIM":
		value := PayCurrencyEnumFim
		*p = value
	case "FRF":
		value := PayCurrencyEnumFrf
		*p = value
	case "XFO":
		value := PayCurrencyEnumXfo
		*p = value
	case "XFU":
		value := PayCurrencyEnumXfu
		*p = value
	case "GMD":
		value := PayCurrencyEnumGmd
		*p = value
	case "GEK":
		value := PayCurrencyEnumGek
		*p = value
	case "GEL":
		value := PayCurrencyEnumGel
		*p = value
	case "DEM":
		value := PayCurrencyEnumDem
		*p = value
	case "GHS":
		value := PayCurrencyEnumGhs
		*p = value
	case "GHC":
		value := PayCurrencyEnumGhc
		*p = value
	case "GIP":
		value := PayCurrencyEnumGip
		*p = value
	case "XAU":
		value := PayCurrencyEnumXau
		*p = value
	case "GRD":
		value := PayCurrencyEnumGrd
		*p = value
	case "GTQ":
		value := PayCurrencyEnumGtq
		*p = value
	case "GWP":
		value := PayCurrencyEnumGwp
		*p = value
	case "GNF":
		value := PayCurrencyEnumGnf
		*p = value
	case "GNS":
		value := PayCurrencyEnumGns
		*p = value
	case "GYD":
		value := PayCurrencyEnumGyd
		*p = value
	case "HTG":
		value := PayCurrencyEnumHtg
		*p = value
	case "HNL":
		value := PayCurrencyEnumHnl
		*p = value
	case "HKD":
		value := PayCurrencyEnumHkd
		*p = value
	case "HUF":
		value := PayCurrencyEnumHuf
		*p = value
	case "IMP":
		value := PayCurrencyEnumImp
		*p = value
	case "ISK":
		value := PayCurrencyEnumIsk
		*p = value
	case "ISJ":
		value := PayCurrencyEnumIsj
		*p = value
	case "INR":
		value := PayCurrencyEnumInr
		*p = value
	case "IDR":
		value := PayCurrencyEnumIdr
		*p = value
	case "IRR":
		value := PayCurrencyEnumIrr
		*p = value
	case "IQD":
		value := PayCurrencyEnumIqd
		*p = value
	case "IEP":
		value := PayCurrencyEnumIep
		*p = value
	case "ILS":
		value := PayCurrencyEnumIls
		*p = value
	case "ILP":
		value := PayCurrencyEnumIlp
		*p = value
	case "ILR":
		value := PayCurrencyEnumIlr
		*p = value
	case "ITL":
		value := PayCurrencyEnumItl
		*p = value
	case "JMD":
		value := PayCurrencyEnumJmd
		*p = value
	case "JPY":
		value := PayCurrencyEnumJpy
		*p = value
	case "JOD":
		value := PayCurrencyEnumJod
		*p = value
	case "KZT":
		value := PayCurrencyEnumKzt
		*p = value
	case "KES":
		value := PayCurrencyEnumKes
		*p = value
	case "KWD":
		value := PayCurrencyEnumKwd
		*p = value
	case "KGS":
		value := PayCurrencyEnumKgs
		*p = value
	case "LAK":
		value := PayCurrencyEnumLak
		*p = value
	case "LVL":
		value := PayCurrencyEnumLvl
		*p = value
	case "LVR":
		value := PayCurrencyEnumLvr
		*p = value
	case "LBP":
		value := PayCurrencyEnumLbp
		*p = value
	case "LSL":
		value := PayCurrencyEnumLsl
		*p = value
	case "LRD":
		value := PayCurrencyEnumLrd
		*p = value
	case "LYD":
		value := PayCurrencyEnumLyd
		*p = value
	case "LTL":
		value := PayCurrencyEnumLtl
		*p = value
	case "LTT":
		value := PayCurrencyEnumLtt
		*p = value
	case "LUL":
		value := PayCurrencyEnumLul
		*p = value
	case "LUC":
		value := PayCurrencyEnumLuc
		*p = value
	case "LUF":
		value := PayCurrencyEnumLuf
		*p = value
	case "MOP":
		value := PayCurrencyEnumMop
		*p = value
	case "MKD":
		value := PayCurrencyEnumMkd
		*p = value
	case "MKN":
		value := PayCurrencyEnumMkn
		*p = value
	case "MGA":
		value := PayCurrencyEnumMga
		*p = value
	case "MGF":
		value := PayCurrencyEnumMgf
		*p = value
	case "MWK":
		value := PayCurrencyEnumMwk
		*p = value
	case "MYR":
		value := PayCurrencyEnumMyr
		*p = value
	case "MVR":
		value := PayCurrencyEnumMvr
		*p = value
	case "MVP":
		value := PayCurrencyEnumMvp
		*p = value
	case "MLF":
		value := PayCurrencyEnumMlf
		*p = value
	case "MTL":
		value := PayCurrencyEnumMtl
		*p = value
	case "MTP":
		value := PayCurrencyEnumMtp
		*p = value
	case "MRU":
		value := PayCurrencyEnumMru
		*p = value
	case "MRO":
		value := PayCurrencyEnumMro
		*p = value
	case "MUR":
		value := PayCurrencyEnumMur
		*p = value
	case "MXV":
		value := PayCurrencyEnumMxv
		*p = value
	case "MXN":
		value := PayCurrencyEnumMxn
		*p = value
	case "MXP":
		value := PayCurrencyEnumMxp
		*p = value
	case "MDC":
		value := PayCurrencyEnumMdc
		*p = value
	case "MDL":
		value := PayCurrencyEnumMdl
		*p = value
	case "MCF":
		value := PayCurrencyEnumMcf
		*p = value
	case "MNT":
		value := PayCurrencyEnumMnt
		*p = value
	case "MAD":
		value := PayCurrencyEnumMad
		*p = value
	case "MAF":
		value := PayCurrencyEnumMaf
		*p = value
	case "MZE":
		value := PayCurrencyEnumMze
		*p = value
	case "MZN":
		value := PayCurrencyEnumMzn
		*p = value
	case "MZM":
		value := PayCurrencyEnumMzm
		*p = value
	case "MMK":
		value := PayCurrencyEnumMmk
		*p = value
	case "NAD":
		value := PayCurrencyEnumNad
		*p = value
	case "NPR":
		value := PayCurrencyEnumNpr
		*p = value
	case "ANG":
		value := PayCurrencyEnumAng
		*p = value
	case "TWD":
		value := PayCurrencyEnumTwd
		*p = value
	case "NZD":
		value := PayCurrencyEnumNzd
		*p = value
	case "NIO":
		value := PayCurrencyEnumNio
		*p = value
	case "NIC":
		value := PayCurrencyEnumNic
		*p = value
	case "NGN":
		value := PayCurrencyEnumNgn
		*p = value
	case "KPW":
		value := PayCurrencyEnumKpw
		*p = value
	case "NOK":
		value := PayCurrencyEnumNok
		*p = value
	case "OMR":
		value := PayCurrencyEnumOmr
		*p = value
	case "PKR":
		value := PayCurrencyEnumPkr
		*p = value
	case "XPD":
		value := PayCurrencyEnumXpd
		*p = value
	case "PAB":
		value := PayCurrencyEnumPab
		*p = value
	case "PGK":
		value := PayCurrencyEnumPgk
		*p = value
	case "PYG":
		value := PayCurrencyEnumPyg
		*p = value
	case "PEI":
		value := PayCurrencyEnumPei
		*p = value
	case "PEN":
		value := PayCurrencyEnumPen
		*p = value
	case "PES":
		value := PayCurrencyEnumPes
		*p = value
	case "PHP":
		value := PayCurrencyEnumPhp
		*p = value
	case "XPT":
		value := PayCurrencyEnumXpt
		*p = value
	case "PLN":
		value := PayCurrencyEnumPln
		*p = value
	case "PLZ":
		value := PayCurrencyEnumPlz
		*p = value
	case "PTE":
		value := PayCurrencyEnumPte
		*p = value
	case "GWE":
		value := PayCurrencyEnumGwe
		*p = value
	case "QAR":
		value := PayCurrencyEnumQar
		*p = value
	case "XRE":
		value := PayCurrencyEnumXre
		*p = value
	case "RHD":
		value := PayCurrencyEnumRhd
		*p = value
	case "RON":
		value := PayCurrencyEnumRon
		*p = value
	case "ROL":
		value := PayCurrencyEnumRol
		*p = value
	case "RUB":
		value := PayCurrencyEnumRub
		*p = value
	case "RUR":
		value := PayCurrencyEnumRur
		*p = value
	case "RWF":
		value := PayCurrencyEnumRwf
		*p = value
	case "SVC":
		value := PayCurrencyEnumSvc
		*p = value
	case "WST":
		value := PayCurrencyEnumWst
		*p = value
	case "SAR":
		value := PayCurrencyEnumSar
		*p = value
	case "RSD":
		value := PayCurrencyEnumRsd
		*p = value
	case "CSD":
		value := PayCurrencyEnumCsd
		*p = value
	case "SCR":
		value := PayCurrencyEnumScr
		*p = value
	case "SLL":
		value := PayCurrencyEnumSll
		*p = value
	case "XAG":
		value := PayCurrencyEnumXag
		*p = value
	case "SGD":
		value := PayCurrencyEnumSgd
		*p = value
	case "SKK":
		value := PayCurrencyEnumSkk
		*p = value
	case "SIT":
		value := PayCurrencyEnumSit
		*p = value
	case "SBD":
		value := PayCurrencyEnumSbd
		*p = value
	case "SOS":
		value := PayCurrencyEnumSos
		*p = value
	case "ZAR":
		value := PayCurrencyEnumZar
		*p = value
	case "ZAL":
		value := PayCurrencyEnumZal
		*p = value
	case "KRH":
		value := PayCurrencyEnumKrh
		*p = value
	case "KRW":
		value := PayCurrencyEnumKrw
		*p = value
	case "KRO":
		value := PayCurrencyEnumKro
		*p = value
	case "SSP":
		value := PayCurrencyEnumSsp
		*p = value
	case "SUR":
		value := PayCurrencyEnumSur
		*p = value
	case "ESP":
		value := PayCurrencyEnumEsp
		*p = value
	case "ESA":
		value := PayCurrencyEnumEsa
		*p = value
	case "ESB":
		value := PayCurrencyEnumEsb
		*p = value
	case "XDR":
		value := PayCurrencyEnumXdr
		*p = value
	case "LKR":
		value := PayCurrencyEnumLkr
		*p = value
	case "SHP":
		value := PayCurrencyEnumShp
		*p = value
	case "XSU":
		value := PayCurrencyEnumXsu
		*p = value
	case "SDD":
		value := PayCurrencyEnumSdd
		*p = value
	case "SDG":
		value := PayCurrencyEnumSdg
		*p = value
	case "SDP":
		value := PayCurrencyEnumSdp
		*p = value
	case "SRD":
		value := PayCurrencyEnumSrd
		*p = value
	case "SRG":
		value := PayCurrencyEnumSrg
		*p = value
	case "SZL":
		value := PayCurrencyEnumSzl
		*p = value
	case "SEK":
		value := PayCurrencyEnumSek
		*p = value
	case "CHF":
		value := PayCurrencyEnumChf
		*p = value
	case "SYP":
		value := PayCurrencyEnumSyp
		*p = value
	case "STN":
		value := PayCurrencyEnumStn
		*p = value
	case "STD":
		value := PayCurrencyEnumStd
		*p = value
	case "TVD":
		value := PayCurrencyEnumTvd
		*p = value
	case "TJR":
		value := PayCurrencyEnumTjr
		*p = value
	case "TJS":
		value := PayCurrencyEnumTjs
		*p = value
	case "TZS":
		value := PayCurrencyEnumTzs
		*p = value
	case "XTS":
		value := PayCurrencyEnumXts
		*p = value
	case "THB":
		value := PayCurrencyEnumThb
		*p = value
	case "XXX":
		value := PayCurrencyEnumXxx
		*p = value
	case "TPE":
		value := PayCurrencyEnumTpe
		*p = value
	case "TOP":
		value := PayCurrencyEnumTop
		*p = value
	case "TTD":
		value := PayCurrencyEnumTtd
		*p = value
	case "TND":
		value := PayCurrencyEnumTnd
		*p = value
	case "TRY":
		value := PayCurrencyEnumTry
		*p = value
	case "TRL":
		value := PayCurrencyEnumTrl
		*p = value
	case "TMT":
		value := PayCurrencyEnumTmt
		*p = value
	case "TMM":
		value := PayCurrencyEnumTmm
		*p = value
	case "USD":
		value := PayCurrencyEnumUsd
		*p = value
	case "USN":
		value := PayCurrencyEnumUsn
		*p = value
	case "USS":
		value := PayCurrencyEnumUss
		*p = value
	case "UGX":
		value := PayCurrencyEnumUgx
		*p = value
	case "UGS":
		value := PayCurrencyEnumUgs
		*p = value
	case "UAH":
		value := PayCurrencyEnumUah
		*p = value
	case "UAK":
		value := PayCurrencyEnumUak
		*p = value
	case "AED":
		value := PayCurrencyEnumAed
		*p = value
	case "UYW":
		value := PayCurrencyEnumUyw
		*p = value
	case "UYU":
		value := PayCurrencyEnumUyu
		*p = value
	case "UYP":
		value := PayCurrencyEnumUyp
		*p = value
	case "UYI":
		value := PayCurrencyEnumUyi
		*p = value
	case "UZS":
		value := PayCurrencyEnumUzs
		*p = value
	case "VUV":
		value := PayCurrencyEnumVuv
		*p = value
	case "VES":
		value := PayCurrencyEnumVes
		*p = value
	case "VEB":
		value := PayCurrencyEnumVeb
		*p = value
	case "VEF":
		value := PayCurrencyEnumVef
		*p = value
	case "VND":
		value := PayCurrencyEnumVnd
		*p = value
	case "VNN":
		value := PayCurrencyEnumVnn
		*p = value
	case "CHE":
		value := PayCurrencyEnumChe
		*p = value
	case "CHW":
		value := PayCurrencyEnumChw
		*p = value
	case "XOF":
		value := PayCurrencyEnumXof
		*p = value
	case "YDD":
		value := PayCurrencyEnumYdd
		*p = value
	case "YER":
		value := PayCurrencyEnumYer
		*p = value
	case "YUN":
		value := PayCurrencyEnumYun
		*p = value
	case "YUD":
		value := PayCurrencyEnumYud
		*p = value
	case "YUM":
		value := PayCurrencyEnumYum
		*p = value
	case "YUR":
		value := PayCurrencyEnumYur
		*p = value
	case "ZWN":
		value := PayCurrencyEnumZwn
		*p = value
	case "ZRN":
		value := PayCurrencyEnumZrn
		*p = value
	case "ZRZ":
		value := PayCurrencyEnumZrz
		*p = value
	case "ZMW":
		value := PayCurrencyEnumZmw
		*p = value
	case "ZMK":
		value := PayCurrencyEnumZmk
		*p = value
	case "ZWD":
		value := PayCurrencyEnumZwd
		*p = value
	case "ZWR":
		value := PayCurrencyEnumZwr
		*p = value
	case "ZWL":
		value := PayCurrencyEnumZwl
		*p = value
	}
	return nil
}

// - `WEEKLY` - WEEKLY
// - `BIWEEKLY` - BIWEEKLY
// - `MONTHLY` - MONTHLY
// - `QUARTERLY` - QUARTERLY
// - `SEMIANNUALLY` - SEMIANNUALLY
// - `ANNUALLY` - ANNUALLY
// - `THIRTEEN-MONTHLY` - THIRTEEN-MONTHLY
// - `PRO_RATA` - PRO_RATA
// - `SEMIMONTHLY` - SEMIMONTHLY
type PayFrequencyEnum uint

const (
	PayFrequencyEnumWeekly PayFrequencyEnum = iota + 1
	PayFrequencyEnumBiweekly
	PayFrequencyEnumMonthly
	PayFrequencyEnumQuarterly
	PayFrequencyEnumSemiannually
	PayFrequencyEnumAnnually
	PayFrequencyEnumThirteenMonthly
	PayFrequencyEnumProRata
	PayFrequencyEnumSemimonthly
)

func (p PayFrequencyEnum) String() string {
	switch p {
	default:
		return strconv.Itoa(int(p))
	case PayFrequencyEnumWeekly:
		return "WEEKLY"
	case PayFrequencyEnumBiweekly:
		return "BIWEEKLY"
	case PayFrequencyEnumMonthly:
		return "MONTHLY"
	case PayFrequencyEnumQuarterly:
		return "QUARTERLY"
	case PayFrequencyEnumSemiannually:
		return "SEMIANNUALLY"
	case PayFrequencyEnumAnnually:
		return "ANNUALLY"
	case PayFrequencyEnumThirteenMonthly:
		return "THIRTEEN-MONTHLY"
	case PayFrequencyEnumProRata:
		return "PRO_RATA"
	case PayFrequencyEnumSemimonthly:
		return "SEMIMONTHLY"
	}
}

func (p PayFrequencyEnum) MarshalJSON() ([]byte, error) {
	return []byte(fmt.Sprintf("%q", p.String())), nil
}

func (p *PayFrequencyEnum) UnmarshalJSON(data []byte) error {
	var raw string
	if err := json.Unmarshal(data, &raw); err != nil {
		return err
	}
	switch raw {
	case "WEEKLY":
		value := PayFrequencyEnumWeekly
		*p = value
	case "BIWEEKLY":
		value := PayFrequencyEnumBiweekly
		*p = value
	case "MONTHLY":
		value := PayFrequencyEnumMonthly
		*p = value
	case "QUARTERLY":
		value := PayFrequencyEnumQuarterly
		*p = value
	case "SEMIANNUALLY":
		value := PayFrequencyEnumSemiannually
		*p = value
	case "ANNUALLY":
		value := PayFrequencyEnumAnnually
		*p = value
	case "THIRTEEN-MONTHLY":
		value := PayFrequencyEnumThirteenMonthly
		*p = value
	case "PRO_RATA":
		value := PayFrequencyEnumProRata
		*p = value
	case "SEMIMONTHLY":
		value := PayFrequencyEnumSemimonthly
		*p = value
	}
	return nil
}

// # The PayGroup Object
//
// ### Description
//
// The `PayGroup` object is used to represent a subset of employees that are put together for payroll processing purposes.
//
// ### Usage Example
//
// Fetch from the `LIST PayGroup` endpoint and filter by `ID` to show all pay group information.
type PayGroup struct {
	Id *string `json:"id,omitempty"`
	// The third-party API ID of the matching object.
	RemoteId *string `json:"remote_id,omitempty"`
	// The pay group name.
	PayGroupName *string `json:"pay_group_name,omitempty"`
	// Indicates whether or not this object has been deleted in the third party platform.
	RemoteWasDeleted *bool      `json:"remote_was_deleted,omitempty"`
	CreatedAt        *time.Time `json:"created_at,omitempty"`
	// This is the datetime that this object was last updated by Merge
	ModifiedAt    *time.Time     `json:"modified_at,omitempty"`
	FieldMappings map[string]any `json:"field_mappings,omitempty"`
	RemoteData    []*RemoteData  `json:"remote_data,omitempty"`
}

// - `HOUR` - HOUR
// - `DAY` - DAY
// - `WEEK` - WEEK
// - `EVERY_TWO_WEEKS` - EVERY_TWO_WEEKS
// - `SEMIMONTHLY` - SEMIMONTHLY
// - `MONTH` - MONTH
// - `QUARTER` - QUARTER
// - `EVERY_SIX_MONTHS` - EVERY_SIX_MONTHS
// - `YEAR` - YEAR
type PayPeriodEnum uint

const (
	PayPeriodEnumHour PayPeriodEnum = iota + 1
	PayPeriodEnumDay
	PayPeriodEnumWeek
	PayPeriodEnumEveryTwoWeeks
	PayPeriodEnumSemimonthly
	PayPeriodEnumMonth
	PayPeriodEnumQuarter
	PayPeriodEnumEverySixMonths
	PayPeriodEnumYear
)

func (p PayPeriodEnum) String() string {
	switch p {
	default:
		return strconv.Itoa(int(p))
	case PayPeriodEnumHour:
		return "HOUR"
	case PayPeriodEnumDay:
		return "DAY"
	case PayPeriodEnumWeek:
		return "WEEK"
	case PayPeriodEnumEveryTwoWeeks:
		return "EVERY_TWO_WEEKS"
	case PayPeriodEnumSemimonthly:
		return "SEMIMONTHLY"
	case PayPeriodEnumMonth:
		return "MONTH"
	case PayPeriodEnumQuarter:
		return "QUARTER"
	case PayPeriodEnumEverySixMonths:
		return "EVERY_SIX_MONTHS"
	case PayPeriodEnumYear:
		return "YEAR"
	}
}

func (p PayPeriodEnum) MarshalJSON() ([]byte, error) {
	return []byte(fmt.Sprintf("%q", p.String())), nil
}

func (p *PayPeriodEnum) UnmarshalJSON(data []byte) error {
	var raw string
	if err := json.Unmarshal(data, &raw); err != nil {
		return err
	}
	switch raw {
	case "HOUR":
		value := PayPeriodEnumHour
		*p = value
	case "DAY":
		value := PayPeriodEnumDay
		*p = value
	case "WEEK":
		value := PayPeriodEnumWeek
		*p = value
	case "EVERY_TWO_WEEKS":
		value := PayPeriodEnumEveryTwoWeeks
		*p = value
	case "SEMIMONTHLY":
		value := PayPeriodEnumSemimonthly
		*p = value
	case "MONTH":
		value := PayPeriodEnumMonth
		*p = value
	case "QUARTER":
		value := PayPeriodEnumQuarter
		*p = value
	case "EVERY_SIX_MONTHS":
		value := PayPeriodEnumEverySixMonths
		*p = value
	case "YEAR":
		value := PayPeriodEnumYear
		*p = value
	}
	return nil
}

// # The PayrollRun Object
//
// ### Description
//
// The `PayrollRun` object is used to represent a group of pay statements for a specific pay schedule.
//
// ### Usage Example
//
// Fetch from the `LIST PayrollRuns` endpoint and filter by `ID` to show all payroll runs.
type PayrollRun struct {
	Id *string `json:"id,omitempty"`
	// The third-party API ID of the matching object.
	RemoteId *string `json:"remote_id,omitempty"`
	// The state of the payroll run
	//
	// - `PAID` - PAID
	// - `DRAFT` - DRAFT
	// - `APPROVED` - APPROVED
	// - `FAILED` - FAILED
	// - `CLOSED` - CLOSED
	RunState *PayrollRunRunState `json:"run_state,omitempty"`
	// The type of the payroll run
	//
	// - `REGULAR` - REGULAR
	// - `OFF_CYCLE` - OFF_CYCLE
	// - `CORRECTION` - CORRECTION
	// - `TERMINATION` - TERMINATION
	// - `SIGN_ON_BONUS` - SIGN_ON_BONUS
	RunType *PayrollRunRunType `json:"run_type,omitempty"`
	// The day and time the payroll run started.
	StartDate *time.Time `json:"start_date,omitempty"`
	// The day and time the payroll run ended.
	EndDate *time.Time `json:"end_date,omitempty"`
	// The day and time the payroll run was checked.
	CheckDate *time.Time `json:"check_date,omitempty"`
	// Indicates whether or not this object has been deleted in the third party platform.
	RemoteWasDeleted *bool      `json:"remote_was_deleted,omitempty"`
	CreatedAt        *time.Time `json:"created_at,omitempty"`
	// This is the datetime that this object was last updated by Merge
	ModifiedAt    *time.Time     `json:"modified_at,omitempty"`
	FieldMappings map[string]any `json:"field_mappings,omitempty"`
	RemoteData    []*RemoteData  `json:"remote_data,omitempty"`
}

// The state of the payroll run
//
// - `PAID` - PAID
// - `DRAFT` - DRAFT
// - `APPROVED` - APPROVED
// - `FAILED` - FAILED
// - `CLOSED` - CLOSED
type PayrollRunRunState struct {
	typeName     string
	RunStateEnum RunStateEnum
	String       string
}

func NewPayrollRunRunStateFromRunStateEnum(value RunStateEnum) *PayrollRunRunState {
	return &PayrollRunRunState{typeName: "runStateEnum", RunStateEnum: value}
}

func NewPayrollRunRunStateFromString(value string) *PayrollRunRunState {
	return &PayrollRunRunState{typeName: "string", String: value}
}

func (p *PayrollRunRunState) UnmarshalJSON(data []byte) error {
	var valueRunStateEnum RunStateEnum
	if err := json.Unmarshal(data, &valueRunStateEnum); err == nil {
		p.typeName = "runStateEnum"
		p.RunStateEnum = valueRunStateEnum
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		p.typeName = "string"
		p.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, p)
}

func (p PayrollRunRunState) MarshalJSON() ([]byte, error) {
	switch p.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", p.typeName, p)
	case "runStateEnum":
		return json.Marshal(p.RunStateEnum)
	case "string":
		return json.Marshal(p.String)
	}
}

type PayrollRunRunStateVisitor interface {
	VisitRunStateEnum(RunStateEnum) error
	VisitString(string) error
}

func (p *PayrollRunRunState) Accept(visitor PayrollRunRunStateVisitor) error {
	switch p.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", p.typeName, p)
	case "runStateEnum":
		return visitor.VisitRunStateEnum(p.RunStateEnum)
	case "string":
		return visitor.VisitString(p.String)
	}
}

// The type of the payroll run
//
// - `REGULAR` - REGULAR
// - `OFF_CYCLE` - OFF_CYCLE
// - `CORRECTION` - CORRECTION
// - `TERMINATION` - TERMINATION
// - `SIGN_ON_BONUS` - SIGN_ON_BONUS
type PayrollRunRunType struct {
	typeName    string
	RunTypeEnum RunTypeEnum
	String      string
}

func NewPayrollRunRunTypeFromRunTypeEnum(value RunTypeEnum) *PayrollRunRunType {
	return &PayrollRunRunType{typeName: "runTypeEnum", RunTypeEnum: value}
}

func NewPayrollRunRunTypeFromString(value string) *PayrollRunRunType {
	return &PayrollRunRunType{typeName: "string", String: value}
}

func (p *PayrollRunRunType) UnmarshalJSON(data []byte) error {
	var valueRunTypeEnum RunTypeEnum
	if err := json.Unmarshal(data, &valueRunTypeEnum); err == nil {
		p.typeName = "runTypeEnum"
		p.RunTypeEnum = valueRunTypeEnum
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		p.typeName = "string"
		p.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, p)
}

func (p PayrollRunRunType) MarshalJSON() ([]byte, error) {
	switch p.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", p.typeName, p)
	case "runTypeEnum":
		return json.Marshal(p.RunTypeEnum)
	case "string":
		return json.Marshal(p.String)
	}
}

type PayrollRunRunTypeVisitor interface {
	VisitRunTypeEnum(RunTypeEnum) error
	VisitString(string) error
}

func (p *PayrollRunRunType) Accept(visitor PayrollRunRunTypeVisitor) error {
	switch p.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", p.typeName, p)
	case "runTypeEnum":
		return visitor.VisitRunTypeEnum(p.RunTypeEnum)
	case "string":
		return visitor.VisitString(p.String)
	}
}

// - `VACATION` - VACATION
// - `SICK` - SICK
// - `PERSONAL` - PERSONAL
// - `JURY_DUTY` - JURY_DUTY
// - `VOLUNTEER` - VOLUNTEER
// - `BEREAVEMENT` - BEREAVEMENT
type PolicyTypeEnum uint

const (
	PolicyTypeEnumVacation PolicyTypeEnum = iota + 1
	PolicyTypeEnumSick
	PolicyTypeEnumPersonal
	PolicyTypeEnumJuryDuty
	PolicyTypeEnumVolunteer
	PolicyTypeEnumBereavement
)

func (p PolicyTypeEnum) String() string {
	switch p {
	default:
		return strconv.Itoa(int(p))
	case PolicyTypeEnumVacation:
		return "VACATION"
	case PolicyTypeEnumSick:
		return "SICK"
	case PolicyTypeEnumPersonal:
		return "PERSONAL"
	case PolicyTypeEnumJuryDuty:
		return "JURY_DUTY"
	case PolicyTypeEnumVolunteer:
		return "VOLUNTEER"
	case PolicyTypeEnumBereavement:
		return "BEREAVEMENT"
	}
}

func (p PolicyTypeEnum) MarshalJSON() ([]byte, error) {
	return []byte(fmt.Sprintf("%q", p.String())), nil
}

func (p *PolicyTypeEnum) UnmarshalJSON(data []byte) error {
	var raw string
	if err := json.Unmarshal(data, &raw); err != nil {
		return err
	}
	switch raw {
	case "VACATION":
		value := PolicyTypeEnumVacation
		*p = value
	case "SICK":
		value := PolicyTypeEnumSick
		*p = value
	case "PERSONAL":
		value := PolicyTypeEnumPersonal
		*p = value
	case "JURY_DUTY":
		value := PolicyTypeEnumJuryDuty
		*p = value
	case "VOLUNTEER":
		value := PolicyTypeEnumVolunteer
		*p = value
	case "BEREAVEMENT":
		value := PolicyTypeEnumBereavement
		*p = value
	}
	return nil
}

// - `GENERAL_CUSTOMER_REQUEST` - GENERAL_CUSTOMER_REQUEST
// - `GDPR` - GDPR
// - `OTHER` - OTHER
type ReasonEnum uint

const (
	ReasonEnumGeneralCustomerRequest ReasonEnum = iota + 1
	ReasonEnumGdpr
	ReasonEnumOther
)

func (r ReasonEnum) String() string {
	switch r {
	default:
		return strconv.Itoa(int(r))
	case ReasonEnumGeneralCustomerRequest:
		return "GENERAL_CUSTOMER_REQUEST"
	case ReasonEnumGdpr:
		return "GDPR"
	case ReasonEnumOther:
		return "OTHER"
	}
}

func (r ReasonEnum) MarshalJSON() ([]byte, error) {
	return []byte(fmt.Sprintf("%q", r.String())), nil
}

func (r *ReasonEnum) UnmarshalJSON(data []byte) error {
	var raw string
	if err := json.Unmarshal(data, &raw); err != nil {
		return err
	}
	switch raw {
	case "GENERAL_CUSTOMER_REQUEST":
		value := ReasonEnumGeneralCustomerRequest
		*r = value
	case "GDPR":
		value := ReasonEnumGdpr
		*r = value
	case "OTHER":
		value := ReasonEnumOther
		*r = value
	}
	return nil
}

// - `CHILD` - CHILD
// - `SPOUSE` - SPOUSE
// - `DOMESTIC_PARTNER` - DOMESTIC_PARTNER
type RelationshipEnum uint

const (
	RelationshipEnumChild RelationshipEnum = iota + 1
	RelationshipEnumSpouse
	RelationshipEnumDomesticPartner
)

func (r RelationshipEnum) String() string {
	switch r {
	default:
		return strconv.Itoa(int(r))
	case RelationshipEnumChild:
		return "CHILD"
	case RelationshipEnumSpouse:
		return "SPOUSE"
	case RelationshipEnumDomesticPartner:
		return "DOMESTIC_PARTNER"
	}
}

func (r RelationshipEnum) MarshalJSON() ([]byte, error) {
	return []byte(fmt.Sprintf("%q", r.String())), nil
}

func (r *RelationshipEnum) UnmarshalJSON(data []byte) error {
	var raw string
	if err := json.Unmarshal(data, &raw); err != nil {
		return err
	}
	switch raw {
	case "CHILD":
		value := RelationshipEnumChild
		*r = value
	case "SPOUSE":
		value := RelationshipEnumSpouse
		*r = value
	case "DOMESTIC_PARTNER":
		value := RelationshipEnumDomesticPartner
		*r = value
	}
	return nil
}

type RemoteData struct {
	Path string `json:"path"`
	Data *any   `json:"data,omitempty"`
}

// # The RemoteKey Object
//
// ### Description
//
// The `RemoteKey` object is used to represent a request for a new remote key.
//
// ### Usage Example
//
// Post a `GenerateRemoteKey` to receive a new `RemoteKey`.
type RemoteKey struct {
	Name string `json:"name"`
	Key  string `json:"key"`
}

// # The RemoteResponse Object
//
// ### Description
//
// The `RemoteResponse` object is used to represent information returned from a third-party endpoint.
//
// ### Usage Example
//
// View the `RemoteResponse` returned from your `DataPassthrough`.
type RemoteResponse struct {
	Method          string                      `json:"method"`
	Path            string                      `json:"path"`
	Status          int                         `json:"status"`
	Response        any                         `json:"response,omitempty"`
	ResponseHeaders map[string]any              `json:"response_headers,omitempty"`
	ResponseType    *RemoteResponseResponseType `json:"response_type,omitempty"`
	Headers         map[string]any              `json:"headers,omitempty"`
}

type RemoteResponseResponseType struct {
	typeName         string
	ResponseTypeEnum ResponseTypeEnum
	String           string
}

func NewRemoteResponseResponseTypeFromResponseTypeEnum(value ResponseTypeEnum) *RemoteResponseResponseType {
	return &RemoteResponseResponseType{typeName: "responseTypeEnum", ResponseTypeEnum: value}
}

func NewRemoteResponseResponseTypeFromString(value string) *RemoteResponseResponseType {
	return &RemoteResponseResponseType{typeName: "string", String: value}
}

func (r *RemoteResponseResponseType) UnmarshalJSON(data []byte) error {
	var valueResponseTypeEnum ResponseTypeEnum
	if err := json.Unmarshal(data, &valueResponseTypeEnum); err == nil {
		r.typeName = "responseTypeEnum"
		r.ResponseTypeEnum = valueResponseTypeEnum
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		r.typeName = "string"
		r.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, r)
}

func (r RemoteResponseResponseType) MarshalJSON() ([]byte, error) {
	switch r.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", r.typeName, r)
	case "responseTypeEnum":
		return json.Marshal(r.ResponseTypeEnum)
	case "string":
		return json.Marshal(r.String)
	}
}

type RemoteResponseResponseTypeVisitor interface {
	VisitResponseTypeEnum(ResponseTypeEnum) error
	VisitString(string) error
}

func (r *RemoteResponseResponseType) Accept(visitor RemoteResponseResponseTypeVisitor) error {
	switch r.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", r.typeName, r)
	case "responseTypeEnum":
		return visitor.VisitResponseTypeEnum(r.ResponseTypeEnum)
	case "string":
		return visitor.VisitString(r.String)
	}
}

// - `JSON` - JSON
// - `XML` - XML
// - `MULTIPART` - MULTIPART
type RequestFormatEnum uint

const (
	RequestFormatEnumJson RequestFormatEnum = iota + 1
	RequestFormatEnumXml
	RequestFormatEnumMultipart
)

func (r RequestFormatEnum) String() string {
	switch r {
	default:
		return strconv.Itoa(int(r))
	case RequestFormatEnumJson:
		return "JSON"
	case RequestFormatEnumXml:
		return "XML"
	case RequestFormatEnumMultipart:
		return "MULTIPART"
	}
}

func (r RequestFormatEnum) MarshalJSON() ([]byte, error) {
	return []byte(fmt.Sprintf("%q", r.String())), nil
}

func (r *RequestFormatEnum) UnmarshalJSON(data []byte) error {
	var raw string
	if err := json.Unmarshal(data, &raw); err != nil {
		return err
	}
	switch raw {
	case "JSON":
		value := RequestFormatEnumJson
		*r = value
	case "XML":
		value := RequestFormatEnumXml
		*r = value
	case "MULTIPART":
		value := RequestFormatEnumMultipart
		*r = value
	}
	return nil
}

// - `VACATION` - VACATION
// - `SICK` - SICK
// - `PERSONAL` - PERSONAL
// - `JURY_DUTY` - JURY_DUTY
// - `VOLUNTEER` - VOLUNTEER
// - `BEREAVEMENT` - BEREAVEMENT
type RequestTypeEnum uint

const (
	RequestTypeEnumVacation RequestTypeEnum = iota + 1
	RequestTypeEnumSick
	RequestTypeEnumPersonal
	RequestTypeEnumJuryDuty
	RequestTypeEnumVolunteer
	RequestTypeEnumBereavement
)

func (r RequestTypeEnum) String() string {
	switch r {
	default:
		return strconv.Itoa(int(r))
	case RequestTypeEnumVacation:
		return "VACATION"
	case RequestTypeEnumSick:
		return "SICK"
	case RequestTypeEnumPersonal:
		return "PERSONAL"
	case RequestTypeEnumJuryDuty:
		return "JURY_DUTY"
	case RequestTypeEnumVolunteer:
		return "VOLUNTEER"
	case RequestTypeEnumBereavement:
		return "BEREAVEMENT"
	}
}

func (r RequestTypeEnum) MarshalJSON() ([]byte, error) {
	return []byte(fmt.Sprintf("%q", r.String())), nil
}

func (r *RequestTypeEnum) UnmarshalJSON(data []byte) error {
	var raw string
	if err := json.Unmarshal(data, &raw); err != nil {
		return err
	}
	switch raw {
	case "VACATION":
		value := RequestTypeEnumVacation
		*r = value
	case "SICK":
		value := RequestTypeEnumSick
		*r = value
	case "PERSONAL":
		value := RequestTypeEnumPersonal
		*r = value
	case "JURY_DUTY":
		value := RequestTypeEnumJuryDuty
		*r = value
	case "VOLUNTEER":
		value := RequestTypeEnumVolunteer
		*r = value
	case "BEREAVEMENT":
		value := RequestTypeEnumBereavement
		*r = value
	}
	return nil
}

// - `JSON` - JSON
// - `BASE64_GZIP` - BASE64_GZIP
type ResponseTypeEnum uint

const (
	ResponseTypeEnumJson ResponseTypeEnum = iota + 1
	ResponseTypeEnumBase64Gzip
)

func (r ResponseTypeEnum) String() string {
	switch r {
	default:
		return strconv.Itoa(int(r))
	case ResponseTypeEnumJson:
		return "JSON"
	case ResponseTypeEnumBase64Gzip:
		return "BASE64_GZIP"
	}
}

func (r ResponseTypeEnum) MarshalJSON() ([]byte, error) {
	return []byte(fmt.Sprintf("%q", r.String())), nil
}

func (r *ResponseTypeEnum) UnmarshalJSON(data []byte) error {
	var raw string
	if err := json.Unmarshal(data, &raw); err != nil {
		return err
	}
	switch raw {
	case "JSON":
		value := ResponseTypeEnumJson
		*r = value
	case "BASE64_GZIP":
		value := ResponseTypeEnumBase64Gzip
		*r = value
	}
	return nil
}

// - `ADMIN` - ADMIN
// - `DEVELOPER` - DEVELOPER
// - `MEMBER` - MEMBER
// - `API` - API
// - `SYSTEM` - SYSTEM
// - `MERGE_TEAM` - MERGE_TEAM
type RoleEnum uint

const (
	RoleEnumAdmin RoleEnum = iota + 1
	RoleEnumDeveloper
	RoleEnumMember
	RoleEnumApi
	RoleEnumSystem
	RoleEnumMergeTeam
)

func (r RoleEnum) String() string {
	switch r {
	default:
		return strconv.Itoa(int(r))
	case RoleEnumAdmin:
		return "ADMIN"
	case RoleEnumDeveloper:
		return "DEVELOPER"
	case RoleEnumMember:
		return "MEMBER"
	case RoleEnumApi:
		return "API"
	case RoleEnumSystem:
		return "SYSTEM"
	case RoleEnumMergeTeam:
		return "MERGE_TEAM"
	}
}

func (r RoleEnum) MarshalJSON() ([]byte, error) {
	return []byte(fmt.Sprintf("%q", r.String())), nil
}

func (r *RoleEnum) UnmarshalJSON(data []byte) error {
	var raw string
	if err := json.Unmarshal(data, &raw); err != nil {
		return err
	}
	switch raw {
	case "ADMIN":
		value := RoleEnumAdmin
		*r = value
	case "DEVELOPER":
		value := RoleEnumDeveloper
		*r = value
	case "MEMBER":
		value := RoleEnumMember
		*r = value
	case "API":
		value := RoleEnumApi
		*r = value
	case "SYSTEM":
		value := RoleEnumSystem
		*r = value
	case "MERGE_TEAM":
		value := RoleEnumMergeTeam
		*r = value
	}
	return nil
}

// - `PAID` - PAID
// - `DRAFT` - DRAFT
// - `APPROVED` - APPROVED
// - `FAILED` - FAILED
// - `CLOSED` - CLOSED
type RunStateEnum uint

const (
	RunStateEnumPaid RunStateEnum = iota + 1
	RunStateEnumDraft
	RunStateEnumApproved
	RunStateEnumFailed
	RunStateEnumClosed
)

func (r RunStateEnum) String() string {
	switch r {
	default:
		return strconv.Itoa(int(r))
	case RunStateEnumPaid:
		return "PAID"
	case RunStateEnumDraft:
		return "DRAFT"
	case RunStateEnumApproved:
		return "APPROVED"
	case RunStateEnumFailed:
		return "FAILED"
	case RunStateEnumClosed:
		return "CLOSED"
	}
}

func (r RunStateEnum) MarshalJSON() ([]byte, error) {
	return []byte(fmt.Sprintf("%q", r.String())), nil
}

func (r *RunStateEnum) UnmarshalJSON(data []byte) error {
	var raw string
	if err := json.Unmarshal(data, &raw); err != nil {
		return err
	}
	switch raw {
	case "PAID":
		value := RunStateEnumPaid
		*r = value
	case "DRAFT":
		value := RunStateEnumDraft
		*r = value
	case "APPROVED":
		value := RunStateEnumApproved
		*r = value
	case "FAILED":
		value := RunStateEnumFailed
		*r = value
	case "CLOSED":
		value := RunStateEnumClosed
		*r = value
	}
	return nil
}

// - `REGULAR` - REGULAR
// - `OFF_CYCLE` - OFF_CYCLE
// - `CORRECTION` - CORRECTION
// - `TERMINATION` - TERMINATION
// - `SIGN_ON_BONUS` - SIGN_ON_BONUS
type RunTypeEnum uint

const (
	RunTypeEnumRegular RunTypeEnum = iota + 1
	RunTypeEnumOffCycle
	RunTypeEnumCorrection
	RunTypeEnumTermination
	RunTypeEnumSignOnBonus
)

func (r RunTypeEnum) String() string {
	switch r {
	default:
		return strconv.Itoa(int(r))
	case RunTypeEnumRegular:
		return "REGULAR"
	case RunTypeEnumOffCycle:
		return "OFF_CYCLE"
	case RunTypeEnumCorrection:
		return "CORRECTION"
	case RunTypeEnumTermination:
		return "TERMINATION"
	case RunTypeEnumSignOnBonus:
		return "SIGN_ON_BONUS"
	}
}

func (r RunTypeEnum) MarshalJSON() ([]byte, error) {
	return []byte(fmt.Sprintf("%q", r.String())), nil
}

func (r *RunTypeEnum) UnmarshalJSON(data []byte) error {
	var raw string
	if err := json.Unmarshal(data, &raw); err != nil {
		return err
	}
	switch raw {
	case "REGULAR":
		value := RunTypeEnumRegular
		*r = value
	case "OFF_CYCLE":
		value := RunTypeEnumOffCycle
		*r = value
	case "CORRECTION":
		value := RunTypeEnumCorrection
		*r = value
	case "TERMINATION":
		value := RunTypeEnumTermination
		*r = value
	case "SIGN_ON_BONUS":
		value := RunTypeEnumSignOnBonus
		*r = value
	}
	return nil
}

// - `IN_NEXT_SYNC` - IN_NEXT_SYNC
// - `IN_LAST_SYNC` - IN_LAST_SYNC
type SelectiveSyncConfigurationsUsageEnum uint

const (
	SelectiveSyncConfigurationsUsageEnumInNextSync SelectiveSyncConfigurationsUsageEnum = iota + 1
	SelectiveSyncConfigurationsUsageEnumInLastSync
)

func (s SelectiveSyncConfigurationsUsageEnum) String() string {
	switch s {
	default:
		return strconv.Itoa(int(s))
	case SelectiveSyncConfigurationsUsageEnumInNextSync:
		return "IN_NEXT_SYNC"
	case SelectiveSyncConfigurationsUsageEnumInLastSync:
		return "IN_LAST_SYNC"
	}
}

func (s SelectiveSyncConfigurationsUsageEnum) MarshalJSON() ([]byte, error) {
	return []byte(fmt.Sprintf("%q", s.String())), nil
}

func (s *SelectiveSyncConfigurationsUsageEnum) UnmarshalJSON(data []byte) error {
	var raw string
	if err := json.Unmarshal(data, &raw); err != nil {
		return err
	}
	switch raw {
	case "IN_NEXT_SYNC":
		value := SelectiveSyncConfigurationsUsageEnumInNextSync
		*s = value
	case "IN_LAST_SYNC":
		value := SelectiveSyncConfigurationsUsageEnumInLastSync
		*s = value
	}
	return nil
}

// # The SyncStatus Object
//
// ### Description
//
// # The `SyncStatus` object is used to represent the syncing state of an account
//
// ### Usage Example
//
// View the `SyncStatus` for an account to see how recently its models were synced.
type SyncStatus struct {
	ModelName                        string                                `json:"model_name"`
	ModelId                          string                                `json:"model_id"`
	LastSyncStart                    *time.Time                            `json:"last_sync_start,omitempty"`
	NextSyncStart                    *time.Time                            `json:"next_sync_start,omitempty"`
	Status                           SyncStatusStatusEnum                  `json:"status,omitempty"`
	IsInitialSync                    bool                                  `json:"is_initial_sync"`
	SelectiveSyncConfigurationsUsage *SelectiveSyncConfigurationsUsageEnum `json:"selective_sync_configurations_usage,omitempty"`
}

// - `SYNCING` - SYNCING
// - `DONE` - DONE
// - `FAILED` - FAILED
// - `DISABLED` - DISABLED
// - `PAUSED` - PAUSED
// - `PARTIALLY_SYNCED` - PARTIALLY_SYNCED
type SyncStatusStatusEnum uint

const (
	SyncStatusStatusEnumSyncing SyncStatusStatusEnum = iota + 1
	SyncStatusStatusEnumDone
	SyncStatusStatusEnumFailed
	SyncStatusStatusEnumDisabled
	SyncStatusStatusEnumPaused
	SyncStatusStatusEnumPartiallySynced
)

func (s SyncStatusStatusEnum) String() string {
	switch s {
	default:
		return strconv.Itoa(int(s))
	case SyncStatusStatusEnumSyncing:
		return "SYNCING"
	case SyncStatusStatusEnumDone:
		return "DONE"
	case SyncStatusStatusEnumFailed:
		return "FAILED"
	case SyncStatusStatusEnumDisabled:
		return "DISABLED"
	case SyncStatusStatusEnumPaused:
		return "PAUSED"
	case SyncStatusStatusEnumPartiallySynced:
		return "PARTIALLY_SYNCED"
	}
}

func (s SyncStatusStatusEnum) MarshalJSON() ([]byte, error) {
	return []byte(fmt.Sprintf("%q", s.String())), nil
}

func (s *SyncStatusStatusEnum) UnmarshalJSON(data []byte) error {
	var raw string
	if err := json.Unmarshal(data, &raw); err != nil {
		return err
	}
	switch raw {
	case "SYNCING":
		value := SyncStatusStatusEnumSyncing
		*s = value
	case "DONE":
		value := SyncStatusStatusEnumDone
		*s = value
	case "FAILED":
		value := SyncStatusStatusEnumFailed
		*s = value
	case "DISABLED":
		value := SyncStatusStatusEnumDisabled
		*s = value
	case "PAUSED":
		value := SyncStatusStatusEnumPaused
		*s = value
	case "PARTIALLY_SYNCED":
		value := SyncStatusStatusEnumPartiallySynced
		*s = value
	}
	return nil
}

// # The Tax Object
//
// ### Description
//
// The `Tax` object is used to represent an array of the tax deductions for a given employee's payroll run.
//
// ### Usage Example
//
// Fetch from the `LIST Taxes` endpoint and filter by `ID` to show all taxes.
type Tax struct {
	Id *string `json:"id,omitempty"`
	// The third-party API ID of the matching object.
	RemoteId           *string `json:"remote_id,omitempty"`
	EmployeePayrollRun *string `json:"employee_payroll_run,omitempty"`
	// The tax's name.
	Name *string `json:"name,omitempty"`
	// The tax amount.
	Amount *float64 `json:"amount,omitempty"`
	// Whether or not the employer is responsible for paying the tax.
	EmployerTax *bool `json:"employer_tax,omitempty"`
	// Indicates whether or not this object has been deleted in the third party platform.
	RemoteWasDeleted *bool      `json:"remote_was_deleted,omitempty"`
	CreatedAt        *time.Time `json:"created_at,omitempty"`
	// This is the datetime that this object was last updated by Merge
	ModifiedAt    *time.Time     `json:"modified_at,omitempty"`
	FieldMappings map[string]any `json:"field_mappings,omitempty"`
	RemoteData    []*RemoteData  `json:"remote_data,omitempty"`
}

// # The Team Object
//
// ### Description
//
// The `Team` object is used to represent a subdivision of the company, usually a department. Each employee will be grouped into one specific Team.
//
// ### Usage Example
//
// If you're building a way to filter by `Team`, you'd hit the `GET Teams` endpoint to fetch the `Teams`, and then use the `ID` of the team your user selects to filter the `GET Employees` endpoint.
type Team struct {
	Id *string `json:"id,omitempty"`
	// The third-party API ID of the matching object.
	RemoteId *string `json:"remote_id,omitempty"`
	// The team's name.
	Name *string `json:"name,omitempty"`
	// The team's parent team.
	ParentTeam *TeamParentTeam `json:"parent_team,omitempty"`
	// Indicates whether or not this object has been deleted in the third party platform.
	RemoteWasDeleted *bool      `json:"remote_was_deleted,omitempty"`
	CreatedAt        *time.Time `json:"created_at,omitempty"`
	// This is the datetime that this object was last updated by Merge
	ModifiedAt    *time.Time     `json:"modified_at,omitempty"`
	FieldMappings map[string]any `json:"field_mappings,omitempty"`
	RemoteData    []*RemoteData  `json:"remote_data,omitempty"`
}

// The team's parent team.
type TeamParentTeam struct {
	typeName string
	String   string
	Team     *Team
}

func NewTeamParentTeamFromString(value string) *TeamParentTeam {
	return &TeamParentTeam{typeName: "string", String: value}
}

func NewTeamParentTeamFromTeam(value *Team) *TeamParentTeam {
	return &TeamParentTeam{typeName: "team", Team: value}
}

func (t *TeamParentTeam) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		t.typeName = "string"
		t.String = valueString
		return nil
	}
	valueTeam := new(Team)
	if err := json.Unmarshal(data, &valueTeam); err == nil {
		t.typeName = "team"
		t.Team = valueTeam
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, t)
}

func (t TeamParentTeam) MarshalJSON() ([]byte, error) {
	switch t.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", t.typeName, t)
	case "string":
		return json.Marshal(t.String)
	case "team":
		return json.Marshal(t.Team)
	}
}

type TeamParentTeamVisitor interface {
	VisitString(string) error
	VisitTeam(*Team) error
}

func (t *TeamParentTeam) Accept(visitor TeamParentTeamVisitor) error {
	switch t.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", t.typeName, t)
	case "string":
		return visitor.VisitString(t.String)
	case "team":
		return visitor.VisitTeam(t.Team)
	}
}

// # The TimeOff Object
//
// ### Description
//
// The `TimeOff` object is used to represent all employees' Time Off entries.
//
// ### Usage Example
//
// Fetch from the `LIST TimeOffs` endpoint and filter by `ID` to show all time off requests.
type TimeOff struct {
	Id *string `json:"id,omitempty"`
	// The third-party API ID of the matching object.
	RemoteId *string `json:"remote_id,omitempty"`
	// The employee requesting time off.
	Employee *TimeOffEmployee `json:"employee,omitempty"`
	// The Merge ID of the employee with the ability to approve the time off request.
	Approver *TimeOffApprover `json:"approver,omitempty"`
	// The status of this time off request.
	//
	// - `REQUESTED` - REQUESTED
	// - `APPROVED` - APPROVED
	// - `DECLINED` - DECLINED
	// - `CANCELLED` - CANCELLED
	// - `DELETED` - DELETED
	Status *TimeOffStatus `json:"status,omitempty"`
	// The employee note for this time off request.
	EmployeeNote *string `json:"employee_note,omitempty"`
	// The measurement that the third-party integration uses to count time requested.
	//
	// - `HOURS` - HOURS
	// - `DAYS` - DAYS
	Units *TimeOffUnits `json:"units,omitempty"`
	// The time off quantity measured by the prescribed “units”.
	Amount *float64 `json:"amount,omitempty"`
	// The type of time off request.
	//
	// - `VACATION` - VACATION
	// - `SICK` - SICK
	// - `PERSONAL` - PERSONAL
	// - `JURY_DUTY` - JURY_DUTY
	// - `VOLUNTEER` - VOLUNTEER
	// - `BEREAVEMENT` - BEREAVEMENT
	RequestType *TimeOffRequestType `json:"request_type,omitempty"`
	// The day and time of the start of the time requested off.
	StartTime *time.Time `json:"start_time,omitempty"`
	// The day and time of the end of the time requested off.
	EndTime          *time.Time `json:"end_time,omitempty"`
	RemoteWasDeleted *bool      `json:"remote_was_deleted,omitempty"`
	CreatedAt        *time.Time `json:"created_at,omitempty"`
	// This is the datetime that this object was last updated by Merge
	ModifiedAt    *time.Time     `json:"modified_at,omitempty"`
	FieldMappings map[string]any `json:"field_mappings,omitempty"`
	RemoteData    []*RemoteData  `json:"remote_data,omitempty"`
}

// The Merge ID of the employee with the ability to approve the time off request.
type TimeOffApprover struct {
	typeName string
	String   string
	Employee *Employee
}

func NewTimeOffApproverFromString(value string) *TimeOffApprover {
	return &TimeOffApprover{typeName: "string", String: value}
}

func NewTimeOffApproverFromEmployee(value *Employee) *TimeOffApprover {
	return &TimeOffApprover{typeName: "employee", Employee: value}
}

func (t *TimeOffApprover) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		t.typeName = "string"
		t.String = valueString
		return nil
	}
	valueEmployee := new(Employee)
	if err := json.Unmarshal(data, &valueEmployee); err == nil {
		t.typeName = "employee"
		t.Employee = valueEmployee
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, t)
}

func (t TimeOffApprover) MarshalJSON() ([]byte, error) {
	switch t.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", t.typeName, t)
	case "string":
		return json.Marshal(t.String)
	case "employee":
		return json.Marshal(t.Employee)
	}
}

type TimeOffApproverVisitor interface {
	VisitString(string) error
	VisitEmployee(*Employee) error
}

func (t *TimeOffApprover) Accept(visitor TimeOffApproverVisitor) error {
	switch t.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", t.typeName, t)
	case "string":
		return visitor.VisitString(t.String)
	case "employee":
		return visitor.VisitEmployee(t.Employee)
	}
}

// # The TimeOffBalance Object
//
// ### Description
//
// The `TimeOffBalance` object is used to represent current balances for an employee's Time Off plan.
//
// ### Usage Example
//
// Fetch from the `LIST TimeOffBalances` endpoint and filter by `ID` to show all time off balances.
type TimeOffBalance struct {
	Id *string `json:"id,omitempty"`
	// The third-party API ID of the matching object.
	RemoteId *string `json:"remote_id,omitempty"`
	// The employee the balance belongs to.
	Employee *TimeOffBalanceEmployee `json:"employee,omitempty"`
	// The current remaining PTO balance, always measured in terms of hours.
	Balance *float64 `json:"balance,omitempty"`
	// The amount of PTO used in terms of hours.
	Used *float64 `json:"used,omitempty"`
	// The policy type of this time off balance.
	//
	// - `VACATION` - VACATION
	// - `SICK` - SICK
	// - `PERSONAL` - PERSONAL
	// - `JURY_DUTY` - JURY_DUTY
	// - `VOLUNTEER` - VOLUNTEER
	// - `BEREAVEMENT` - BEREAVEMENT
	PolicyType *TimeOffBalancePolicyType `json:"policy_type,omitempty"`
	// Indicates whether or not this object has been deleted in the third party platform.
	RemoteWasDeleted *bool      `json:"remote_was_deleted,omitempty"`
	CreatedAt        *time.Time `json:"created_at,omitempty"`
	// This is the datetime that this object was last updated by Merge
	ModifiedAt    *time.Time     `json:"modified_at,omitempty"`
	FieldMappings map[string]any `json:"field_mappings,omitempty"`
	RemoteData    []*RemoteData  `json:"remote_data,omitempty"`
}

// The employee the balance belongs to.
type TimeOffBalanceEmployee struct {
	typeName string
	String   string
	Employee *Employee
}

func NewTimeOffBalanceEmployeeFromString(value string) *TimeOffBalanceEmployee {
	return &TimeOffBalanceEmployee{typeName: "string", String: value}
}

func NewTimeOffBalanceEmployeeFromEmployee(value *Employee) *TimeOffBalanceEmployee {
	return &TimeOffBalanceEmployee{typeName: "employee", Employee: value}
}

func (t *TimeOffBalanceEmployee) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		t.typeName = "string"
		t.String = valueString
		return nil
	}
	valueEmployee := new(Employee)
	if err := json.Unmarshal(data, &valueEmployee); err == nil {
		t.typeName = "employee"
		t.Employee = valueEmployee
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, t)
}

func (t TimeOffBalanceEmployee) MarshalJSON() ([]byte, error) {
	switch t.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", t.typeName, t)
	case "string":
		return json.Marshal(t.String)
	case "employee":
		return json.Marshal(t.Employee)
	}
}

type TimeOffBalanceEmployeeVisitor interface {
	VisitString(string) error
	VisitEmployee(*Employee) error
}

func (t *TimeOffBalanceEmployee) Accept(visitor TimeOffBalanceEmployeeVisitor) error {
	switch t.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", t.typeName, t)
	case "string":
		return visitor.VisitString(t.String)
	case "employee":
		return visitor.VisitEmployee(t.Employee)
	}
}

// The policy type of this time off balance.
//
// - `VACATION` - VACATION
// - `SICK` - SICK
// - `PERSONAL` - PERSONAL
// - `JURY_DUTY` - JURY_DUTY
// - `VOLUNTEER` - VOLUNTEER
// - `BEREAVEMENT` - BEREAVEMENT
type TimeOffBalancePolicyType struct {
	typeName       string
	PolicyTypeEnum PolicyTypeEnum
	String         string
}

func NewTimeOffBalancePolicyTypeFromPolicyTypeEnum(value PolicyTypeEnum) *TimeOffBalancePolicyType {
	return &TimeOffBalancePolicyType{typeName: "policyTypeEnum", PolicyTypeEnum: value}
}

func NewTimeOffBalancePolicyTypeFromString(value string) *TimeOffBalancePolicyType {
	return &TimeOffBalancePolicyType{typeName: "string", String: value}
}

func (t *TimeOffBalancePolicyType) UnmarshalJSON(data []byte) error {
	var valuePolicyTypeEnum PolicyTypeEnum
	if err := json.Unmarshal(data, &valuePolicyTypeEnum); err == nil {
		t.typeName = "policyTypeEnum"
		t.PolicyTypeEnum = valuePolicyTypeEnum
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		t.typeName = "string"
		t.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, t)
}

func (t TimeOffBalancePolicyType) MarshalJSON() ([]byte, error) {
	switch t.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", t.typeName, t)
	case "policyTypeEnum":
		return json.Marshal(t.PolicyTypeEnum)
	case "string":
		return json.Marshal(t.String)
	}
}

type TimeOffBalancePolicyTypeVisitor interface {
	VisitPolicyTypeEnum(PolicyTypeEnum) error
	VisitString(string) error
}

func (t *TimeOffBalancePolicyType) Accept(visitor TimeOffBalancePolicyTypeVisitor) error {
	switch t.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", t.typeName, t)
	case "policyTypeEnum":
		return visitor.VisitPolicyTypeEnum(t.PolicyTypeEnum)
	case "string":
		return visitor.VisitString(t.String)
	}
}

// The employee requesting time off.
type TimeOffEmployee struct {
	typeName string
	String   string
	Employee *Employee
}

func NewTimeOffEmployeeFromString(value string) *TimeOffEmployee {
	return &TimeOffEmployee{typeName: "string", String: value}
}

func NewTimeOffEmployeeFromEmployee(value *Employee) *TimeOffEmployee {
	return &TimeOffEmployee{typeName: "employee", Employee: value}
}

func (t *TimeOffEmployee) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		t.typeName = "string"
		t.String = valueString
		return nil
	}
	valueEmployee := new(Employee)
	if err := json.Unmarshal(data, &valueEmployee); err == nil {
		t.typeName = "employee"
		t.Employee = valueEmployee
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, t)
}

func (t TimeOffEmployee) MarshalJSON() ([]byte, error) {
	switch t.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", t.typeName, t)
	case "string":
		return json.Marshal(t.String)
	case "employee":
		return json.Marshal(t.Employee)
	}
}

type TimeOffEmployeeVisitor interface {
	VisitString(string) error
	VisitEmployee(*Employee) error
}

func (t *TimeOffEmployee) Accept(visitor TimeOffEmployeeVisitor) error {
	switch t.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", t.typeName, t)
	case "string":
		return visitor.VisitString(t.String)
	case "employee":
		return visitor.VisitEmployee(t.Employee)
	}
}

// # The TimeOff Object
//
// ### Description
//
// The `TimeOff` object is used to represent all employees' Time Off entries.
//
// ### Usage Example
//
// Fetch from the `LIST TimeOffs` endpoint and filter by `ID` to show all time off requests.
type TimeOffRequest struct {
	// The employee requesting time off.
	Employee *TimeOffRequestEmployee `json:"employee,omitempty"`
	// The Merge ID of the employee with the ability to approve the time off request.
	Approver *TimeOffRequestApprover `json:"approver,omitempty"`
	// The status of this time off request.
	//
	// - `REQUESTED` - REQUESTED
	// - `APPROVED` - APPROVED
	// - `DECLINED` - DECLINED
	// - `CANCELLED` - CANCELLED
	// - `DELETED` - DELETED
	Status *TimeOffRequestStatus `json:"status,omitempty"`
	// The employee note for this time off request.
	EmployeeNote *string `json:"employee_note,omitempty"`
	// The measurement that the third-party integration uses to count time requested.
	//
	// - `HOURS` - HOURS
	// - `DAYS` - DAYS
	Units *TimeOffRequestUnits `json:"units,omitempty"`
	// The time off quantity measured by the prescribed “units”.
	Amount *float64 `json:"amount,omitempty"`
	// The type of time off request.
	//
	// - `VACATION` - VACATION
	// - `SICK` - SICK
	// - `PERSONAL` - PERSONAL
	// - `JURY_DUTY` - JURY_DUTY
	// - `VOLUNTEER` - VOLUNTEER
	// - `BEREAVEMENT` - BEREAVEMENT
	RequestType *TimeOffRequestRequestType `json:"request_type,omitempty"`
	// The day and time of the start of the time requested off.
	StartTime *time.Time `json:"start_time,omitempty"`
	// The day and time of the end of the time requested off.
	EndTime             *time.Time     `json:"end_time,omitempty"`
	IntegrationParams   map[string]any `json:"integration_params,omitempty"`
	LinkedAccountParams map[string]any `json:"linked_account_params,omitempty"`
}

// The Merge ID of the employee with the ability to approve the time off request.
type TimeOffRequestApprover struct {
	typeName string
	String   string
	Employee *Employee
}

func NewTimeOffRequestApproverFromString(value string) *TimeOffRequestApprover {
	return &TimeOffRequestApprover{typeName: "string", String: value}
}

func NewTimeOffRequestApproverFromEmployee(value *Employee) *TimeOffRequestApprover {
	return &TimeOffRequestApprover{typeName: "employee", Employee: value}
}

func (t *TimeOffRequestApprover) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		t.typeName = "string"
		t.String = valueString
		return nil
	}
	valueEmployee := new(Employee)
	if err := json.Unmarshal(data, &valueEmployee); err == nil {
		t.typeName = "employee"
		t.Employee = valueEmployee
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, t)
}

func (t TimeOffRequestApprover) MarshalJSON() ([]byte, error) {
	switch t.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", t.typeName, t)
	case "string":
		return json.Marshal(t.String)
	case "employee":
		return json.Marshal(t.Employee)
	}
}

type TimeOffRequestApproverVisitor interface {
	VisitString(string) error
	VisitEmployee(*Employee) error
}

func (t *TimeOffRequestApprover) Accept(visitor TimeOffRequestApproverVisitor) error {
	switch t.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", t.typeName, t)
	case "string":
		return visitor.VisitString(t.String)
	case "employee":
		return visitor.VisitEmployee(t.Employee)
	}
}

// The employee requesting time off.
type TimeOffRequestEmployee struct {
	typeName string
	String   string
	Employee *Employee
}

func NewTimeOffRequestEmployeeFromString(value string) *TimeOffRequestEmployee {
	return &TimeOffRequestEmployee{typeName: "string", String: value}
}

func NewTimeOffRequestEmployeeFromEmployee(value *Employee) *TimeOffRequestEmployee {
	return &TimeOffRequestEmployee{typeName: "employee", Employee: value}
}

func (t *TimeOffRequestEmployee) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		t.typeName = "string"
		t.String = valueString
		return nil
	}
	valueEmployee := new(Employee)
	if err := json.Unmarshal(data, &valueEmployee); err == nil {
		t.typeName = "employee"
		t.Employee = valueEmployee
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, t)
}

func (t TimeOffRequestEmployee) MarshalJSON() ([]byte, error) {
	switch t.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", t.typeName, t)
	case "string":
		return json.Marshal(t.String)
	case "employee":
		return json.Marshal(t.Employee)
	}
}

type TimeOffRequestEmployeeVisitor interface {
	VisitString(string) error
	VisitEmployee(*Employee) error
}

func (t *TimeOffRequestEmployee) Accept(visitor TimeOffRequestEmployeeVisitor) error {
	switch t.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", t.typeName, t)
	case "string":
		return visitor.VisitString(t.String)
	case "employee":
		return visitor.VisitEmployee(t.Employee)
	}
}

// The type of time off request.
//
// - `VACATION` - VACATION
// - `SICK` - SICK
// - `PERSONAL` - PERSONAL
// - `JURY_DUTY` - JURY_DUTY
// - `VOLUNTEER` - VOLUNTEER
// - `BEREAVEMENT` - BEREAVEMENT
type TimeOffRequestRequestType struct {
	typeName        string
	RequestTypeEnum RequestTypeEnum
	String          string
}

func NewTimeOffRequestRequestTypeFromRequestTypeEnum(value RequestTypeEnum) *TimeOffRequestRequestType {
	return &TimeOffRequestRequestType{typeName: "requestTypeEnum", RequestTypeEnum: value}
}

func NewTimeOffRequestRequestTypeFromString(value string) *TimeOffRequestRequestType {
	return &TimeOffRequestRequestType{typeName: "string", String: value}
}

func (t *TimeOffRequestRequestType) UnmarshalJSON(data []byte) error {
	var valueRequestTypeEnum RequestTypeEnum
	if err := json.Unmarshal(data, &valueRequestTypeEnum); err == nil {
		t.typeName = "requestTypeEnum"
		t.RequestTypeEnum = valueRequestTypeEnum
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		t.typeName = "string"
		t.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, t)
}

func (t TimeOffRequestRequestType) MarshalJSON() ([]byte, error) {
	switch t.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", t.typeName, t)
	case "requestTypeEnum":
		return json.Marshal(t.RequestTypeEnum)
	case "string":
		return json.Marshal(t.String)
	}
}

type TimeOffRequestRequestTypeVisitor interface {
	VisitRequestTypeEnum(RequestTypeEnum) error
	VisitString(string) error
}

func (t *TimeOffRequestRequestType) Accept(visitor TimeOffRequestRequestTypeVisitor) error {
	switch t.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", t.typeName, t)
	case "requestTypeEnum":
		return visitor.VisitRequestTypeEnum(t.RequestTypeEnum)
	case "string":
		return visitor.VisitString(t.String)
	}
}

// The status of this time off request.
//
// - `REQUESTED` - REQUESTED
// - `APPROVED` - APPROVED
// - `DECLINED` - DECLINED
// - `CANCELLED` - CANCELLED
// - `DELETED` - DELETED
type TimeOffRequestStatus struct {
	typeName          string
	TimeOffStatusEnum TimeOffStatusEnum
	String            string
}

func NewTimeOffRequestStatusFromTimeOffStatusEnum(value TimeOffStatusEnum) *TimeOffRequestStatus {
	return &TimeOffRequestStatus{typeName: "timeOffStatusEnum", TimeOffStatusEnum: value}
}

func NewTimeOffRequestStatusFromString(value string) *TimeOffRequestStatus {
	return &TimeOffRequestStatus{typeName: "string", String: value}
}

func (t *TimeOffRequestStatus) UnmarshalJSON(data []byte) error {
	var valueTimeOffStatusEnum TimeOffStatusEnum
	if err := json.Unmarshal(data, &valueTimeOffStatusEnum); err == nil {
		t.typeName = "timeOffStatusEnum"
		t.TimeOffStatusEnum = valueTimeOffStatusEnum
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		t.typeName = "string"
		t.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, t)
}

func (t TimeOffRequestStatus) MarshalJSON() ([]byte, error) {
	switch t.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", t.typeName, t)
	case "timeOffStatusEnum":
		return json.Marshal(t.TimeOffStatusEnum)
	case "string":
		return json.Marshal(t.String)
	}
}

type TimeOffRequestStatusVisitor interface {
	VisitTimeOffStatusEnum(TimeOffStatusEnum) error
	VisitString(string) error
}

func (t *TimeOffRequestStatus) Accept(visitor TimeOffRequestStatusVisitor) error {
	switch t.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", t.typeName, t)
	case "timeOffStatusEnum":
		return visitor.VisitTimeOffStatusEnum(t.TimeOffStatusEnum)
	case "string":
		return visitor.VisitString(t.String)
	}
}

// The type of time off request.
//
// - `VACATION` - VACATION
// - `SICK` - SICK
// - `PERSONAL` - PERSONAL
// - `JURY_DUTY` - JURY_DUTY
// - `VOLUNTEER` - VOLUNTEER
// - `BEREAVEMENT` - BEREAVEMENT
type TimeOffRequestType struct {
	typeName        string
	RequestTypeEnum RequestTypeEnum
	String          string
}

func NewTimeOffRequestTypeFromRequestTypeEnum(value RequestTypeEnum) *TimeOffRequestType {
	return &TimeOffRequestType{typeName: "requestTypeEnum", RequestTypeEnum: value}
}

func NewTimeOffRequestTypeFromString(value string) *TimeOffRequestType {
	return &TimeOffRequestType{typeName: "string", String: value}
}

func (t *TimeOffRequestType) UnmarshalJSON(data []byte) error {
	var valueRequestTypeEnum RequestTypeEnum
	if err := json.Unmarshal(data, &valueRequestTypeEnum); err == nil {
		t.typeName = "requestTypeEnum"
		t.RequestTypeEnum = valueRequestTypeEnum
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		t.typeName = "string"
		t.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, t)
}

func (t TimeOffRequestType) MarshalJSON() ([]byte, error) {
	switch t.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", t.typeName, t)
	case "requestTypeEnum":
		return json.Marshal(t.RequestTypeEnum)
	case "string":
		return json.Marshal(t.String)
	}
}

type TimeOffRequestTypeVisitor interface {
	VisitRequestTypeEnum(RequestTypeEnum) error
	VisitString(string) error
}

func (t *TimeOffRequestType) Accept(visitor TimeOffRequestTypeVisitor) error {
	switch t.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", t.typeName, t)
	case "requestTypeEnum":
		return visitor.VisitRequestTypeEnum(t.RequestTypeEnum)
	case "string":
		return visitor.VisitString(t.String)
	}
}

// The measurement that the third-party integration uses to count time requested.
//
// - `HOURS` - HOURS
// - `DAYS` - DAYS
type TimeOffRequestUnits struct {
	typeName  string
	UnitsEnum UnitsEnum
	String    string
}

func NewTimeOffRequestUnitsFromUnitsEnum(value UnitsEnum) *TimeOffRequestUnits {
	return &TimeOffRequestUnits{typeName: "unitsEnum", UnitsEnum: value}
}

func NewTimeOffRequestUnitsFromString(value string) *TimeOffRequestUnits {
	return &TimeOffRequestUnits{typeName: "string", String: value}
}

func (t *TimeOffRequestUnits) UnmarshalJSON(data []byte) error {
	var valueUnitsEnum UnitsEnum
	if err := json.Unmarshal(data, &valueUnitsEnum); err == nil {
		t.typeName = "unitsEnum"
		t.UnitsEnum = valueUnitsEnum
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		t.typeName = "string"
		t.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, t)
}

func (t TimeOffRequestUnits) MarshalJSON() ([]byte, error) {
	switch t.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", t.typeName, t)
	case "unitsEnum":
		return json.Marshal(t.UnitsEnum)
	case "string":
		return json.Marshal(t.String)
	}
}

type TimeOffRequestUnitsVisitor interface {
	VisitUnitsEnum(UnitsEnum) error
	VisitString(string) error
}

func (t *TimeOffRequestUnits) Accept(visitor TimeOffRequestUnitsVisitor) error {
	switch t.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", t.typeName, t)
	case "unitsEnum":
		return visitor.VisitUnitsEnum(t.UnitsEnum)
	case "string":
		return visitor.VisitString(t.String)
	}
}

type TimeOffResponse struct {
	Model    *TimeOff                    `json:"model,omitempty"`
	Warnings []*WarningValidationProblem `json:"warnings,omitempty"`
	Errors   []*ErrorValidationProblem   `json:"errors,omitempty"`
	Logs     []*DebugModeLog             `json:"logs,omitempty"`
}

// The status of this time off request.
//
// - `REQUESTED` - REQUESTED
// - `APPROVED` - APPROVED
// - `DECLINED` - DECLINED
// - `CANCELLED` - CANCELLED
// - `DELETED` - DELETED
type TimeOffStatus struct {
	typeName          string
	TimeOffStatusEnum TimeOffStatusEnum
	String            string
}

func NewTimeOffStatusFromTimeOffStatusEnum(value TimeOffStatusEnum) *TimeOffStatus {
	return &TimeOffStatus{typeName: "timeOffStatusEnum", TimeOffStatusEnum: value}
}

func NewTimeOffStatusFromString(value string) *TimeOffStatus {
	return &TimeOffStatus{typeName: "string", String: value}
}

func (t *TimeOffStatus) UnmarshalJSON(data []byte) error {
	var valueTimeOffStatusEnum TimeOffStatusEnum
	if err := json.Unmarshal(data, &valueTimeOffStatusEnum); err == nil {
		t.typeName = "timeOffStatusEnum"
		t.TimeOffStatusEnum = valueTimeOffStatusEnum
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		t.typeName = "string"
		t.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, t)
}

func (t TimeOffStatus) MarshalJSON() ([]byte, error) {
	switch t.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", t.typeName, t)
	case "timeOffStatusEnum":
		return json.Marshal(t.TimeOffStatusEnum)
	case "string":
		return json.Marshal(t.String)
	}
}

type TimeOffStatusVisitor interface {
	VisitTimeOffStatusEnum(TimeOffStatusEnum) error
	VisitString(string) error
}

func (t *TimeOffStatus) Accept(visitor TimeOffStatusVisitor) error {
	switch t.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", t.typeName, t)
	case "timeOffStatusEnum":
		return visitor.VisitTimeOffStatusEnum(t.TimeOffStatusEnum)
	case "string":
		return visitor.VisitString(t.String)
	}
}

// - `REQUESTED` - REQUESTED
// - `APPROVED` - APPROVED
// - `DECLINED` - DECLINED
// - `CANCELLED` - CANCELLED
// - `DELETED` - DELETED
type TimeOffStatusEnum uint

const (
	TimeOffStatusEnumRequested TimeOffStatusEnum = iota + 1
	TimeOffStatusEnumApproved
	TimeOffStatusEnumDeclined
	TimeOffStatusEnumCancelled
	TimeOffStatusEnumDeleted
)

func (t TimeOffStatusEnum) String() string {
	switch t {
	default:
		return strconv.Itoa(int(t))
	case TimeOffStatusEnumRequested:
		return "REQUESTED"
	case TimeOffStatusEnumApproved:
		return "APPROVED"
	case TimeOffStatusEnumDeclined:
		return "DECLINED"
	case TimeOffStatusEnumCancelled:
		return "CANCELLED"
	case TimeOffStatusEnumDeleted:
		return "DELETED"
	}
}

func (t TimeOffStatusEnum) MarshalJSON() ([]byte, error) {
	return []byte(fmt.Sprintf("%q", t.String())), nil
}

func (t *TimeOffStatusEnum) UnmarshalJSON(data []byte) error {
	var raw string
	if err := json.Unmarshal(data, &raw); err != nil {
		return err
	}
	switch raw {
	case "REQUESTED":
		value := TimeOffStatusEnumRequested
		*t = value
	case "APPROVED":
		value := TimeOffStatusEnumApproved
		*t = value
	case "DECLINED":
		value := TimeOffStatusEnumDeclined
		*t = value
	case "CANCELLED":
		value := TimeOffStatusEnumCancelled
		*t = value
	case "DELETED":
		value := TimeOffStatusEnumDeleted
		*t = value
	}
	return nil
}

// The measurement that the third-party integration uses to count time requested.
//
// - `HOURS` - HOURS
// - `DAYS` - DAYS
type TimeOffUnits struct {
	typeName  string
	UnitsEnum UnitsEnum
	String    string
}

func NewTimeOffUnitsFromUnitsEnum(value UnitsEnum) *TimeOffUnits {
	return &TimeOffUnits{typeName: "unitsEnum", UnitsEnum: value}
}

func NewTimeOffUnitsFromString(value string) *TimeOffUnits {
	return &TimeOffUnits{typeName: "string", String: value}
}

func (t *TimeOffUnits) UnmarshalJSON(data []byte) error {
	var valueUnitsEnum UnitsEnum
	if err := json.Unmarshal(data, &valueUnitsEnum); err == nil {
		t.typeName = "unitsEnum"
		t.UnitsEnum = valueUnitsEnum
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		t.typeName = "string"
		t.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, t)
}

func (t TimeOffUnits) MarshalJSON() ([]byte, error) {
	switch t.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", t.typeName, t)
	case "unitsEnum":
		return json.Marshal(t.UnitsEnum)
	case "string":
		return json.Marshal(t.String)
	}
}

type TimeOffUnitsVisitor interface {
	VisitUnitsEnum(UnitsEnum) error
	VisitString(string) error
}

func (t *TimeOffUnits) Accept(visitor TimeOffUnitsVisitor) error {
	switch t.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", t.typeName, t)
	case "unitsEnum":
		return visitor.VisitUnitsEnum(t.UnitsEnum)
	case "string":
		return visitor.VisitString(t.String)
	}
}

// # The Timesheet Entry Object
//
// ### Description
//
// The `Timesheet Entry` object is used to track coverage for hours worked by an 'Employee'.
//
// ### Usage Example
//
// GET and POST Timesheet Entries
type TimesheetEntry struct {
	Id *string `json:"id,omitempty"`
	// The third-party API ID of the matching object.
	RemoteId *string `json:"remote_id,omitempty"`
	// The employee the timesheet entry is for.
	Employee *string `json:"employee,omitempty"`
	// The number of hours logged by the employee.
	HoursWorked *float64 `json:"hours_worked,omitempty"`
	// The time at which the employee started work.
	StartTime *time.Time `json:"start_time,omitempty"`
	// The time at which the employee ended work.
	EndTime   *time.Time `json:"end_time,omitempty"`
	CreatedAt *time.Time `json:"created_at,omitempty"`
	// This is the datetime that this object was last updated by Merge
	ModifiedAt *time.Time `json:"modified_at,omitempty"`
}

// # The Timesheet Entry Object
//
// ### Description
//
// The `Timesheet Entry` object is used to track coverage for hours worked by an 'Employee'.
//
// ### Usage Example
//
// GET and POST Timesheet Entries
type TimesheetEntryRequest struct {
	// The employee the timesheet entry is for.
	Employee *string `json:"employee,omitempty"`
	// The number of hours logged by the employee.
	HoursWorked *float64 `json:"hours_worked,omitempty"`
	// The time at which the employee started work.
	StartTime *time.Time `json:"start_time,omitempty"`
	// The time at which the employee ended work.
	EndTime             *time.Time     `json:"end_time,omitempty"`
	IntegrationParams   map[string]any `json:"integration_params,omitempty"`
	LinkedAccountParams map[string]any `json:"linked_account_params,omitempty"`
}

type TimesheetEntryResponse struct {
	Model    *TimesheetEntry             `json:"model,omitempty"`
	Warnings []*WarningValidationProblem `json:"warnings,omitempty"`
	Errors   []*ErrorValidationProblem   `json:"errors,omitempty"`
	Logs     []*DebugModeLog             `json:"logs,omitempty"`
}

// - `HOURS` - HOURS
// - `DAYS` - DAYS
type UnitsEnum uint

const (
	UnitsEnumHours UnitsEnum = iota + 1
	UnitsEnumDays
)

func (u UnitsEnum) String() string {
	switch u {
	default:
		return strconv.Itoa(int(u))
	case UnitsEnumHours:
		return "HOURS"
	case UnitsEnumDays:
		return "DAYS"
	}
}

func (u UnitsEnum) MarshalJSON() ([]byte, error) {
	return []byte(fmt.Sprintf("%q", u.String())), nil
}

func (u *UnitsEnum) UnmarshalJSON(data []byte) error {
	var raw string
	if err := json.Unmarshal(data, &raw); err != nil {
		return err
	}
	switch raw {
	case "HOURS":
		value := UnitsEnumHours
		*u = value
	case "DAYS":
		value := UnitsEnumDays
		*u = value
	}
	return nil
}

type ValidationProblemSource struct {
	Pointer string `json:"pointer"`
}

type WarningValidationProblem struct {
	Source      *ValidationProblemSource `json:"source,omitempty"`
	Title       string                   `json:"title"`
	Detail      string                   `json:"detail"`
	ProblemType string                   `json:"problem_type"`
}

type WebhookReceiver struct {
	Event    string  `json:"event"`
	IsActive bool    `json:"is_active"`
	Key      *string `json:"key,omitempty"`
}
