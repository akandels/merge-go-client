// This file was auto-generated by Fern from our API Definition.

package filestorage

import (
	json "encoding/json"
	fmt "fmt"
	strconv "strconv"
	time "time"
)

type AccountDetails struct {
	Id                      *string       `json:"id,omitempty"`
	Integration             *string       `json:"integration,omitempty"`
	IntegrationSlug         *string       `json:"integration_slug,omitempty"`
	Category                *CategoryEnum `json:"category,omitempty"`
	EndUserOriginId         *string       `json:"end_user_origin_id,omitempty"`
	EndUserOrganizationName *string       `json:"end_user_organization_name,omitempty"`
	EndUserEmailAddress     *string       `json:"end_user_email_address,omitempty"`
	Status                  *string       `json:"status,omitempty"`
	WebhookListenerUrl      *string       `json:"webhook_listener_url,omitempty"`
	// Whether a Production Linked Account's credentials match another existing Production Linked Account. This field is `null` for Test Linked Accounts, incomplete Production Linked Accounts, and ignored duplicate Production Linked Account sets.
	IsDuplicate *bool   `json:"is_duplicate,omitempty"`
	AccountType *string `json:"account_type,omitempty"`
}

// # The LinkedAccount Object
//
// ### Description
//
// The `LinkedAccount` object is used to represent an end user's link with a specific integration.
//
// ### Usage Example
//
// View a list of your organization's `LinkedAccount` objects.
type AccountDetailsAndActions struct {
	Id                      string                             `json:"id"`
	Category                *CategoryEnum                      `json:"category,omitempty"`
	Status                  AccountDetailsAndActionsStatusEnum `json:"status,omitempty"`
	StatusDetail            *string                            `json:"status_detail,omitempty"`
	EndUserOriginId         *string                            `json:"end_user_origin_id,omitempty"`
	EndUserOrganizationName string                             `json:"end_user_organization_name"`
	EndUserEmailAddress     string                             `json:"end_user_email_address"`
	WebhookListenerUrl      string                             `json:"webhook_listener_url"`
	// Whether a Production Linked Account's credentials match another existing Production Linked Account. This field is `null` for Test Linked Accounts, incomplete Production Linked Accounts, and ignored duplicate Production Linked Account sets.
	IsDuplicate *bool                                `json:"is_duplicate,omitempty"`
	Integration *AccountDetailsAndActionsIntegration `json:"integration,omitempty"`
	AccountType string                               `json:"account_type"`
}

type AccountDetailsAndActionsIntegration struct {
	Name                     string            `json:"name"`
	Categories               []CategoriesEnum  `json:"categories,omitempty"`
	Image                    *string           `json:"image,omitempty"`
	SquareImage              *string           `json:"square_image,omitempty"`
	Color                    string            `json:"color"`
	Slug                     string            `json:"slug"`
	PassthroughAvailable     bool              `json:"passthrough_available"`
	AvailableModelOperations []*ModelOperation `json:"available_model_operations,omitempty"`
}

// - `COMPLETE` - COMPLETE
// - `INCOMPLETE` - INCOMPLETE
// - `RELINK_NEEDED` - RELINK_NEEDED
type AccountDetailsAndActionsStatusEnum uint

const (
	AccountDetailsAndActionsStatusEnumComplete AccountDetailsAndActionsStatusEnum = iota + 1
	AccountDetailsAndActionsStatusEnumIncomplete
	AccountDetailsAndActionsStatusEnumRelinkNeeded
)

func (a AccountDetailsAndActionsStatusEnum) String() string {
	switch a {
	default:
		return strconv.Itoa(int(a))
	case AccountDetailsAndActionsStatusEnumComplete:
		return "COMPLETE"
	case AccountDetailsAndActionsStatusEnumIncomplete:
		return "INCOMPLETE"
	case AccountDetailsAndActionsStatusEnumRelinkNeeded:
		return "RELINK_NEEDED"
	}
}

func (a AccountDetailsAndActionsStatusEnum) MarshalJSON() ([]byte, error) {
	return []byte(fmt.Sprintf("%q", a.String())), nil
}

func (a *AccountDetailsAndActionsStatusEnum) UnmarshalJSON(data []byte) error {
	var raw string
	if err := json.Unmarshal(data, &raw); err != nil {
		return err
	}
	switch raw {
	case "COMPLETE":
		value := AccountDetailsAndActionsStatusEnumComplete
		*a = value
	case "INCOMPLETE":
		value := AccountDetailsAndActionsStatusEnumIncomplete
		*a = value
	case "RELINK_NEEDED":
		value := AccountDetailsAndActionsStatusEnumRelinkNeeded
		*a = value
	}
	return nil
}

type AccountIntegration struct {
	// Company name.
	Name string `json:"name"`
	// Category or categories this integration belongs to. Multiple categories should be comma separated, i.e. [ats, hris].
	Categories []CategoriesEnum `json:"categories,omitempty"`
	// Company logo in rectangular shape. <b>Upload an image with a clear background.</b>
	Image *string `json:"image,omitempty"`
	// Company logo in square shape. <b>Upload an image with a white background.</b>
	SquareImage *string `json:"square_image,omitempty"`
	// The color of this integration used for buttons and text throughout the app and landing pages. <b>Choose a darker, saturated color.</b>
	Color *string `json:"color,omitempty"`
	Slug  *string `json:"slug,omitempty"`
	// If checked, this integration will not appear in the linking flow, and will appear elsewhere with a Beta tag.
	IsInBeta *bool `json:"is_in_beta,omitempty"`
	// Mapping of API endpoints to documentation urls for support. Example: {'GET': [['/common-model-scopes', 'https://docs.merge.dev/accounting/common-model-scopes/#common_model_scopes_retrieve'],['/common-model-actions', 'https://docs.merge.dev/accounting/common-model-actions/#common_model_actions_retrieve']], 'POST': []}
	ApiEndpointsToDocumentationUrls map[string]any `json:"api_endpoints_to_documentation_urls,omitempty"`
	// Setup guide URL for third party webhook creation. Exposed in Merge Docs.
	WebhookSetupGuideUrl *string `json:"webhook_setup_guide_url,omitempty"`
}

type AccountToken struct {
	AccountToken string              `json:"account_token"`
	Integration  *AccountIntegration `json:"integration,omitempty"`
}

type AsyncPassthroughReciept struct {
	AsyncPassthroughReceiptId string `json:"async_passthrough_receipt_id"`
}

type AuditLogEvent struct {
	Id *string `json:"id,omitempty"`
	// The User's full name at the time of this Event occurring.
	UserName *string `json:"user_name,omitempty"`
	// The User's email at the time of this Event occurring.
	UserEmail *string `json:"user_email,omitempty"`
	// Designates the role of the user (or SYSTEM/API if action not taken by a user) at the time of this Event occurring.
	//
	// - `ADMIN` - ADMIN
	// - `DEVELOPER` - DEVELOPER
	// - `MEMBER` - MEMBER
	// - `API` - API
	// - `SYSTEM` - SYSTEM
	// - `MERGE_TEAM` - MERGE_TEAM
	Role      *AuditLogEventRole `json:"role,omitempty"`
	IpAddress string             `json:"ip_address"`
	// Designates the type of event that occurred.
	//
	// - `CREATED_REMOTE_PRODUCTION_API_KEY` - CREATED_REMOTE_PRODUCTION_API_KEY
	// - `DELETED_REMOTE_PRODUCTION_API_KEY` - DELETED_REMOTE_PRODUCTION_API_KEY
	// - `CREATED_TEST_API_KEY` - CREATED_TEST_API_KEY
	// - `DELETED_TEST_API_KEY` - DELETED_TEST_API_KEY
	// - `REGENERATED_PRODUCTION_API_KEY` - REGENERATED_PRODUCTION_API_KEY
	// - `INVITED_USER` - INVITED_USER
	// - `TWO_FACTOR_AUTH_ENABLED` - TWO_FACTOR_AUTH_ENABLED
	// - `TWO_FACTOR_AUTH_DISABLED` - TWO_FACTOR_AUTH_DISABLED
	// - `DELETED_LINKED_ACCOUNT` - DELETED_LINKED_ACCOUNT
	// - `CREATED_DESTINATION` - CREATED_DESTINATION
	// - `DELETED_DESTINATION` - DELETED_DESTINATION
	// - `CHANGED_SCOPES` - CHANGED_SCOPES
	// - `CHANGED_PERSONAL_INFORMATION` - CHANGED_PERSONAL_INFORMATION
	// - `CHANGED_ORGANIZATION_SETTINGS` - CHANGED_ORGANIZATION_SETTINGS
	// - `ENABLED_INTEGRATION` - ENABLED_INTEGRATION
	// - `DISABLED_INTEGRATION` - DISABLED_INTEGRATION
	// - `ENABLED_CATEGORY` - ENABLED_CATEGORY
	// - `DISABLED_CATEGORY` - DISABLED_CATEGORY
	// - `CHANGED_PASSWORD` - CHANGED_PASSWORD
	// - `RESET_PASSWORD` - RESET_PASSWORD
	// - `ENABLED_REDACT_UNMAPPED_DATA_FOR_ORGANIZATION` - ENABLED_REDACT_UNMAPPED_DATA_FOR_ORGANIZATION
	// - `ENABLED_REDACT_UNMAPPED_DATA_FOR_LINKED_ACCOUNT` - ENABLED_REDACT_UNMAPPED_DATA_FOR_LINKED_ACCOUNT
	// - `DISABLED_REDACT_UNMAPPED_DATA_FOR_ORGANIZATION` - DISABLED_REDACT_UNMAPPED_DATA_FOR_ORGANIZATION
	// - `DISABLED_REDACT_UNMAPPED_DATA_FOR_LINKED_ACCOUNT` - DISABLED_REDACT_UNMAPPED_DATA_FOR_LINKED_ACCOUNT
	// - `CREATED_INTEGRATION_WIDE_FIELD_MAPPING` - CREATED_INTEGRATION_WIDE_FIELD_MAPPING
	// - `CREATED_LINKED_ACCOUNT_FIELD_MAPPING` - CREATED_LINKED_ACCOUNT_FIELD_MAPPING
	// - `CHANGED_INTEGRATION_WIDE_FIELD_MAPPING` - CHANGED_INTEGRATION_WIDE_FIELD_MAPPING
	// - `CHANGED_LINKED_ACCOUNT_FIELD_MAPPING` - CHANGED_LINKED_ACCOUNT_FIELD_MAPPING
	// - `DELETED_INTEGRATION_WIDE_FIELD_MAPPING` - DELETED_INTEGRATION_WIDE_FIELD_MAPPING
	// - `DELETED_LINKED_ACCOUNT_FIELD_MAPPING` - DELETED_LINKED_ACCOUNT_FIELD_MAPPING
	EventType        *AuditLogEventEventType `json:"event_type,omitempty"`
	EventDescription string                  `json:"event_description"`
	CreatedAt        *time.Time              `json:"created_at,omitempty"`
}

// Designates the type of event that occurred.
//
// - `CREATED_REMOTE_PRODUCTION_API_KEY` - CREATED_REMOTE_PRODUCTION_API_KEY
// - `DELETED_REMOTE_PRODUCTION_API_KEY` - DELETED_REMOTE_PRODUCTION_API_KEY
// - `CREATED_TEST_API_KEY` - CREATED_TEST_API_KEY
// - `DELETED_TEST_API_KEY` - DELETED_TEST_API_KEY
// - `REGENERATED_PRODUCTION_API_KEY` - REGENERATED_PRODUCTION_API_KEY
// - `INVITED_USER` - INVITED_USER
// - `TWO_FACTOR_AUTH_ENABLED` - TWO_FACTOR_AUTH_ENABLED
// - `TWO_FACTOR_AUTH_DISABLED` - TWO_FACTOR_AUTH_DISABLED
// - `DELETED_LINKED_ACCOUNT` - DELETED_LINKED_ACCOUNT
// - `CREATED_DESTINATION` - CREATED_DESTINATION
// - `DELETED_DESTINATION` - DELETED_DESTINATION
// - `CHANGED_SCOPES` - CHANGED_SCOPES
// - `CHANGED_PERSONAL_INFORMATION` - CHANGED_PERSONAL_INFORMATION
// - `CHANGED_ORGANIZATION_SETTINGS` - CHANGED_ORGANIZATION_SETTINGS
// - `ENABLED_INTEGRATION` - ENABLED_INTEGRATION
// - `DISABLED_INTEGRATION` - DISABLED_INTEGRATION
// - `ENABLED_CATEGORY` - ENABLED_CATEGORY
// - `DISABLED_CATEGORY` - DISABLED_CATEGORY
// - `CHANGED_PASSWORD` - CHANGED_PASSWORD
// - `RESET_PASSWORD` - RESET_PASSWORD
// - `ENABLED_REDACT_UNMAPPED_DATA_FOR_ORGANIZATION` - ENABLED_REDACT_UNMAPPED_DATA_FOR_ORGANIZATION
// - `ENABLED_REDACT_UNMAPPED_DATA_FOR_LINKED_ACCOUNT` - ENABLED_REDACT_UNMAPPED_DATA_FOR_LINKED_ACCOUNT
// - `DISABLED_REDACT_UNMAPPED_DATA_FOR_ORGANIZATION` - DISABLED_REDACT_UNMAPPED_DATA_FOR_ORGANIZATION
// - `DISABLED_REDACT_UNMAPPED_DATA_FOR_LINKED_ACCOUNT` - DISABLED_REDACT_UNMAPPED_DATA_FOR_LINKED_ACCOUNT
// - `CREATED_INTEGRATION_WIDE_FIELD_MAPPING` - CREATED_INTEGRATION_WIDE_FIELD_MAPPING
// - `CREATED_LINKED_ACCOUNT_FIELD_MAPPING` - CREATED_LINKED_ACCOUNT_FIELD_MAPPING
// - `CHANGED_INTEGRATION_WIDE_FIELD_MAPPING` - CHANGED_INTEGRATION_WIDE_FIELD_MAPPING
// - `CHANGED_LINKED_ACCOUNT_FIELD_MAPPING` - CHANGED_LINKED_ACCOUNT_FIELD_MAPPING
// - `DELETED_INTEGRATION_WIDE_FIELD_MAPPING` - DELETED_INTEGRATION_WIDE_FIELD_MAPPING
// - `DELETED_LINKED_ACCOUNT_FIELD_MAPPING` - DELETED_LINKED_ACCOUNT_FIELD_MAPPING
type AuditLogEventEventType struct {
	typeName      string
	EventTypeEnum EventTypeEnum
	String        string
}

func NewAuditLogEventEventTypeFromEventTypeEnum(value EventTypeEnum) *AuditLogEventEventType {
	return &AuditLogEventEventType{typeName: "eventTypeEnum", EventTypeEnum: value}
}

func NewAuditLogEventEventTypeFromString(value string) *AuditLogEventEventType {
	return &AuditLogEventEventType{typeName: "string", String: value}
}

func (a *AuditLogEventEventType) UnmarshalJSON(data []byte) error {
	var valueEventTypeEnum EventTypeEnum
	if err := json.Unmarshal(data, &valueEventTypeEnum); err == nil {
		a.typeName = "eventTypeEnum"
		a.EventTypeEnum = valueEventTypeEnum
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		a.typeName = "string"
		a.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, a)
}

func (a AuditLogEventEventType) MarshalJSON() ([]byte, error) {
	switch a.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", a.typeName, a)
	case "eventTypeEnum":
		return json.Marshal(a.EventTypeEnum)
	case "string":
		return json.Marshal(a.String)
	}
}

type AuditLogEventEventTypeVisitor interface {
	VisitEventTypeEnum(EventTypeEnum) error
	VisitString(string) error
}

func (a *AuditLogEventEventType) Accept(visitor AuditLogEventEventTypeVisitor) error {
	switch a.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", a.typeName, a)
	case "eventTypeEnum":
		return visitor.VisitEventTypeEnum(a.EventTypeEnum)
	case "string":
		return visitor.VisitString(a.String)
	}
}

// Designates the role of the user (or SYSTEM/API if action not taken by a user) at the time of this Event occurring.
//
// - `ADMIN` - ADMIN
// - `DEVELOPER` - DEVELOPER
// - `MEMBER` - MEMBER
// - `API` - API
// - `SYSTEM` - SYSTEM
// - `MERGE_TEAM` - MERGE_TEAM
type AuditLogEventRole struct {
	typeName string
	RoleEnum RoleEnum
	String   string
}

func NewAuditLogEventRoleFromRoleEnum(value RoleEnum) *AuditLogEventRole {
	return &AuditLogEventRole{typeName: "roleEnum", RoleEnum: value}
}

func NewAuditLogEventRoleFromString(value string) *AuditLogEventRole {
	return &AuditLogEventRole{typeName: "string", String: value}
}

func (a *AuditLogEventRole) UnmarshalJSON(data []byte) error {
	var valueRoleEnum RoleEnum
	if err := json.Unmarshal(data, &valueRoleEnum); err == nil {
		a.typeName = "roleEnum"
		a.RoleEnum = valueRoleEnum
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		a.typeName = "string"
		a.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, a)
}

func (a AuditLogEventRole) MarshalJSON() ([]byte, error) {
	switch a.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", a.typeName, a)
	case "roleEnum":
		return json.Marshal(a.RoleEnum)
	case "string":
		return json.Marshal(a.String)
	}
}

type AuditLogEventRoleVisitor interface {
	VisitRoleEnum(RoleEnum) error
	VisitString(string) error
}

func (a *AuditLogEventRole) Accept(visitor AuditLogEventRoleVisitor) error {
	switch a.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", a.typeName, a)
	case "roleEnum":
		return visitor.VisitRoleEnum(a.RoleEnum)
	case "string":
		return visitor.VisitString(a.String)
	}
}

// # The AvailableActions Object
//
// ### Description
//
// The `Activity` object is used to see all available model/operation combinations for an integration.
//
// ### Usage Example
//
// Fetch all the actions available for the `Zenefits` integration.
type AvailableActions struct {
	Integration              *AccountIntegration `json:"integration,omitempty"`
	PassthroughAvailable     bool                `json:"passthrough_available"`
	AvailableModelOperations []*ModelOperation   `json:"available_model_operations,omitempty"`
}

// - `hris` - hris
// - `ats` - ats
// - `accounting` - accounting
// - `ticketing` - ticketing
// - `crm` - crm
// - `mktg` - mktg
// - `filestorage` - filestorage
type CategoriesEnum uint

const (
	CategoriesEnumHris CategoriesEnum = iota + 1
	CategoriesEnumAts
	CategoriesEnumAccounting
	CategoriesEnumTicketing
	CategoriesEnumCrm
	CategoriesEnumMktg
	CategoriesEnumFilestorage
)

func (c CategoriesEnum) String() string {
	switch c {
	default:
		return strconv.Itoa(int(c))
	case CategoriesEnumHris:
		return "hris"
	case CategoriesEnumAts:
		return "ats"
	case CategoriesEnumAccounting:
		return "accounting"
	case CategoriesEnumTicketing:
		return "ticketing"
	case CategoriesEnumCrm:
		return "crm"
	case CategoriesEnumMktg:
		return "mktg"
	case CategoriesEnumFilestorage:
		return "filestorage"
	}
}

func (c CategoriesEnum) MarshalJSON() ([]byte, error) {
	return []byte(fmt.Sprintf("%q", c.String())), nil
}

func (c *CategoriesEnum) UnmarshalJSON(data []byte) error {
	var raw string
	if err := json.Unmarshal(data, &raw); err != nil {
		return err
	}
	switch raw {
	case "hris":
		value := CategoriesEnumHris
		*c = value
	case "ats":
		value := CategoriesEnumAts
		*c = value
	case "accounting":
		value := CategoriesEnumAccounting
		*c = value
	case "ticketing":
		value := CategoriesEnumTicketing
		*c = value
	case "crm":
		value := CategoriesEnumCrm
		*c = value
	case "mktg":
		value := CategoriesEnumMktg
		*c = value
	case "filestorage":
		value := CategoriesEnumFilestorage
		*c = value
	}
	return nil
}

// - `hris` - hris
// - `ats` - ats
// - `accounting` - accounting
// - `ticketing` - ticketing
// - `crm` - crm
// - `mktg` - mktg
// - `filestorage` - filestorage
type CategoryEnum uint

const (
	CategoryEnumHris CategoryEnum = iota + 1
	CategoryEnumAts
	CategoryEnumAccounting
	CategoryEnumTicketing
	CategoryEnumCrm
	CategoryEnumMktg
	CategoryEnumFilestorage
)

func (c CategoryEnum) String() string {
	switch c {
	default:
		return strconv.Itoa(int(c))
	case CategoryEnumHris:
		return "hris"
	case CategoryEnumAts:
		return "ats"
	case CategoryEnumAccounting:
		return "accounting"
	case CategoryEnumTicketing:
		return "ticketing"
	case CategoryEnumCrm:
		return "crm"
	case CategoryEnumMktg:
		return "mktg"
	case CategoryEnumFilestorage:
		return "filestorage"
	}
}

func (c CategoryEnum) MarshalJSON() ([]byte, error) {
	return []byte(fmt.Sprintf("%q", c.String())), nil
}

func (c *CategoryEnum) UnmarshalJSON(data []byte) error {
	var raw string
	if err := json.Unmarshal(data, &raw); err != nil {
		return err
	}
	switch raw {
	case "hris":
		value := CategoryEnumHris
		*c = value
	case "ats":
		value := CategoryEnumAts
		*c = value
	case "accounting":
		value := CategoryEnumAccounting
		*c = value
	case "ticketing":
		value := CategoryEnumTicketing
		*c = value
	case "crm":
		value := CategoryEnumCrm
		*c = value
	case "mktg":
		value := CategoryEnumMktg
		*c = value
	case "filestorage":
		value := CategoryEnumFilestorage
		*c = value
	}
	return nil
}

type CommonModelScopesBodyRequest struct {
	ModelId        string               `json:"model_id"`
	EnabledActions []EnabledActionsEnum `json:"enabled_actions,omitempty"`
	DisabledFields []string             `json:"disabled_fields,omitempty"`
}

type ConditionSchema struct {
	// The ID of the condition schema. This ID is used when updating selective syncs for a linked account.
	Id string `json:"id"`
	// The common model for which a condition schema is defined.
	CommonModel *string `json:"common_model,omitempty"`
	// User-facing _native condition_ name. e.g. "Skip Manager".
	NativeName *string `json:"native_name,omitempty"`
	// The name of the field on the common model that this condition corresponds to, if they conceptually match. e.g. "location_type".
	FieldName *string `json:"field_name,omitempty"`
	// Whether this condition can only be applied once. If false, the condition can be AND'd together multiple times.
	IsUnique *bool `json:"is_unique,omitempty"`
	// The type of value(s) that can be set for this condition.
	//
	// - `BOOLEAN` - BOOLEAN
	// - `DATE` - DATE
	// - `DATE_TIME` - DATE_TIME
	// - `INTEGER` - INTEGER
	// - `FLOAT` - FLOAT
	// - `STRING` - STRING
	// - `LIST_OF_STRINGS` - LIST_OF_STRINGS
	ConditionType *ConditionSchemaConditionType `json:"condition_type,omitempty"`
	// The schemas for the operators that can be used on a condition.
	Operators []*OperatorSchema `json:"operators,omitempty"`
}

// The type of value(s) that can be set for this condition.
//
// - `BOOLEAN` - BOOLEAN
// - `DATE` - DATE
// - `DATE_TIME` - DATE_TIME
// - `INTEGER` - INTEGER
// - `FLOAT` - FLOAT
// - `STRING` - STRING
// - `LIST_OF_STRINGS` - LIST_OF_STRINGS
type ConditionSchemaConditionType struct {
	typeName          string
	ConditionTypeEnum ConditionTypeEnum
	String            string
}

func NewConditionSchemaConditionTypeFromConditionTypeEnum(value ConditionTypeEnum) *ConditionSchemaConditionType {
	return &ConditionSchemaConditionType{typeName: "conditionTypeEnum", ConditionTypeEnum: value}
}

func NewConditionSchemaConditionTypeFromString(value string) *ConditionSchemaConditionType {
	return &ConditionSchemaConditionType{typeName: "string", String: value}
}

func (c *ConditionSchemaConditionType) UnmarshalJSON(data []byte) error {
	var valueConditionTypeEnum ConditionTypeEnum
	if err := json.Unmarshal(data, &valueConditionTypeEnum); err == nil {
		c.typeName = "conditionTypeEnum"
		c.ConditionTypeEnum = valueConditionTypeEnum
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		c.typeName = "string"
		c.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, c)
}

func (c ConditionSchemaConditionType) MarshalJSON() ([]byte, error) {
	switch c.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", c.typeName, c)
	case "conditionTypeEnum":
		return json.Marshal(c.ConditionTypeEnum)
	case "string":
		return json.Marshal(c.String)
	}
}

type ConditionSchemaConditionTypeVisitor interface {
	VisitConditionTypeEnum(ConditionTypeEnum) error
	VisitString(string) error
}

func (c *ConditionSchemaConditionType) Accept(visitor ConditionSchemaConditionTypeVisitor) error {
	switch c.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", c.typeName, c)
	case "conditionTypeEnum":
		return visitor.VisitConditionTypeEnum(c.ConditionTypeEnum)
	case "string":
		return visitor.VisitString(c.String)
	}
}

// - `BOOLEAN` - BOOLEAN
// - `DATE` - DATE
// - `DATE_TIME` - DATE_TIME
// - `INTEGER` - INTEGER
// - `FLOAT` - FLOAT
// - `STRING` - STRING
// - `LIST_OF_STRINGS` - LIST_OF_STRINGS
type ConditionTypeEnum uint

const (
	ConditionTypeEnumBoolean ConditionTypeEnum = iota + 1
	ConditionTypeEnumDate
	ConditionTypeEnumDateTime
	ConditionTypeEnumInteger
	ConditionTypeEnumFloat
	ConditionTypeEnumString
	ConditionTypeEnumListOfStrings
)

func (c ConditionTypeEnum) String() string {
	switch c {
	default:
		return strconv.Itoa(int(c))
	case ConditionTypeEnumBoolean:
		return "BOOLEAN"
	case ConditionTypeEnumDate:
		return "DATE"
	case ConditionTypeEnumDateTime:
		return "DATE_TIME"
	case ConditionTypeEnumInteger:
		return "INTEGER"
	case ConditionTypeEnumFloat:
		return "FLOAT"
	case ConditionTypeEnumString:
		return "STRING"
	case ConditionTypeEnumListOfStrings:
		return "LIST_OF_STRINGS"
	}
}

func (c ConditionTypeEnum) MarshalJSON() ([]byte, error) {
	return []byte(fmt.Sprintf("%q", c.String())), nil
}

func (c *ConditionTypeEnum) UnmarshalJSON(data []byte) error {
	var raw string
	if err := json.Unmarshal(data, &raw); err != nil {
		return err
	}
	switch raw {
	case "BOOLEAN":
		value := ConditionTypeEnumBoolean
		*c = value
	case "DATE":
		value := ConditionTypeEnumDate
		*c = value
	case "DATE_TIME":
		value := ConditionTypeEnumDateTime
		*c = value
	case "INTEGER":
		value := ConditionTypeEnumInteger
		*c = value
	case "FLOAT":
		value := ConditionTypeEnumFloat
		*c = value
	case "STRING":
		value := ConditionTypeEnumString
		*c = value
	case "LIST_OF_STRINGS":
		value := ConditionTypeEnumListOfStrings
		*c = value
	}
	return nil
}

// # The DataPassthrough Object
//
// ### Description
//
// The `DataPassthrough` object is used to send information to an otherwise-unsupported third-party endpoint.
//
// ### Usage Example
//
// Create a `DataPassthrough` to get team hierarchies from your Rippling integration.
type DataPassthroughRequest struct {
	Method          MethodEnum `json:"method,omitempty"`
	Path            string     `json:"path"`
	BaseUrlOverride *string    `json:"base_url_override,omitempty"`
	Data            *string    `json:"data,omitempty"`
	// Pass an array of `MultipartFormField` objects in here instead of using the `data` param if `request_format` is set to `MULTIPART`.
	MultipartFormData []*MultipartFormFieldRequest `json:"multipart_form_data,omitempty"`
	// The headers to use for the request (Merge will handle the account's authorization headers). `Content-Type` header is required for passthrough. Choose content type corresponding to expected format of receiving server.
	Headers       map[string]any     `json:"headers,omitempty"`
	RequestFormat *RequestFormatEnum `json:"request_format,omitempty"`
	// Optional. If true, the response will always be an object of the form `{"type": T, "value": ...}` where `T` will be one of `string, boolean, number, null, array, object`.
	NormalizeResponse *bool `json:"normalize_response,omitempty"`
}

type DebugModeLog struct {
	LogId         string                `json:"log_id"`
	DashboardView string                `json:"dashboard_view"`
	LogSummary    *DebugModelLogSummary `json:"log_summary,omitempty"`
}

type DebugModelLogSummary struct {
	Url        string `json:"url"`
	Method     string `json:"method"`
	StatusCode int    `json:"status_code"`
}

// # The Drive Object
//
// ### Description
//
// The `Drive` object is used to represent a drive that contains the folders and files in the user's workspace.
//
// ### Usage Example
//
// Fetch from the `GET /api/filestorage/v1/drives` endpoint and view their drives.
type Drive struct {
	Id *string `json:"id,omitempty"`
	// The third-party API ID of the matching object.
	RemoteId *string `json:"remote_id,omitempty"`
	// The drive's name.
	Name *string `json:"name,omitempty"`
	// When the third party's drive was created.
	RemoteCreatedAt *time.Time `json:"remote_created_at,omitempty"`
	// The drive's url.
	DriveUrl *string `json:"drive_url,omitempty"`
	// Indicates whether or not this object has been deleted in the third party platform.
	RemoteWasDeleted *bool      `json:"remote_was_deleted,omitempty"`
	CreatedAt        *time.Time `json:"created_at,omitempty"`
	// This is the datetime that this object was last updated by Merge
	ModifiedAt    *time.Time       `json:"modified_at,omitempty"`
	FieldMappings map[string]any   `json:"field_mappings,omitempty"`
	RemoteData    []map[string]any `json:"remote_data,omitempty"`
}

// - `READ` - READ
// - `WRITE` - WRITE
type EnabledActionsEnum uint

const (
	EnabledActionsEnumRead EnabledActionsEnum = iota + 1
	EnabledActionsEnumWrite
)

func (e EnabledActionsEnum) String() string {
	switch e {
	default:
		return strconv.Itoa(int(e))
	case EnabledActionsEnumRead:
		return "READ"
	case EnabledActionsEnumWrite:
		return "WRITE"
	}
}

func (e EnabledActionsEnum) MarshalJSON() ([]byte, error) {
	return []byte(fmt.Sprintf("%q", e.String())), nil
}

func (e *EnabledActionsEnum) UnmarshalJSON(data []byte) error {
	var raw string
	if err := json.Unmarshal(data, &raw); err != nil {
		return err
	}
	switch raw {
	case "READ":
		value := EnabledActionsEnumRead
		*e = value
	case "WRITE":
		value := EnabledActionsEnumWrite
		*e = value
	}
	return nil
}

// - `RAW` - RAW
// - `BASE64` - BASE64
// - `GZIP_BASE64` - GZIP_BASE64
type EncodingEnum uint

const (
	EncodingEnumRaw EncodingEnum = iota + 1
	EncodingEnumBase64
	EncodingEnumGzipBase64
)

func (e EncodingEnum) String() string {
	switch e {
	default:
		return strconv.Itoa(int(e))
	case EncodingEnumRaw:
		return "RAW"
	case EncodingEnumBase64:
		return "BASE64"
	case EncodingEnumGzipBase64:
		return "GZIP_BASE64"
	}
}

func (e EncodingEnum) MarshalJSON() ([]byte, error) {
	return []byte(fmt.Sprintf("%q", e.String())), nil
}

func (e *EncodingEnum) UnmarshalJSON(data []byte) error {
	var raw string
	if err := json.Unmarshal(data, &raw); err != nil {
		return err
	}
	switch raw {
	case "RAW":
		value := EncodingEnumRaw
		*e = value
	case "BASE64":
		value := EncodingEnumBase64
		*e = value
	case "GZIP_BASE64":
		value := EncodingEnumGzipBase64
		*e = value
	}
	return nil
}

type ErrorValidationProblem struct {
	Source      *ValidationProblemSource `json:"source,omitempty"`
	Title       string                   `json:"title"`
	Detail      string                   `json:"detail"`
	ProblemType string                   `json:"problem_type"`
}

// - `CREATED_REMOTE_PRODUCTION_API_KEY` - CREATED_REMOTE_PRODUCTION_API_KEY
// - `DELETED_REMOTE_PRODUCTION_API_KEY` - DELETED_REMOTE_PRODUCTION_API_KEY
// - `CREATED_TEST_API_KEY` - CREATED_TEST_API_KEY
// - `DELETED_TEST_API_KEY` - DELETED_TEST_API_KEY
// - `REGENERATED_PRODUCTION_API_KEY` - REGENERATED_PRODUCTION_API_KEY
// - `INVITED_USER` - INVITED_USER
// - `TWO_FACTOR_AUTH_ENABLED` - TWO_FACTOR_AUTH_ENABLED
// - `TWO_FACTOR_AUTH_DISABLED` - TWO_FACTOR_AUTH_DISABLED
// - `DELETED_LINKED_ACCOUNT` - DELETED_LINKED_ACCOUNT
// - `CREATED_DESTINATION` - CREATED_DESTINATION
// - `DELETED_DESTINATION` - DELETED_DESTINATION
// - `CHANGED_SCOPES` - CHANGED_SCOPES
// - `CHANGED_PERSONAL_INFORMATION` - CHANGED_PERSONAL_INFORMATION
// - `CHANGED_ORGANIZATION_SETTINGS` - CHANGED_ORGANIZATION_SETTINGS
// - `ENABLED_INTEGRATION` - ENABLED_INTEGRATION
// - `DISABLED_INTEGRATION` - DISABLED_INTEGRATION
// - `ENABLED_CATEGORY` - ENABLED_CATEGORY
// - `DISABLED_CATEGORY` - DISABLED_CATEGORY
// - `CHANGED_PASSWORD` - CHANGED_PASSWORD
// - `RESET_PASSWORD` - RESET_PASSWORD
// - `ENABLED_REDACT_UNMAPPED_DATA_FOR_ORGANIZATION` - ENABLED_REDACT_UNMAPPED_DATA_FOR_ORGANIZATION
// - `ENABLED_REDACT_UNMAPPED_DATA_FOR_LINKED_ACCOUNT` - ENABLED_REDACT_UNMAPPED_DATA_FOR_LINKED_ACCOUNT
// - `DISABLED_REDACT_UNMAPPED_DATA_FOR_ORGANIZATION` - DISABLED_REDACT_UNMAPPED_DATA_FOR_ORGANIZATION
// - `DISABLED_REDACT_UNMAPPED_DATA_FOR_LINKED_ACCOUNT` - DISABLED_REDACT_UNMAPPED_DATA_FOR_LINKED_ACCOUNT
// - `CREATED_INTEGRATION_WIDE_FIELD_MAPPING` - CREATED_INTEGRATION_WIDE_FIELD_MAPPING
// - `CREATED_LINKED_ACCOUNT_FIELD_MAPPING` - CREATED_LINKED_ACCOUNT_FIELD_MAPPING
// - `CHANGED_INTEGRATION_WIDE_FIELD_MAPPING` - CHANGED_INTEGRATION_WIDE_FIELD_MAPPING
// - `CHANGED_LINKED_ACCOUNT_FIELD_MAPPING` - CHANGED_LINKED_ACCOUNT_FIELD_MAPPING
// - `DELETED_INTEGRATION_WIDE_FIELD_MAPPING` - DELETED_INTEGRATION_WIDE_FIELD_MAPPING
// - `DELETED_LINKED_ACCOUNT_FIELD_MAPPING` - DELETED_LINKED_ACCOUNT_FIELD_MAPPING
type EventTypeEnum uint

const (
	EventTypeEnumCreatedRemoteProductionApiKey EventTypeEnum = iota + 1
	EventTypeEnumDeletedRemoteProductionApiKey
	EventTypeEnumCreatedTestApiKey
	EventTypeEnumDeletedTestApiKey
	EventTypeEnumRegeneratedProductionApiKey
	EventTypeEnumInvitedUser
	EventTypeEnumTwoFactorAuthEnabled
	EventTypeEnumTwoFactorAuthDisabled
	EventTypeEnumDeletedLinkedAccount
	EventTypeEnumCreatedDestination
	EventTypeEnumDeletedDestination
	EventTypeEnumChangedScopes
	EventTypeEnumChangedPersonalInformation
	EventTypeEnumChangedOrganizationSettings
	EventTypeEnumEnabledIntegration
	EventTypeEnumDisabledIntegration
	EventTypeEnumEnabledCategory
	EventTypeEnumDisabledCategory
	EventTypeEnumChangedPassword
	EventTypeEnumResetPassword
	EventTypeEnumEnabledRedactUnmappedDataForOrganization
	EventTypeEnumEnabledRedactUnmappedDataForLinkedAccount
	EventTypeEnumDisabledRedactUnmappedDataForOrganization
	EventTypeEnumDisabledRedactUnmappedDataForLinkedAccount
	EventTypeEnumCreatedIntegrationWideFieldMapping
	EventTypeEnumCreatedLinkedAccountFieldMapping
	EventTypeEnumChangedIntegrationWideFieldMapping
	EventTypeEnumChangedLinkedAccountFieldMapping
	EventTypeEnumDeletedIntegrationWideFieldMapping
	EventTypeEnumDeletedLinkedAccountFieldMapping
)

func (e EventTypeEnum) String() string {
	switch e {
	default:
		return strconv.Itoa(int(e))
	case EventTypeEnumCreatedRemoteProductionApiKey:
		return "CREATED_REMOTE_PRODUCTION_API_KEY"
	case EventTypeEnumDeletedRemoteProductionApiKey:
		return "DELETED_REMOTE_PRODUCTION_API_KEY"
	case EventTypeEnumCreatedTestApiKey:
		return "CREATED_TEST_API_KEY"
	case EventTypeEnumDeletedTestApiKey:
		return "DELETED_TEST_API_KEY"
	case EventTypeEnumRegeneratedProductionApiKey:
		return "REGENERATED_PRODUCTION_API_KEY"
	case EventTypeEnumInvitedUser:
		return "INVITED_USER"
	case EventTypeEnumTwoFactorAuthEnabled:
		return "TWO_FACTOR_AUTH_ENABLED"
	case EventTypeEnumTwoFactorAuthDisabled:
		return "TWO_FACTOR_AUTH_DISABLED"
	case EventTypeEnumDeletedLinkedAccount:
		return "DELETED_LINKED_ACCOUNT"
	case EventTypeEnumCreatedDestination:
		return "CREATED_DESTINATION"
	case EventTypeEnumDeletedDestination:
		return "DELETED_DESTINATION"
	case EventTypeEnumChangedScopes:
		return "CHANGED_SCOPES"
	case EventTypeEnumChangedPersonalInformation:
		return "CHANGED_PERSONAL_INFORMATION"
	case EventTypeEnumChangedOrganizationSettings:
		return "CHANGED_ORGANIZATION_SETTINGS"
	case EventTypeEnumEnabledIntegration:
		return "ENABLED_INTEGRATION"
	case EventTypeEnumDisabledIntegration:
		return "DISABLED_INTEGRATION"
	case EventTypeEnumEnabledCategory:
		return "ENABLED_CATEGORY"
	case EventTypeEnumDisabledCategory:
		return "DISABLED_CATEGORY"
	case EventTypeEnumChangedPassword:
		return "CHANGED_PASSWORD"
	case EventTypeEnumResetPassword:
		return "RESET_PASSWORD"
	case EventTypeEnumEnabledRedactUnmappedDataForOrganization:
		return "ENABLED_REDACT_UNMAPPED_DATA_FOR_ORGANIZATION"
	case EventTypeEnumEnabledRedactUnmappedDataForLinkedAccount:
		return "ENABLED_REDACT_UNMAPPED_DATA_FOR_LINKED_ACCOUNT"
	case EventTypeEnumDisabledRedactUnmappedDataForOrganization:
		return "DISABLED_REDACT_UNMAPPED_DATA_FOR_ORGANIZATION"
	case EventTypeEnumDisabledRedactUnmappedDataForLinkedAccount:
		return "DISABLED_REDACT_UNMAPPED_DATA_FOR_LINKED_ACCOUNT"
	case EventTypeEnumCreatedIntegrationWideFieldMapping:
		return "CREATED_INTEGRATION_WIDE_FIELD_MAPPING"
	case EventTypeEnumCreatedLinkedAccountFieldMapping:
		return "CREATED_LINKED_ACCOUNT_FIELD_MAPPING"
	case EventTypeEnumChangedIntegrationWideFieldMapping:
		return "CHANGED_INTEGRATION_WIDE_FIELD_MAPPING"
	case EventTypeEnumChangedLinkedAccountFieldMapping:
		return "CHANGED_LINKED_ACCOUNT_FIELD_MAPPING"
	case EventTypeEnumDeletedIntegrationWideFieldMapping:
		return "DELETED_INTEGRATION_WIDE_FIELD_MAPPING"
	case EventTypeEnumDeletedLinkedAccountFieldMapping:
		return "DELETED_LINKED_ACCOUNT_FIELD_MAPPING"
	}
}

func (e EventTypeEnum) MarshalJSON() ([]byte, error) {
	return []byte(fmt.Sprintf("%q", e.String())), nil
}

func (e *EventTypeEnum) UnmarshalJSON(data []byte) error {
	var raw string
	if err := json.Unmarshal(data, &raw); err != nil {
		return err
	}
	switch raw {
	case "CREATED_REMOTE_PRODUCTION_API_KEY":
		value := EventTypeEnumCreatedRemoteProductionApiKey
		*e = value
	case "DELETED_REMOTE_PRODUCTION_API_KEY":
		value := EventTypeEnumDeletedRemoteProductionApiKey
		*e = value
	case "CREATED_TEST_API_KEY":
		value := EventTypeEnumCreatedTestApiKey
		*e = value
	case "DELETED_TEST_API_KEY":
		value := EventTypeEnumDeletedTestApiKey
		*e = value
	case "REGENERATED_PRODUCTION_API_KEY":
		value := EventTypeEnumRegeneratedProductionApiKey
		*e = value
	case "INVITED_USER":
		value := EventTypeEnumInvitedUser
		*e = value
	case "TWO_FACTOR_AUTH_ENABLED":
		value := EventTypeEnumTwoFactorAuthEnabled
		*e = value
	case "TWO_FACTOR_AUTH_DISABLED":
		value := EventTypeEnumTwoFactorAuthDisabled
		*e = value
	case "DELETED_LINKED_ACCOUNT":
		value := EventTypeEnumDeletedLinkedAccount
		*e = value
	case "CREATED_DESTINATION":
		value := EventTypeEnumCreatedDestination
		*e = value
	case "DELETED_DESTINATION":
		value := EventTypeEnumDeletedDestination
		*e = value
	case "CHANGED_SCOPES":
		value := EventTypeEnumChangedScopes
		*e = value
	case "CHANGED_PERSONAL_INFORMATION":
		value := EventTypeEnumChangedPersonalInformation
		*e = value
	case "CHANGED_ORGANIZATION_SETTINGS":
		value := EventTypeEnumChangedOrganizationSettings
		*e = value
	case "ENABLED_INTEGRATION":
		value := EventTypeEnumEnabledIntegration
		*e = value
	case "DISABLED_INTEGRATION":
		value := EventTypeEnumDisabledIntegration
		*e = value
	case "ENABLED_CATEGORY":
		value := EventTypeEnumEnabledCategory
		*e = value
	case "DISABLED_CATEGORY":
		value := EventTypeEnumDisabledCategory
		*e = value
	case "CHANGED_PASSWORD":
		value := EventTypeEnumChangedPassword
		*e = value
	case "RESET_PASSWORD":
		value := EventTypeEnumResetPassword
		*e = value
	case "ENABLED_REDACT_UNMAPPED_DATA_FOR_ORGANIZATION":
		value := EventTypeEnumEnabledRedactUnmappedDataForOrganization
		*e = value
	case "ENABLED_REDACT_UNMAPPED_DATA_FOR_LINKED_ACCOUNT":
		value := EventTypeEnumEnabledRedactUnmappedDataForLinkedAccount
		*e = value
	case "DISABLED_REDACT_UNMAPPED_DATA_FOR_ORGANIZATION":
		value := EventTypeEnumDisabledRedactUnmappedDataForOrganization
		*e = value
	case "DISABLED_REDACT_UNMAPPED_DATA_FOR_LINKED_ACCOUNT":
		value := EventTypeEnumDisabledRedactUnmappedDataForLinkedAccount
		*e = value
	case "CREATED_INTEGRATION_WIDE_FIELD_MAPPING":
		value := EventTypeEnumCreatedIntegrationWideFieldMapping
		*e = value
	case "CREATED_LINKED_ACCOUNT_FIELD_MAPPING":
		value := EventTypeEnumCreatedLinkedAccountFieldMapping
		*e = value
	case "CHANGED_INTEGRATION_WIDE_FIELD_MAPPING":
		value := EventTypeEnumChangedIntegrationWideFieldMapping
		*e = value
	case "CHANGED_LINKED_ACCOUNT_FIELD_MAPPING":
		value := EventTypeEnumChangedLinkedAccountFieldMapping
		*e = value
	case "DELETED_INTEGRATION_WIDE_FIELD_MAPPING":
		value := EventTypeEnumDeletedIntegrationWideFieldMapping
		*e = value
	case "DELETED_LINKED_ACCOUNT_FIELD_MAPPING":
		value := EventTypeEnumDeletedLinkedAccountFieldMapping
		*e = value
	}
	return nil
}

// # The File Object
//
// ### Description
//
// The `File` object is used to represent a file in the workspace. The Object typically exists under a folder or drive, if it exists.
//
// ### Usage Example
//
// Fetch from the `GET /api/filestorage/v1/files` endpoint and view their files.
type File struct {
	Id *string `json:"id,omitempty"`
	// The third-party API ID of the matching object.
	RemoteId *string `json:"remote_id,omitempty"`
	// The file's name.
	Name *string `json:"name,omitempty"`
	// The URL to access the file.
	FileUrl *string `json:"file_url,omitempty"`
	// The URL that produces a thumbnail preview of the file. Typically an image.
	FileThumbnailUrl *string `json:"file_thumbnail_url,omitempty"`
	// The file's size, in bytes.
	Size *int `json:"size,omitempty"`
	// The file's mime type.
	MimeType *string `json:"mime_type,omitempty"`
	// The file's description.
	Description *string `json:"description,omitempty"`
	// The folder that the file belongs to.
	Folder *FileFolder `json:"folder,omitempty"`
	// The Permission object is used to represent a user's or group's access to a File or Folder. Permissions are unexpanded by default. Use the query param `expand=permissions` to see more details under `GET /files`.
	Permissions *FilePermissions `json:"permissions,omitempty"`
	// The drive that the file belongs to.
	Drive *FileDrive `json:"drive,omitempty"`
	// When the third party's file was created.
	RemoteCreatedAt *time.Time `json:"remote_created_at,omitempty"`
	// When the third party's file was updated.
	RemoteUpdatedAt *time.Time `json:"remote_updated_at,omitempty"`
	// Indicates whether or not this object has been deleted in the third party platform.
	RemoteWasDeleted *bool      `json:"remote_was_deleted,omitempty"`
	CreatedAt        *time.Time `json:"created_at,omitempty"`
	// This is the datetime that this object was last updated by Merge
	ModifiedAt    *time.Time       `json:"modified_at,omitempty"`
	FieldMappings map[string]any   `json:"field_mappings,omitempty"`
	RemoteData    []map[string]any `json:"remote_data,omitempty"`
}

// The drive that the file belongs to.
type FileDrive struct {
	typeName string
	String   string
	Drive    *Drive
}

func NewFileDriveFromString(value string) *FileDrive {
	return &FileDrive{typeName: "string", String: value}
}

func NewFileDriveFromDrive(value *Drive) *FileDrive {
	return &FileDrive{typeName: "drive", Drive: value}
}

func (f *FileDrive) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		f.typeName = "string"
		f.String = valueString
		return nil
	}
	valueDrive := new(Drive)
	if err := json.Unmarshal(data, &valueDrive); err == nil {
		f.typeName = "drive"
		f.Drive = valueDrive
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, f)
}

func (f FileDrive) MarshalJSON() ([]byte, error) {
	switch f.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", f.typeName, f)
	case "string":
		return json.Marshal(f.String)
	case "drive":
		return json.Marshal(f.Drive)
	}
}

type FileDriveVisitor interface {
	VisitString(string) error
	VisitDrive(*Drive) error
}

func (f *FileDrive) Accept(visitor FileDriveVisitor) error {
	switch f.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", f.typeName, f)
	case "string":
		return visitor.VisitString(f.String)
	case "drive":
		return visitor.VisitDrive(f.Drive)
	}
}

// The folder that the file belongs to.
type FileFolder struct {
	typeName string
	String   string
	Folder   *Folder
}

func NewFileFolderFromString(value string) *FileFolder {
	return &FileFolder{typeName: "string", String: value}
}

func NewFileFolderFromFolder(value *Folder) *FileFolder {
	return &FileFolder{typeName: "folder", Folder: value}
}

func (f *FileFolder) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		f.typeName = "string"
		f.String = valueString
		return nil
	}
	valueFolder := new(Folder)
	if err := json.Unmarshal(data, &valueFolder); err == nil {
		f.typeName = "folder"
		f.Folder = valueFolder
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, f)
}

func (f FileFolder) MarshalJSON() ([]byte, error) {
	switch f.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", f.typeName, f)
	case "string":
		return json.Marshal(f.String)
	case "folder":
		return json.Marshal(f.Folder)
	}
}

type FileFolderVisitor interface {
	VisitString(string) error
	VisitFolder(*Folder) error
}

func (f *FileFolder) Accept(visitor FileFolderVisitor) error {
	switch f.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", f.typeName, f)
	case "string":
		return visitor.VisitString(f.String)
	case "folder":
		return visitor.VisitFolder(f.Folder)
	}
}

// The Permission object is used to represent a user's or group's access to a File or Folder. Permissions are unexpanded by default. Use the query param `expand=permissions` to see more details under `GET /files`.
type FilePermissions struct {
	typeName                string
	String                  string
	Unknown                 any
	FilePermissionsItemList []*FilePermissionsItem
}

func NewFilePermissionsFromString(value string) *FilePermissions {
	return &FilePermissions{typeName: "string", String: value}
}

func NewFilePermissionsFromUnknown(value any) *FilePermissions {
	return &FilePermissions{typeName: "unknown", Unknown: value}
}

func NewFilePermissionsFromFilePermissionsItemList(value []*FilePermissionsItem) *FilePermissions {
	return &FilePermissions{typeName: "filePermissionsItemList", FilePermissionsItemList: value}
}

func (f *FilePermissions) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		f.typeName = "string"
		f.String = valueString
		return nil
	}
	var valueUnknown any
	if err := json.Unmarshal(data, &valueUnknown); err == nil {
		f.typeName = "unknown"
		f.Unknown = valueUnknown
		return nil
	}
	var valueFilePermissionsItemList []*FilePermissionsItem
	if err := json.Unmarshal(data, &valueFilePermissionsItemList); err == nil {
		f.typeName = "filePermissionsItemList"
		f.FilePermissionsItemList = valueFilePermissionsItemList
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, f)
}

func (f FilePermissions) MarshalJSON() ([]byte, error) {
	switch f.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", f.typeName, f)
	case "string":
		return json.Marshal(f.String)
	case "unknown":
		return json.Marshal(f.Unknown)
	case "filePermissionsItemList":
		return json.Marshal(f.FilePermissionsItemList)
	}
}

type FilePermissionsVisitor interface {
	VisitString(string) error
	VisitUnknown(any) error
	VisitFilePermissionsItemList([]*FilePermissionsItem) error
}

func (f *FilePermissions) Accept(visitor FilePermissionsVisitor) error {
	switch f.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", f.typeName, f)
	case "string":
		return visitor.VisitString(f.String)
	case "unknown":
		return visitor.VisitUnknown(f.Unknown)
	case "filePermissionsItemList":
		return visitor.VisitFilePermissionsItemList(f.FilePermissionsItemList)
	}
}

type FilePermissionsItem struct {
	typeName          string
	String            string
	PermissionRequest *PermissionRequest
}

func NewFilePermissionsItemFromString(value string) *FilePermissionsItem {
	return &FilePermissionsItem{typeName: "string", String: value}
}

func NewFilePermissionsItemFromPermissionRequest(value *PermissionRequest) *FilePermissionsItem {
	return &FilePermissionsItem{typeName: "permissionRequest", PermissionRequest: value}
}

func (f *FilePermissionsItem) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		f.typeName = "string"
		f.String = valueString
		return nil
	}
	valuePermissionRequest := new(PermissionRequest)
	if err := json.Unmarshal(data, &valuePermissionRequest); err == nil {
		f.typeName = "permissionRequest"
		f.PermissionRequest = valuePermissionRequest
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, f)
}

func (f FilePermissionsItem) MarshalJSON() ([]byte, error) {
	switch f.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", f.typeName, f)
	case "string":
		return json.Marshal(f.String)
	case "permissionRequest":
		return json.Marshal(f.PermissionRequest)
	}
}

type FilePermissionsItemVisitor interface {
	VisitString(string) error
	VisitPermissionRequest(*PermissionRequest) error
}

func (f *FilePermissionsItem) Accept(visitor FilePermissionsItemVisitor) error {
	switch f.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", f.typeName, f)
	case "string":
		return visitor.VisitString(f.String)
	case "permissionRequest":
		return visitor.VisitPermissionRequest(f.PermissionRequest)
	}
}

// # The File Object
//
// ### Description
//
// The `File` object is used to represent a file in the workspace. The Object typically exists under a folder or drive, if it exists.
//
// ### Usage Example
//
// Fetch from the `GET /api/filestorage/v1/files` endpoint and view their files.
type FileRequest struct {
	// The file's name.
	Name *string `json:"name,omitempty"`
	// The URL to access the file.
	FileUrl *string `json:"file_url,omitempty"`
	// The URL that produces a thumbnail preview of the file. Typically an image.
	FileThumbnailUrl *string `json:"file_thumbnail_url,omitempty"`
	// The file's size, in bytes.
	Size *int `json:"size,omitempty"`
	// The file's mime type.
	MimeType *string `json:"mime_type,omitempty"`
	// The file's description.
	Description *string `json:"description,omitempty"`
	// The folder that the file belongs to.
	Folder *FileRequestFolder `json:"folder,omitempty"`
	// The Permission object is used to represent a user's or group's access to a File or Folder. Permissions are unexpanded by default. Use the query param `expand=permissions` to see more details under `GET /files`.
	Permissions *FileRequestPermissions `json:"permissions,omitempty"`
	// The drive that the file belongs to.
	Drive               *FileRequestDrive `json:"drive,omitempty"`
	IntegrationParams   map[string]any    `json:"integration_params,omitempty"`
	LinkedAccountParams map[string]any    `json:"linked_account_params,omitempty"`
}

// The drive that the file belongs to.
type FileRequestDrive struct {
	typeName string
	String   string
	Drive    *Drive
}

func NewFileRequestDriveFromString(value string) *FileRequestDrive {
	return &FileRequestDrive{typeName: "string", String: value}
}

func NewFileRequestDriveFromDrive(value *Drive) *FileRequestDrive {
	return &FileRequestDrive{typeName: "drive", Drive: value}
}

func (f *FileRequestDrive) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		f.typeName = "string"
		f.String = valueString
		return nil
	}
	valueDrive := new(Drive)
	if err := json.Unmarshal(data, &valueDrive); err == nil {
		f.typeName = "drive"
		f.Drive = valueDrive
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, f)
}

func (f FileRequestDrive) MarshalJSON() ([]byte, error) {
	switch f.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", f.typeName, f)
	case "string":
		return json.Marshal(f.String)
	case "drive":
		return json.Marshal(f.Drive)
	}
}

type FileRequestDriveVisitor interface {
	VisitString(string) error
	VisitDrive(*Drive) error
}

func (f *FileRequestDrive) Accept(visitor FileRequestDriveVisitor) error {
	switch f.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", f.typeName, f)
	case "string":
		return visitor.VisitString(f.String)
	case "drive":
		return visitor.VisitDrive(f.Drive)
	}
}

// The folder that the file belongs to.
type FileRequestFolder struct {
	typeName string
	String   string
	Folder   *Folder
}

func NewFileRequestFolderFromString(value string) *FileRequestFolder {
	return &FileRequestFolder{typeName: "string", String: value}
}

func NewFileRequestFolderFromFolder(value *Folder) *FileRequestFolder {
	return &FileRequestFolder{typeName: "folder", Folder: value}
}

func (f *FileRequestFolder) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		f.typeName = "string"
		f.String = valueString
		return nil
	}
	valueFolder := new(Folder)
	if err := json.Unmarshal(data, &valueFolder); err == nil {
		f.typeName = "folder"
		f.Folder = valueFolder
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, f)
}

func (f FileRequestFolder) MarshalJSON() ([]byte, error) {
	switch f.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", f.typeName, f)
	case "string":
		return json.Marshal(f.String)
	case "folder":
		return json.Marshal(f.Folder)
	}
}

type FileRequestFolderVisitor interface {
	VisitString(string) error
	VisitFolder(*Folder) error
}

func (f *FileRequestFolder) Accept(visitor FileRequestFolderVisitor) error {
	switch f.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", f.typeName, f)
	case "string":
		return visitor.VisitString(f.String)
	case "folder":
		return visitor.VisitFolder(f.Folder)
	}
}

// The Permission object is used to represent a user's or group's access to a File or Folder. Permissions are unexpanded by default. Use the query param `expand=permissions` to see more details under `GET /files`.
type FileRequestPermissions struct {
	typeName                       string
	String                         string
	Unknown                        any
	FileRequestPermissionsItemList []*FileRequestPermissionsItem
}

func NewFileRequestPermissionsFromString(value string) *FileRequestPermissions {
	return &FileRequestPermissions{typeName: "string", String: value}
}

func NewFileRequestPermissionsFromUnknown(value any) *FileRequestPermissions {
	return &FileRequestPermissions{typeName: "unknown", Unknown: value}
}

func NewFileRequestPermissionsFromFileRequestPermissionsItemList(value []*FileRequestPermissionsItem) *FileRequestPermissions {
	return &FileRequestPermissions{typeName: "fileRequestPermissionsItemList", FileRequestPermissionsItemList: value}
}

func (f *FileRequestPermissions) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		f.typeName = "string"
		f.String = valueString
		return nil
	}
	var valueUnknown any
	if err := json.Unmarshal(data, &valueUnknown); err == nil {
		f.typeName = "unknown"
		f.Unknown = valueUnknown
		return nil
	}
	var valueFileRequestPermissionsItemList []*FileRequestPermissionsItem
	if err := json.Unmarshal(data, &valueFileRequestPermissionsItemList); err == nil {
		f.typeName = "fileRequestPermissionsItemList"
		f.FileRequestPermissionsItemList = valueFileRequestPermissionsItemList
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, f)
}

func (f FileRequestPermissions) MarshalJSON() ([]byte, error) {
	switch f.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", f.typeName, f)
	case "string":
		return json.Marshal(f.String)
	case "unknown":
		return json.Marshal(f.Unknown)
	case "fileRequestPermissionsItemList":
		return json.Marshal(f.FileRequestPermissionsItemList)
	}
}

type FileRequestPermissionsVisitor interface {
	VisitString(string) error
	VisitUnknown(any) error
	VisitFileRequestPermissionsItemList([]*FileRequestPermissionsItem) error
}

func (f *FileRequestPermissions) Accept(visitor FileRequestPermissionsVisitor) error {
	switch f.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", f.typeName, f)
	case "string":
		return visitor.VisitString(f.String)
	case "unknown":
		return visitor.VisitUnknown(f.Unknown)
	case "fileRequestPermissionsItemList":
		return visitor.VisitFileRequestPermissionsItemList(f.FileRequestPermissionsItemList)
	}
}

type FileRequestPermissionsItem struct {
	typeName          string
	String            string
	PermissionRequest *PermissionRequest
}

func NewFileRequestPermissionsItemFromString(value string) *FileRequestPermissionsItem {
	return &FileRequestPermissionsItem{typeName: "string", String: value}
}

func NewFileRequestPermissionsItemFromPermissionRequest(value *PermissionRequest) *FileRequestPermissionsItem {
	return &FileRequestPermissionsItem{typeName: "permissionRequest", PermissionRequest: value}
}

func (f *FileRequestPermissionsItem) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		f.typeName = "string"
		f.String = valueString
		return nil
	}
	valuePermissionRequest := new(PermissionRequest)
	if err := json.Unmarshal(data, &valuePermissionRequest); err == nil {
		f.typeName = "permissionRequest"
		f.PermissionRequest = valuePermissionRequest
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, f)
}

func (f FileRequestPermissionsItem) MarshalJSON() ([]byte, error) {
	switch f.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", f.typeName, f)
	case "string":
		return json.Marshal(f.String)
	case "permissionRequest":
		return json.Marshal(f.PermissionRequest)
	}
}

type FileRequestPermissionsItemVisitor interface {
	VisitString(string) error
	VisitPermissionRequest(*PermissionRequest) error
}

func (f *FileRequestPermissionsItem) Accept(visitor FileRequestPermissionsItemVisitor) error {
	switch f.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", f.typeName, f)
	case "string":
		return visitor.VisitString(f.String)
	case "permissionRequest":
		return visitor.VisitPermissionRequest(f.PermissionRequest)
	}
}

type FileStorageFileResponse struct {
	Model    *File                       `json:"model,omitempty"`
	Warnings []*WarningValidationProblem `json:"warnings,omitempty"`
	Errors   []*ErrorValidationProblem   `json:"errors,omitempty"`
	Logs     []*DebugModeLog             `json:"logs,omitempty"`
}

type FileStorageFolderResponse struct {
	Model    *Folder                     `json:"model,omitempty"`
	Warnings []*WarningValidationProblem `json:"warnings,omitempty"`
	Errors   []*ErrorValidationProblem   `json:"errors,omitempty"`
	Logs     []*DebugModeLog             `json:"logs,omitempty"`
}

// # The Folder Object
//
// ### Description
//
// The `Folder` object is used to represent a collection of files and/or folders in the workspace. Could be within a drive, if it exists.
//
// ### Usage Example
//
// Fetch from the `GET /api/filestorage/v1/folders` endpoint and view their folders.
type Folder struct {
	Id *string `json:"id,omitempty"`
	// The third-party API ID of the matching object.
	RemoteId *string `json:"remote_id,omitempty"`
	// The folder's name.
	Name *string `json:"name,omitempty"`
	// The URL to access the folder.
	FolderUrl *string `json:"folder_url,omitempty"`
	// The folder's size, in bytes.
	Size *int `json:"size,omitempty"`
	// The folder's description.
	Description *string `json:"description,omitempty"`
	// The folder that the folder belongs to.
	ParentFolder *FolderParentFolder `json:"parent_folder,omitempty"`
	// The drive that the folder belongs to.
	Drive *FolderDrive `json:"drive,omitempty"`
	// The Permission object is used to represent a user's or group's access to a File or Folder. Permissions are unexpanded by default. Use the query param `expand=permissions` to see more details under `GET /folders`.
	Permissions *FolderPermissions `json:"permissions,omitempty"`
	// When the third party's folder was created.
	RemoteCreatedAt *time.Time `json:"remote_created_at,omitempty"`
	// When the third party's folder was updated.
	RemoteUpdatedAt *time.Time `json:"remote_updated_at,omitempty"`
	// Indicates whether or not this object has been deleted in the third party platform.
	RemoteWasDeleted *bool      `json:"remote_was_deleted,omitempty"`
	CreatedAt        *time.Time `json:"created_at,omitempty"`
	// This is the datetime that this object was last updated by Merge
	ModifiedAt    *time.Time       `json:"modified_at,omitempty"`
	FieldMappings map[string]any   `json:"field_mappings,omitempty"`
	RemoteData    []map[string]any `json:"remote_data,omitempty"`
}

// The drive that the folder belongs to.
type FolderDrive struct {
	typeName string
	String   string
	Drive    *Drive
}

func NewFolderDriveFromString(value string) *FolderDrive {
	return &FolderDrive{typeName: "string", String: value}
}

func NewFolderDriveFromDrive(value *Drive) *FolderDrive {
	return &FolderDrive{typeName: "drive", Drive: value}
}

func (f *FolderDrive) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		f.typeName = "string"
		f.String = valueString
		return nil
	}
	valueDrive := new(Drive)
	if err := json.Unmarshal(data, &valueDrive); err == nil {
		f.typeName = "drive"
		f.Drive = valueDrive
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, f)
}

func (f FolderDrive) MarshalJSON() ([]byte, error) {
	switch f.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", f.typeName, f)
	case "string":
		return json.Marshal(f.String)
	case "drive":
		return json.Marshal(f.Drive)
	}
}

type FolderDriveVisitor interface {
	VisitString(string) error
	VisitDrive(*Drive) error
}

func (f *FolderDrive) Accept(visitor FolderDriveVisitor) error {
	switch f.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", f.typeName, f)
	case "string":
		return visitor.VisitString(f.String)
	case "drive":
		return visitor.VisitDrive(f.Drive)
	}
}

// The folder that the folder belongs to.
type FolderParentFolder struct {
	typeName string
	String   string
	Folder   *Folder
}

func NewFolderParentFolderFromString(value string) *FolderParentFolder {
	return &FolderParentFolder{typeName: "string", String: value}
}

func NewFolderParentFolderFromFolder(value *Folder) *FolderParentFolder {
	return &FolderParentFolder{typeName: "folder", Folder: value}
}

func (f *FolderParentFolder) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		f.typeName = "string"
		f.String = valueString
		return nil
	}
	valueFolder := new(Folder)
	if err := json.Unmarshal(data, &valueFolder); err == nil {
		f.typeName = "folder"
		f.Folder = valueFolder
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, f)
}

func (f FolderParentFolder) MarshalJSON() ([]byte, error) {
	switch f.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", f.typeName, f)
	case "string":
		return json.Marshal(f.String)
	case "folder":
		return json.Marshal(f.Folder)
	}
}

type FolderParentFolderVisitor interface {
	VisitString(string) error
	VisitFolder(*Folder) error
}

func (f *FolderParentFolder) Accept(visitor FolderParentFolderVisitor) error {
	switch f.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", f.typeName, f)
	case "string":
		return visitor.VisitString(f.String)
	case "folder":
		return visitor.VisitFolder(f.Folder)
	}
}

// The Permission object is used to represent a user's or group's access to a File or Folder. Permissions are unexpanded by default. Use the query param `expand=permissions` to see more details under `GET /folders`.
type FolderPermissions struct {
	typeName                  string
	String                    string
	Unknown                   any
	FolderPermissionsItemList []*FolderPermissionsItem
}

func NewFolderPermissionsFromString(value string) *FolderPermissions {
	return &FolderPermissions{typeName: "string", String: value}
}

func NewFolderPermissionsFromUnknown(value any) *FolderPermissions {
	return &FolderPermissions{typeName: "unknown", Unknown: value}
}

func NewFolderPermissionsFromFolderPermissionsItemList(value []*FolderPermissionsItem) *FolderPermissions {
	return &FolderPermissions{typeName: "folderPermissionsItemList", FolderPermissionsItemList: value}
}

func (f *FolderPermissions) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		f.typeName = "string"
		f.String = valueString
		return nil
	}
	var valueUnknown any
	if err := json.Unmarshal(data, &valueUnknown); err == nil {
		f.typeName = "unknown"
		f.Unknown = valueUnknown
		return nil
	}
	var valueFolderPermissionsItemList []*FolderPermissionsItem
	if err := json.Unmarshal(data, &valueFolderPermissionsItemList); err == nil {
		f.typeName = "folderPermissionsItemList"
		f.FolderPermissionsItemList = valueFolderPermissionsItemList
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, f)
}

func (f FolderPermissions) MarshalJSON() ([]byte, error) {
	switch f.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", f.typeName, f)
	case "string":
		return json.Marshal(f.String)
	case "unknown":
		return json.Marshal(f.Unknown)
	case "folderPermissionsItemList":
		return json.Marshal(f.FolderPermissionsItemList)
	}
}

type FolderPermissionsVisitor interface {
	VisitString(string) error
	VisitUnknown(any) error
	VisitFolderPermissionsItemList([]*FolderPermissionsItem) error
}

func (f *FolderPermissions) Accept(visitor FolderPermissionsVisitor) error {
	switch f.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", f.typeName, f)
	case "string":
		return visitor.VisitString(f.String)
	case "unknown":
		return visitor.VisitUnknown(f.Unknown)
	case "folderPermissionsItemList":
		return visitor.VisitFolderPermissionsItemList(f.FolderPermissionsItemList)
	}
}

type FolderPermissionsItem struct {
	typeName          string
	String            string
	PermissionRequest *PermissionRequest
}

func NewFolderPermissionsItemFromString(value string) *FolderPermissionsItem {
	return &FolderPermissionsItem{typeName: "string", String: value}
}

func NewFolderPermissionsItemFromPermissionRequest(value *PermissionRequest) *FolderPermissionsItem {
	return &FolderPermissionsItem{typeName: "permissionRequest", PermissionRequest: value}
}

func (f *FolderPermissionsItem) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		f.typeName = "string"
		f.String = valueString
		return nil
	}
	valuePermissionRequest := new(PermissionRequest)
	if err := json.Unmarshal(data, &valuePermissionRequest); err == nil {
		f.typeName = "permissionRequest"
		f.PermissionRequest = valuePermissionRequest
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, f)
}

func (f FolderPermissionsItem) MarshalJSON() ([]byte, error) {
	switch f.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", f.typeName, f)
	case "string":
		return json.Marshal(f.String)
	case "permissionRequest":
		return json.Marshal(f.PermissionRequest)
	}
}

type FolderPermissionsItemVisitor interface {
	VisitString(string) error
	VisitPermissionRequest(*PermissionRequest) error
}

func (f *FolderPermissionsItem) Accept(visitor FolderPermissionsItemVisitor) error {
	switch f.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", f.typeName, f)
	case "string":
		return visitor.VisitString(f.String)
	case "permissionRequest":
		return visitor.VisitPermissionRequest(f.PermissionRequest)
	}
}

// # The Folder Object
//
// ### Description
//
// The `Folder` object is used to represent a collection of files and/or folders in the workspace. Could be within a drive, if it exists.
//
// ### Usage Example
//
// Fetch from the `GET /api/filestorage/v1/folders` endpoint and view their folders.
type FolderRequest struct {
	// The folder's name.
	Name *string `json:"name,omitempty"`
	// The URL to access the folder.
	FolderUrl *string `json:"folder_url,omitempty"`
	// The folder's size, in bytes.
	Size *int `json:"size,omitempty"`
	// The folder's description.
	Description *string `json:"description,omitempty"`
	// The folder that the folder belongs to.
	ParentFolder *FolderRequestParentFolder `json:"parent_folder,omitempty"`
	// The drive that the folder belongs to.
	Drive *FolderRequestDrive `json:"drive,omitempty"`
	// The Permission object is used to represent a user's or group's access to a File or Folder. Permissions are unexpanded by default. Use the query param `expand=permissions` to see more details under `GET /folders`.
	Permissions         *FolderRequestPermissions `json:"permissions,omitempty"`
	IntegrationParams   map[string]any            `json:"integration_params,omitempty"`
	LinkedAccountParams map[string]any            `json:"linked_account_params,omitempty"`
}

// The drive that the folder belongs to.
type FolderRequestDrive struct {
	typeName string
	String   string
	Drive    *Drive
}

func NewFolderRequestDriveFromString(value string) *FolderRequestDrive {
	return &FolderRequestDrive{typeName: "string", String: value}
}

func NewFolderRequestDriveFromDrive(value *Drive) *FolderRequestDrive {
	return &FolderRequestDrive{typeName: "drive", Drive: value}
}

func (f *FolderRequestDrive) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		f.typeName = "string"
		f.String = valueString
		return nil
	}
	valueDrive := new(Drive)
	if err := json.Unmarshal(data, &valueDrive); err == nil {
		f.typeName = "drive"
		f.Drive = valueDrive
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, f)
}

func (f FolderRequestDrive) MarshalJSON() ([]byte, error) {
	switch f.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", f.typeName, f)
	case "string":
		return json.Marshal(f.String)
	case "drive":
		return json.Marshal(f.Drive)
	}
}

type FolderRequestDriveVisitor interface {
	VisitString(string) error
	VisitDrive(*Drive) error
}

func (f *FolderRequestDrive) Accept(visitor FolderRequestDriveVisitor) error {
	switch f.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", f.typeName, f)
	case "string":
		return visitor.VisitString(f.String)
	case "drive":
		return visitor.VisitDrive(f.Drive)
	}
}

// The folder that the folder belongs to.
type FolderRequestParentFolder struct {
	typeName string
	String   string
	Folder   *Folder
}

func NewFolderRequestParentFolderFromString(value string) *FolderRequestParentFolder {
	return &FolderRequestParentFolder{typeName: "string", String: value}
}

func NewFolderRequestParentFolderFromFolder(value *Folder) *FolderRequestParentFolder {
	return &FolderRequestParentFolder{typeName: "folder", Folder: value}
}

func (f *FolderRequestParentFolder) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		f.typeName = "string"
		f.String = valueString
		return nil
	}
	valueFolder := new(Folder)
	if err := json.Unmarshal(data, &valueFolder); err == nil {
		f.typeName = "folder"
		f.Folder = valueFolder
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, f)
}

func (f FolderRequestParentFolder) MarshalJSON() ([]byte, error) {
	switch f.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", f.typeName, f)
	case "string":
		return json.Marshal(f.String)
	case "folder":
		return json.Marshal(f.Folder)
	}
}

type FolderRequestParentFolderVisitor interface {
	VisitString(string) error
	VisitFolder(*Folder) error
}

func (f *FolderRequestParentFolder) Accept(visitor FolderRequestParentFolderVisitor) error {
	switch f.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", f.typeName, f)
	case "string":
		return visitor.VisitString(f.String)
	case "folder":
		return visitor.VisitFolder(f.Folder)
	}
}

// The Permission object is used to represent a user's or group's access to a File or Folder. Permissions are unexpanded by default. Use the query param `expand=permissions` to see more details under `GET /folders`.
type FolderRequestPermissions struct {
	typeName                         string
	String                           string
	Unknown                          any
	FolderRequestPermissionsItemList []*FolderRequestPermissionsItem
}

func NewFolderRequestPermissionsFromString(value string) *FolderRequestPermissions {
	return &FolderRequestPermissions{typeName: "string", String: value}
}

func NewFolderRequestPermissionsFromUnknown(value any) *FolderRequestPermissions {
	return &FolderRequestPermissions{typeName: "unknown", Unknown: value}
}

func NewFolderRequestPermissionsFromFolderRequestPermissionsItemList(value []*FolderRequestPermissionsItem) *FolderRequestPermissions {
	return &FolderRequestPermissions{typeName: "folderRequestPermissionsItemList", FolderRequestPermissionsItemList: value}
}

func (f *FolderRequestPermissions) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		f.typeName = "string"
		f.String = valueString
		return nil
	}
	var valueUnknown any
	if err := json.Unmarshal(data, &valueUnknown); err == nil {
		f.typeName = "unknown"
		f.Unknown = valueUnknown
		return nil
	}
	var valueFolderRequestPermissionsItemList []*FolderRequestPermissionsItem
	if err := json.Unmarshal(data, &valueFolderRequestPermissionsItemList); err == nil {
		f.typeName = "folderRequestPermissionsItemList"
		f.FolderRequestPermissionsItemList = valueFolderRequestPermissionsItemList
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, f)
}

func (f FolderRequestPermissions) MarshalJSON() ([]byte, error) {
	switch f.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", f.typeName, f)
	case "string":
		return json.Marshal(f.String)
	case "unknown":
		return json.Marshal(f.Unknown)
	case "folderRequestPermissionsItemList":
		return json.Marshal(f.FolderRequestPermissionsItemList)
	}
}

type FolderRequestPermissionsVisitor interface {
	VisitString(string) error
	VisitUnknown(any) error
	VisitFolderRequestPermissionsItemList([]*FolderRequestPermissionsItem) error
}

func (f *FolderRequestPermissions) Accept(visitor FolderRequestPermissionsVisitor) error {
	switch f.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", f.typeName, f)
	case "string":
		return visitor.VisitString(f.String)
	case "unknown":
		return visitor.VisitUnknown(f.Unknown)
	case "folderRequestPermissionsItemList":
		return visitor.VisitFolderRequestPermissionsItemList(f.FolderRequestPermissionsItemList)
	}
}

type FolderRequestPermissionsItem struct {
	typeName          string
	String            string
	PermissionRequest *PermissionRequest
}

func NewFolderRequestPermissionsItemFromString(value string) *FolderRequestPermissionsItem {
	return &FolderRequestPermissionsItem{typeName: "string", String: value}
}

func NewFolderRequestPermissionsItemFromPermissionRequest(value *PermissionRequest) *FolderRequestPermissionsItem {
	return &FolderRequestPermissionsItem{typeName: "permissionRequest", PermissionRequest: value}
}

func (f *FolderRequestPermissionsItem) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		f.typeName = "string"
		f.String = valueString
		return nil
	}
	valuePermissionRequest := new(PermissionRequest)
	if err := json.Unmarshal(data, &valuePermissionRequest); err == nil {
		f.typeName = "permissionRequest"
		f.PermissionRequest = valuePermissionRequest
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, f)
}

func (f FolderRequestPermissionsItem) MarshalJSON() ([]byte, error) {
	switch f.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", f.typeName, f)
	case "string":
		return json.Marshal(f.String)
	case "permissionRequest":
		return json.Marshal(f.PermissionRequest)
	}
}

type FolderRequestPermissionsItemVisitor interface {
	VisitString(string) error
	VisitPermissionRequest(*PermissionRequest) error
}

func (f *FolderRequestPermissionsItem) Accept(visitor FolderRequestPermissionsItemVisitor) error {
	switch f.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", f.typeName, f)
	case "string":
		return visitor.VisitString(f.String)
	case "permissionRequest":
		return visitor.VisitPermissionRequest(f.PermissionRequest)
	}
}

// # The Group Object
//
// ### Description
//
// The `Group` object is used to represent any subset of `User`s. This can extend to company domains as well.
//
// ### Usage Example
//
// Fetch from the `GET /api/filestorage/v1/groups` endpoint and view their groups.
type Group struct {
	Id *string `json:"id,omitempty"`
	// The third-party API ID of the matching object.
	RemoteId *string `json:"remote_id,omitempty"`
	// The group's name.
	Name *string `json:"name,omitempty"`
	// The users that belong in the group. If null, this typically means it's either a domain or the third-party platform does not surface this information.
	Users []string `json:"users,omitempty"`
	// Indicates whether or not this object has been deleted in the third party platform.
	RemoteWasDeleted *bool      `json:"remote_was_deleted,omitempty"`
	CreatedAt        *time.Time `json:"created_at,omitempty"`
	// This is the datetime that this object was last updated by Merge
	ModifiedAt    *time.Time       `json:"modified_at,omitempty"`
	FieldMappings map[string]any   `json:"field_mappings,omitempty"`
	RemoteData    []map[string]any `json:"remote_data,omitempty"`
}

type Issue struct {
	Id *string `json:"id,omitempty"`
	// Status of the issue. Options: ('ONGOING', 'RESOLVED')
	//
	// - `ONGOING` - ONGOING
	// - `RESOLVED` - RESOLVED
	Status            *IssueStatus   `json:"status,omitempty"`
	ErrorDescription  string         `json:"error_description"`
	EndUser           map[string]any `json:"end_user,omitempty"`
	FirstIncidentTime *time.Time     `json:"first_incident_time,omitempty"`
	LastIncidentTime  *time.Time     `json:"last_incident_time,omitempty"`
	IsMuted           *bool          `json:"is_muted,omitempty"`
	ErrorDetails      []string       `json:"error_details,omitempty"`
}

// Status of the issue. Options: ('ONGOING', 'RESOLVED')
//
// - `ONGOING` - ONGOING
// - `RESOLVED` - RESOLVED
type IssueStatus struct {
	typeName        string
	IssueStatusEnum IssueStatusEnum
	String          string
}

func NewIssueStatusFromIssueStatusEnum(value IssueStatusEnum) *IssueStatus {
	return &IssueStatus{typeName: "issueStatusEnum", IssueStatusEnum: value}
}

func NewIssueStatusFromString(value string) *IssueStatus {
	return &IssueStatus{typeName: "string", String: value}
}

func (i *IssueStatus) UnmarshalJSON(data []byte) error {
	var valueIssueStatusEnum IssueStatusEnum
	if err := json.Unmarshal(data, &valueIssueStatusEnum); err == nil {
		i.typeName = "issueStatusEnum"
		i.IssueStatusEnum = valueIssueStatusEnum
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		i.typeName = "string"
		i.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, i)
}

func (i IssueStatus) MarshalJSON() ([]byte, error) {
	switch i.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", i.typeName, i)
	case "issueStatusEnum":
		return json.Marshal(i.IssueStatusEnum)
	case "string":
		return json.Marshal(i.String)
	}
}

type IssueStatusVisitor interface {
	VisitIssueStatusEnum(IssueStatusEnum) error
	VisitString(string) error
}

func (i *IssueStatus) Accept(visitor IssueStatusVisitor) error {
	switch i.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", i.typeName, i)
	case "issueStatusEnum":
		return visitor.VisitIssueStatusEnum(i.IssueStatusEnum)
	case "string":
		return visitor.VisitString(i.String)
	}
}

// - `ONGOING` - ONGOING
// - `RESOLVED` - RESOLVED
type IssueStatusEnum uint

const (
	IssueStatusEnumOngoing IssueStatusEnum = iota + 1
	IssueStatusEnumResolved
)

func (i IssueStatusEnum) String() string {
	switch i {
	default:
		return strconv.Itoa(int(i))
	case IssueStatusEnumOngoing:
		return "ONGOING"
	case IssueStatusEnumResolved:
		return "RESOLVED"
	}
}

func (i IssueStatusEnum) MarshalJSON() ([]byte, error) {
	return []byte(fmt.Sprintf("%q", i.String())), nil
}

func (i *IssueStatusEnum) UnmarshalJSON(data []byte) error {
	var raw string
	if err := json.Unmarshal(data, &raw); err != nil {
		return err
	}
	switch raw {
	case "ONGOING":
		value := IssueStatusEnumOngoing
		*i = value
	case "RESOLVED":
		value := IssueStatusEnumResolved
		*i = value
	}
	return nil
}

type LinkToken struct {
	LinkToken       string  `json:"link_token"`
	IntegrationName *string `json:"integration_name,omitempty"`
	MagicLinkUrl    *string `json:"magic_link_url,omitempty"`
}

type LinkedAccountCondition struct {
	// The ID indicating which condition schema to use for a specific condition.
	ConditionSchemaId string `json:"condition_schema_id"`
	// The common model for a specific condition.
	CommonModel *string `json:"common_model,omitempty"`
	// User-facing _native condition_ name. e.g. "Skip Manager".
	NativeName *string `json:"native_name,omitempty"`
	// The operator for a specific condition.
	Operator string `json:"operator"`
	Value    *any   `json:"value,omitempty"`
	// The name of the field on the common model that this condition corresponds to, if they conceptually match. e.g. "location_type".
	FieldName *string `json:"field_name,omitempty"`
}

type LinkedAccountConditionRequest struct {
	// The ID indicating which condition schema to use for a specific condition.
	ConditionSchemaId string `json:"condition_schema_id"`
	// The operator for a specific condition.
	Operator string `json:"operator"`
	Value    any    `json:"value,omitempty"`
}

type LinkedAccountSelectiveSyncConfiguration struct {
	// The conditions belonging to a selective sync.
	LinkedAccountConditions []*LinkedAccountCondition `json:"linked_account_conditions,omitempty"`
}

type LinkedAccountSelectiveSyncConfigurationRequest struct {
	// The conditions belonging to a selective sync.
	LinkedAccountConditions []*LinkedAccountConditionRequest `json:"linked_account_conditions,omitempty"`
}

type LinkedAccountStatus struct {
	LinkedAccountStatus string `json:"linked_account_status"`
	CanMakeRequest      bool   `json:"can_make_request"`
}

type MetaResponse struct {
	RequestSchema                  map[string]any       `json:"request_schema,omitempty"`
	RemoteFieldClasses             map[string]any       `json:"remote_field_classes,omitempty"`
	Status                         *LinkedAccountStatus `json:"status,omitempty"`
	HasConditionalParams           bool                 `json:"has_conditional_params"`
	HasRequiredLinkedAccountParams bool                 `json:"has_required_linked_account_params"`
}

// - `GET` - GET
// - `OPTIONS` - OPTIONS
// - `HEAD` - HEAD
// - `POST` - POST
// - `PUT` - PUT
// - `PATCH` - PATCH
// - `DELETE` - DELETE
type MethodEnum uint

const (
	MethodEnumGet MethodEnum = iota + 1
	MethodEnumOptions
	MethodEnumHead
	MethodEnumPost
	MethodEnumPut
	MethodEnumPatch
	MethodEnumDelete
)

func (m MethodEnum) String() string {
	switch m {
	default:
		return strconv.Itoa(int(m))
	case MethodEnumGet:
		return "GET"
	case MethodEnumOptions:
		return "OPTIONS"
	case MethodEnumHead:
		return "HEAD"
	case MethodEnumPost:
		return "POST"
	case MethodEnumPut:
		return "PUT"
	case MethodEnumPatch:
		return "PATCH"
	case MethodEnumDelete:
		return "DELETE"
	}
}

func (m MethodEnum) MarshalJSON() ([]byte, error) {
	return []byte(fmt.Sprintf("%q", m.String())), nil
}

func (m *MethodEnum) UnmarshalJSON(data []byte) error {
	var raw string
	if err := json.Unmarshal(data, &raw); err != nil {
		return err
	}
	switch raw {
	case "GET":
		value := MethodEnumGet
		*m = value
	case "OPTIONS":
		value := MethodEnumOptions
		*m = value
	case "HEAD":
		value := MethodEnumHead
		*m = value
	case "POST":
		value := MethodEnumPost
		*m = value
	case "PUT":
		value := MethodEnumPut
		*m = value
	case "PATCH":
		value := MethodEnumPatch
		*m = value
	case "DELETE":
		value := MethodEnumDelete
		*m = value
	}
	return nil
}

// # The ModelOperation Object
//
// ### Description
//
// The `ModelOperation` object is used to represent the operations that are currently supported for a given model.
//
// ### Usage Example
//
// View what operations are supported for the `Candidate` endpoint.
type ModelOperation struct {
	ModelName              string   `json:"model_name"`
	AvailableOperations    []string `json:"available_operations,omitempty"`
	RequiredPostParameters []string `json:"required_post_parameters,omitempty"`
	SupportedFields        []string `json:"supported_fields,omitempty"`
}

// # The MultipartFormField Object
//
// ### Description
//
// The `MultipartFormField` object is used to represent fields in an HTTP request using `multipart/form-data`.
//
// ### Usage Example
//
// Create a `MultipartFormField` to define a multipart form entry.
type MultipartFormFieldRequest struct {
	// The name of the form field
	Name string `json:"name"`
	// The data for the form field.
	Data string `json:"data"`
	// The encoding of the value of `data`. Defaults to `RAW` if not defined.
	//
	// - `RAW` - RAW
	// - `BASE64` - BASE64
	// - `GZIP_BASE64` - GZIP_BASE64
	Encoding *MultipartFormFieldRequestEncoding `json:"encoding,omitempty"`
	// The file name of the form field, if the field is for a file.
	FileName *string `json:"file_name,omitempty"`
	// The MIME type of the file, if the field is for a file.
	ContentType *string `json:"content_type,omitempty"`
}

// The encoding of the value of `data`. Defaults to `RAW` if not defined.
//
// - `RAW` - RAW
// - `BASE64` - BASE64
// - `GZIP_BASE64` - GZIP_BASE64
type MultipartFormFieldRequestEncoding struct {
	typeName     string
	EncodingEnum EncodingEnum
	String       string
}

func NewMultipartFormFieldRequestEncodingFromEncodingEnum(value EncodingEnum) *MultipartFormFieldRequestEncoding {
	return &MultipartFormFieldRequestEncoding{typeName: "encodingEnum", EncodingEnum: value}
}

func NewMultipartFormFieldRequestEncodingFromString(value string) *MultipartFormFieldRequestEncoding {
	return &MultipartFormFieldRequestEncoding{typeName: "string", String: value}
}

func (m *MultipartFormFieldRequestEncoding) UnmarshalJSON(data []byte) error {
	var valueEncodingEnum EncodingEnum
	if err := json.Unmarshal(data, &valueEncodingEnum); err == nil {
		m.typeName = "encodingEnum"
		m.EncodingEnum = valueEncodingEnum
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		m.typeName = "string"
		m.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, m)
}

func (m MultipartFormFieldRequestEncoding) MarshalJSON() ([]byte, error) {
	switch m.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", m.typeName, m)
	case "encodingEnum":
		return json.Marshal(m.EncodingEnum)
	case "string":
		return json.Marshal(m.String)
	}
}

type MultipartFormFieldRequestEncodingVisitor interface {
	VisitEncodingEnum(EncodingEnum) error
	VisitString(string) error
}

func (m *MultipartFormFieldRequestEncoding) Accept(visitor MultipartFormFieldRequestEncodingVisitor) error {
	switch m.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", m.typeName, m)
	case "encodingEnum":
		return visitor.VisitEncodingEnum(m.EncodingEnum)
	case "string":
		return visitor.VisitString(m.String)
	}
}

type OperatorSchema struct {
	// The operator for which an operator schema is defined.
	Operator *string `json:"operator,omitempty"`
	// Whether the operator can be repeated multiple times.
	IsUnique *bool `json:"is_unique,omitempty"`
}

type PaginatedAccountDetailsAndActionsList struct {
	Next     *string                     `json:"next,omitempty"`
	Previous *string                     `json:"previous,omitempty"`
	Results  []*AccountDetailsAndActions `json:"results,omitempty"`
}

type PaginatedAuditLogEventList struct {
	Next     *string          `json:"next,omitempty"`
	Previous *string          `json:"previous,omitempty"`
	Results  []*AuditLogEvent `json:"results,omitempty"`
}

type PaginatedConditionSchemaList struct {
	Next     *string            `json:"next,omitempty"`
	Previous *string            `json:"previous,omitempty"`
	Results  []*ConditionSchema `json:"results,omitempty"`
}

type PaginatedDriveList struct {
	Next     *string  `json:"next,omitempty"`
	Previous *string  `json:"previous,omitempty"`
	Results  []*Drive `json:"results,omitempty"`
}

type PaginatedFileList struct {
	Next     *string `json:"next,omitempty"`
	Previous *string `json:"previous,omitempty"`
	Results  []*File `json:"results,omitempty"`
}

type PaginatedFolderList struct {
	Next     *string   `json:"next,omitempty"`
	Previous *string   `json:"previous,omitempty"`
	Results  []*Folder `json:"results,omitempty"`
}

type PaginatedGroupList struct {
	Next     *string  `json:"next,omitempty"`
	Previous *string  `json:"previous,omitempty"`
	Results  []*Group `json:"results,omitempty"`
}

type PaginatedIssueList struct {
	Next     *string  `json:"next,omitempty"`
	Previous *string  `json:"previous,omitempty"`
	Results  []*Issue `json:"results,omitempty"`
}

type PaginatedSyncStatusList struct {
	Next     *string       `json:"next,omitempty"`
	Previous *string       `json:"previous,omitempty"`
	Results  []*SyncStatus `json:"results,omitempty"`
}

type PaginatedUserList struct {
	Next     *string `json:"next,omitempty"`
	Previous *string `json:"previous,omitempty"`
	Results  []*User `json:"results,omitempty"`
}

// # The Permission Object
//
// ### Description
//
// The Permission object is used to represent a user's or group's access to a File or Folder. Permissions are unexpanded by default.
//
// ### Usage Example
//
// Fetch from the `GET Files` or `GET Folders` endpoint. Permissions are unexpanded by default. Use the query param `expand=permissions` to see more details.
type Permission struct {
	Id *string `json:"id,omitempty"`
	// The third-party API ID of the matching object.
	RemoteId *string `json:"remote_id,omitempty"`
	// The user that is granted this permission.
	User *PermissionUser `json:"user,omitempty"`
	// The group that is granted this permission.
	Group *PermissionGroup `json:"group,omitempty"`
	// Denotes what type of people have access to the file.
	//
	// - `USER` - USER
	// - `GROUP` - GROUP
	// - `COMPANY` - COMPANY
	// - `ANYONE` - ANYONE
	Type *PermissionType `json:"type,omitempty"`
	// The permissions that the user or group has for the File or Folder. It is possible for a user or group to have multiple roles, such as viewing & uploading. Possible values include: `READ`, `WRITE`, `OWNER`. In cases where there is no clear mapping, the original value passed through will be returned.
	Roles     []*PermissionRolesItem `json:"roles,omitempty"`
	CreatedAt *time.Time             `json:"created_at,omitempty"`
	// This is the datetime that this object was last updated by Merge
	ModifiedAt *time.Time `json:"modified_at,omitempty"`
}

// The group that is granted this permission.
type PermissionGroup struct {
	typeName string
	String   string
	Group    *Group
}

func NewPermissionGroupFromString(value string) *PermissionGroup {
	return &PermissionGroup{typeName: "string", String: value}
}

func NewPermissionGroupFromGroup(value *Group) *PermissionGroup {
	return &PermissionGroup{typeName: "group", Group: value}
}

func (p *PermissionGroup) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		p.typeName = "string"
		p.String = valueString
		return nil
	}
	valueGroup := new(Group)
	if err := json.Unmarshal(data, &valueGroup); err == nil {
		p.typeName = "group"
		p.Group = valueGroup
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, p)
}

func (p PermissionGroup) MarshalJSON() ([]byte, error) {
	switch p.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", p.typeName, p)
	case "string":
		return json.Marshal(p.String)
	case "group":
		return json.Marshal(p.Group)
	}
}

type PermissionGroupVisitor interface {
	VisitString(string) error
	VisitGroup(*Group) error
}

func (p *PermissionGroup) Accept(visitor PermissionGroupVisitor) error {
	switch p.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", p.typeName, p)
	case "string":
		return visitor.VisitString(p.String)
	case "group":
		return visitor.VisitGroup(p.Group)
	}
}

// # The Permission Object
//
// ### Description
//
// The Permission object is used to represent a user's or group's access to a File or Folder. Permissions are unexpanded by default.
//
// ### Usage Example
//
// Fetch from the `GET Files` or `GET Folders` endpoint. Permissions are unexpanded by default. Use the query param `expand=permissions` to see more details.
type PermissionRequest struct {
	// The third-party API ID of the matching object.
	RemoteId *string `json:"remote_id,omitempty"`
	// The user that is granted this permission.
	User *PermissionRequestUser `json:"user,omitempty"`
	// The group that is granted this permission.
	Group *PermissionRequestGroup `json:"group,omitempty"`
	// Denotes what type of people have access to the file.
	//
	// - `USER` - USER
	// - `GROUP` - GROUP
	// - `COMPANY` - COMPANY
	// - `ANYONE` - ANYONE
	Type *PermissionRequestType `json:"type,omitempty"`
	// The permissions that the user or group has for the File or Folder. It is possible for a user or group to have multiple roles, such as viewing & uploading. Possible values include: `READ`, `WRITE`, `OWNER`. In cases where there is no clear mapping, the original value passed through will be returned.
	Roles               []*PermissionRequestRolesItem `json:"roles,omitempty"`
	IntegrationParams   map[string]any                `json:"integration_params,omitempty"`
	LinkedAccountParams map[string]any                `json:"linked_account_params,omitempty"`
}

// The group that is granted this permission.
type PermissionRequestGroup struct {
	typeName string
	String   string
	Group    *Group
}

func NewPermissionRequestGroupFromString(value string) *PermissionRequestGroup {
	return &PermissionRequestGroup{typeName: "string", String: value}
}

func NewPermissionRequestGroupFromGroup(value *Group) *PermissionRequestGroup {
	return &PermissionRequestGroup{typeName: "group", Group: value}
}

func (p *PermissionRequestGroup) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		p.typeName = "string"
		p.String = valueString
		return nil
	}
	valueGroup := new(Group)
	if err := json.Unmarshal(data, &valueGroup); err == nil {
		p.typeName = "group"
		p.Group = valueGroup
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, p)
}

func (p PermissionRequestGroup) MarshalJSON() ([]byte, error) {
	switch p.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", p.typeName, p)
	case "string":
		return json.Marshal(p.String)
	case "group":
		return json.Marshal(p.Group)
	}
}

type PermissionRequestGroupVisitor interface {
	VisitString(string) error
	VisitGroup(*Group) error
}

func (p *PermissionRequestGroup) Accept(visitor PermissionRequestGroupVisitor) error {
	switch p.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", p.typeName, p)
	case "string":
		return visitor.VisitString(p.String)
	case "group":
		return visitor.VisitGroup(p.Group)
	}
}

// The permissions that the user or group has for the File or Folder.
//
// - `READ` - READ
// - `WRITE` - WRITE
// - `OWNER` - OWNER
type PermissionRequestRolesItem struct {
	typeName  string
	RolesEnum RolesEnum
	String    string
}

func NewPermissionRequestRolesItemFromRolesEnum(value RolesEnum) *PermissionRequestRolesItem {
	return &PermissionRequestRolesItem{typeName: "rolesEnum", RolesEnum: value}
}

func NewPermissionRequestRolesItemFromString(value string) *PermissionRequestRolesItem {
	return &PermissionRequestRolesItem{typeName: "string", String: value}
}

func (p *PermissionRequestRolesItem) UnmarshalJSON(data []byte) error {
	var valueRolesEnum RolesEnum
	if err := json.Unmarshal(data, &valueRolesEnum); err == nil {
		p.typeName = "rolesEnum"
		p.RolesEnum = valueRolesEnum
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		p.typeName = "string"
		p.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, p)
}

func (p PermissionRequestRolesItem) MarshalJSON() ([]byte, error) {
	switch p.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", p.typeName, p)
	case "rolesEnum":
		return json.Marshal(p.RolesEnum)
	case "string":
		return json.Marshal(p.String)
	}
}

type PermissionRequestRolesItemVisitor interface {
	VisitRolesEnum(RolesEnum) error
	VisitString(string) error
}

func (p *PermissionRequestRolesItem) Accept(visitor PermissionRequestRolesItemVisitor) error {
	switch p.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", p.typeName, p)
	case "rolesEnum":
		return visitor.VisitRolesEnum(p.RolesEnum)
	case "string":
		return visitor.VisitString(p.String)
	}
}

// Denotes what type of people have access to the file.
//
// - `USER` - USER
// - `GROUP` - GROUP
// - `COMPANY` - COMPANY
// - `ANYONE` - ANYONE
type PermissionRequestType struct {
	typeName string
	TypeEnum TypeEnum
	String   string
}

func NewPermissionRequestTypeFromTypeEnum(value TypeEnum) *PermissionRequestType {
	return &PermissionRequestType{typeName: "typeEnum", TypeEnum: value}
}

func NewPermissionRequestTypeFromString(value string) *PermissionRequestType {
	return &PermissionRequestType{typeName: "string", String: value}
}

func (p *PermissionRequestType) UnmarshalJSON(data []byte) error {
	var valueTypeEnum TypeEnum
	if err := json.Unmarshal(data, &valueTypeEnum); err == nil {
		p.typeName = "typeEnum"
		p.TypeEnum = valueTypeEnum
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		p.typeName = "string"
		p.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, p)
}

func (p PermissionRequestType) MarshalJSON() ([]byte, error) {
	switch p.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", p.typeName, p)
	case "typeEnum":
		return json.Marshal(p.TypeEnum)
	case "string":
		return json.Marshal(p.String)
	}
}

type PermissionRequestTypeVisitor interface {
	VisitTypeEnum(TypeEnum) error
	VisitString(string) error
}

func (p *PermissionRequestType) Accept(visitor PermissionRequestTypeVisitor) error {
	switch p.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", p.typeName, p)
	case "typeEnum":
		return visitor.VisitTypeEnum(p.TypeEnum)
	case "string":
		return visitor.VisitString(p.String)
	}
}

// The user that is granted this permission.
type PermissionRequestUser struct {
	typeName string
	String   string
	User     *User
}

func NewPermissionRequestUserFromString(value string) *PermissionRequestUser {
	return &PermissionRequestUser{typeName: "string", String: value}
}

func NewPermissionRequestUserFromUser(value *User) *PermissionRequestUser {
	return &PermissionRequestUser{typeName: "user", User: value}
}

func (p *PermissionRequestUser) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		p.typeName = "string"
		p.String = valueString
		return nil
	}
	valueUser := new(User)
	if err := json.Unmarshal(data, &valueUser); err == nil {
		p.typeName = "user"
		p.User = valueUser
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, p)
}

func (p PermissionRequestUser) MarshalJSON() ([]byte, error) {
	switch p.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", p.typeName, p)
	case "string":
		return json.Marshal(p.String)
	case "user":
		return json.Marshal(p.User)
	}
}

type PermissionRequestUserVisitor interface {
	VisitString(string) error
	VisitUser(*User) error
}

func (p *PermissionRequestUser) Accept(visitor PermissionRequestUserVisitor) error {
	switch p.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", p.typeName, p)
	case "string":
		return visitor.VisitString(p.String)
	case "user":
		return visitor.VisitUser(p.User)
	}
}

// The permissions that the user or group has for the File or Folder.
//
// - `READ` - READ
// - `WRITE` - WRITE
// - `OWNER` - OWNER
type PermissionRolesItem struct {
	typeName  string
	RolesEnum RolesEnum
	String    string
}

func NewPermissionRolesItemFromRolesEnum(value RolesEnum) *PermissionRolesItem {
	return &PermissionRolesItem{typeName: "rolesEnum", RolesEnum: value}
}

func NewPermissionRolesItemFromString(value string) *PermissionRolesItem {
	return &PermissionRolesItem{typeName: "string", String: value}
}

func (p *PermissionRolesItem) UnmarshalJSON(data []byte) error {
	var valueRolesEnum RolesEnum
	if err := json.Unmarshal(data, &valueRolesEnum); err == nil {
		p.typeName = "rolesEnum"
		p.RolesEnum = valueRolesEnum
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		p.typeName = "string"
		p.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, p)
}

func (p PermissionRolesItem) MarshalJSON() ([]byte, error) {
	switch p.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", p.typeName, p)
	case "rolesEnum":
		return json.Marshal(p.RolesEnum)
	case "string":
		return json.Marshal(p.String)
	}
}

type PermissionRolesItemVisitor interface {
	VisitRolesEnum(RolesEnum) error
	VisitString(string) error
}

func (p *PermissionRolesItem) Accept(visitor PermissionRolesItemVisitor) error {
	switch p.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", p.typeName, p)
	case "rolesEnum":
		return visitor.VisitRolesEnum(p.RolesEnum)
	case "string":
		return visitor.VisitString(p.String)
	}
}

// Denotes what type of people have access to the file.
//
// - `USER` - USER
// - `GROUP` - GROUP
// - `COMPANY` - COMPANY
// - `ANYONE` - ANYONE
type PermissionType struct {
	typeName string
	TypeEnum TypeEnum
	String   string
}

func NewPermissionTypeFromTypeEnum(value TypeEnum) *PermissionType {
	return &PermissionType{typeName: "typeEnum", TypeEnum: value}
}

func NewPermissionTypeFromString(value string) *PermissionType {
	return &PermissionType{typeName: "string", String: value}
}

func (p *PermissionType) UnmarshalJSON(data []byte) error {
	var valueTypeEnum TypeEnum
	if err := json.Unmarshal(data, &valueTypeEnum); err == nil {
		p.typeName = "typeEnum"
		p.TypeEnum = valueTypeEnum
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		p.typeName = "string"
		p.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, p)
}

func (p PermissionType) MarshalJSON() ([]byte, error) {
	switch p.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", p.typeName, p)
	case "typeEnum":
		return json.Marshal(p.TypeEnum)
	case "string":
		return json.Marshal(p.String)
	}
}

type PermissionTypeVisitor interface {
	VisitTypeEnum(TypeEnum) error
	VisitString(string) error
}

func (p *PermissionType) Accept(visitor PermissionTypeVisitor) error {
	switch p.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", p.typeName, p)
	case "typeEnum":
		return visitor.VisitTypeEnum(p.TypeEnum)
	case "string":
		return visitor.VisitString(p.String)
	}
}

// The user that is granted this permission.
type PermissionUser struct {
	typeName string
	String   string
	User     *User
}

func NewPermissionUserFromString(value string) *PermissionUser {
	return &PermissionUser{typeName: "string", String: value}
}

func NewPermissionUserFromUser(value *User) *PermissionUser {
	return &PermissionUser{typeName: "user", User: value}
}

func (p *PermissionUser) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		p.typeName = "string"
		p.String = valueString
		return nil
	}
	valueUser := new(User)
	if err := json.Unmarshal(data, &valueUser); err == nil {
		p.typeName = "user"
		p.User = valueUser
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, p)
}

func (p PermissionUser) MarshalJSON() ([]byte, error) {
	switch p.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", p.typeName, p)
	case "string":
		return json.Marshal(p.String)
	case "user":
		return json.Marshal(p.User)
	}
}

type PermissionUserVisitor interface {
	VisitString(string) error
	VisitUser(*User) error
}

func (p *PermissionUser) Accept(visitor PermissionUserVisitor) error {
	switch p.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", p.typeName, p)
	case "string":
		return visitor.VisitString(p.String)
	case "user":
		return visitor.VisitUser(p.User)
	}
}

// # The RemoteKey Object
//
// ### Description
//
// The `RemoteKey` object is used to represent a request for a new remote key.
//
// ### Usage Example
//
// Post a `GenerateRemoteKey` to receive a new `RemoteKey`.
type RemoteKey struct {
	Name string `json:"name"`
	Key  string `json:"key"`
}

// # The RemoteResponse Object
//
// ### Description
//
// The `RemoteResponse` object is used to represent information returned from a third-party endpoint.
//
// ### Usage Example
//
// View the `RemoteResponse` returned from your `DataPassthrough`.
type RemoteResponse struct {
	Method          string            `json:"method"`
	Path            string            `json:"path"`
	Status          int               `json:"status"`
	Response        any               `json:"response,omitempty"`
	ResponseHeaders map[string]any    `json:"response_headers,omitempty"`
	ResponseType    *ResponseTypeEnum `json:"response_type,omitempty"`
	Headers         map[string]any    `json:"headers,omitempty"`
}

// - `JSON` - JSON
// - `XML` - XML
// - `MULTIPART` - MULTIPART
type RequestFormatEnum uint

const (
	RequestFormatEnumJson RequestFormatEnum = iota + 1
	RequestFormatEnumXml
	RequestFormatEnumMultipart
)

func (r RequestFormatEnum) String() string {
	switch r {
	default:
		return strconv.Itoa(int(r))
	case RequestFormatEnumJson:
		return "JSON"
	case RequestFormatEnumXml:
		return "XML"
	case RequestFormatEnumMultipart:
		return "MULTIPART"
	}
}

func (r RequestFormatEnum) MarshalJSON() ([]byte, error) {
	return []byte(fmt.Sprintf("%q", r.String())), nil
}

func (r *RequestFormatEnum) UnmarshalJSON(data []byte) error {
	var raw string
	if err := json.Unmarshal(data, &raw); err != nil {
		return err
	}
	switch raw {
	case "JSON":
		value := RequestFormatEnumJson
		*r = value
	case "XML":
		value := RequestFormatEnumXml
		*r = value
	case "MULTIPART":
		value := RequestFormatEnumMultipart
		*r = value
	}
	return nil
}

// - `JSON` - JSON
// - `BASE64_GZIP` - BASE64_GZIP
type ResponseTypeEnum uint

const (
	ResponseTypeEnumJson ResponseTypeEnum = iota + 1
	ResponseTypeEnumBase64Gzip
)

func (r ResponseTypeEnum) String() string {
	switch r {
	default:
		return strconv.Itoa(int(r))
	case ResponseTypeEnumJson:
		return "JSON"
	case ResponseTypeEnumBase64Gzip:
		return "BASE64_GZIP"
	}
}

func (r ResponseTypeEnum) MarshalJSON() ([]byte, error) {
	return []byte(fmt.Sprintf("%q", r.String())), nil
}

func (r *ResponseTypeEnum) UnmarshalJSON(data []byte) error {
	var raw string
	if err := json.Unmarshal(data, &raw); err != nil {
		return err
	}
	switch raw {
	case "JSON":
		value := ResponseTypeEnumJson
		*r = value
	case "BASE64_GZIP":
		value := ResponseTypeEnumBase64Gzip
		*r = value
	}
	return nil
}

// - `ADMIN` - ADMIN
// - `DEVELOPER` - DEVELOPER
// - `MEMBER` - MEMBER
// - `API` - API
// - `SYSTEM` - SYSTEM
// - `MERGE_TEAM` - MERGE_TEAM
type RoleEnum uint

const (
	RoleEnumAdmin RoleEnum = iota + 1
	RoleEnumDeveloper
	RoleEnumMember
	RoleEnumApi
	RoleEnumSystem
	RoleEnumMergeTeam
)

func (r RoleEnum) String() string {
	switch r {
	default:
		return strconv.Itoa(int(r))
	case RoleEnumAdmin:
		return "ADMIN"
	case RoleEnumDeveloper:
		return "DEVELOPER"
	case RoleEnumMember:
		return "MEMBER"
	case RoleEnumApi:
		return "API"
	case RoleEnumSystem:
		return "SYSTEM"
	case RoleEnumMergeTeam:
		return "MERGE_TEAM"
	}
}

func (r RoleEnum) MarshalJSON() ([]byte, error) {
	return []byte(fmt.Sprintf("%q", r.String())), nil
}

func (r *RoleEnum) UnmarshalJSON(data []byte) error {
	var raw string
	if err := json.Unmarshal(data, &raw); err != nil {
		return err
	}
	switch raw {
	case "ADMIN":
		value := RoleEnumAdmin
		*r = value
	case "DEVELOPER":
		value := RoleEnumDeveloper
		*r = value
	case "MEMBER":
		value := RoleEnumMember
		*r = value
	case "API":
		value := RoleEnumApi
		*r = value
	case "SYSTEM":
		value := RoleEnumSystem
		*r = value
	case "MERGE_TEAM":
		value := RoleEnumMergeTeam
		*r = value
	}
	return nil
}

// - `READ` - READ
// - `WRITE` - WRITE
// - `OWNER` - OWNER
type RolesEnum uint

const (
	RolesEnumRead RolesEnum = iota + 1
	RolesEnumWrite
	RolesEnumOwner
)

func (r RolesEnum) String() string {
	switch r {
	default:
		return strconv.Itoa(int(r))
	case RolesEnumRead:
		return "READ"
	case RolesEnumWrite:
		return "WRITE"
	case RolesEnumOwner:
		return "OWNER"
	}
}

func (r RolesEnum) MarshalJSON() ([]byte, error) {
	return []byte(fmt.Sprintf("%q", r.String())), nil
}

func (r *RolesEnum) UnmarshalJSON(data []byte) error {
	var raw string
	if err := json.Unmarshal(data, &raw); err != nil {
		return err
	}
	switch raw {
	case "READ":
		value := RolesEnumRead
		*r = value
	case "WRITE":
		value := RolesEnumWrite
		*r = value
	case "OWNER":
		value := RolesEnumOwner
		*r = value
	}
	return nil
}

// - `IN_NEXT_SYNC` - IN_NEXT_SYNC
// - `IN_LAST_SYNC` - IN_LAST_SYNC
type SelectiveSyncConfigurationsUsageEnum uint

const (
	SelectiveSyncConfigurationsUsageEnumInNextSync SelectiveSyncConfigurationsUsageEnum = iota + 1
	SelectiveSyncConfigurationsUsageEnumInLastSync
)

func (s SelectiveSyncConfigurationsUsageEnum) String() string {
	switch s {
	default:
		return strconv.Itoa(int(s))
	case SelectiveSyncConfigurationsUsageEnumInNextSync:
		return "IN_NEXT_SYNC"
	case SelectiveSyncConfigurationsUsageEnumInLastSync:
		return "IN_LAST_SYNC"
	}
}

func (s SelectiveSyncConfigurationsUsageEnum) MarshalJSON() ([]byte, error) {
	return []byte(fmt.Sprintf("%q", s.String())), nil
}

func (s *SelectiveSyncConfigurationsUsageEnum) UnmarshalJSON(data []byte) error {
	var raw string
	if err := json.Unmarshal(data, &raw); err != nil {
		return err
	}
	switch raw {
	case "IN_NEXT_SYNC":
		value := SelectiveSyncConfigurationsUsageEnumInNextSync
		*s = value
	case "IN_LAST_SYNC":
		value := SelectiveSyncConfigurationsUsageEnumInLastSync
		*s = value
	}
	return nil
}

// # The SyncStatus Object
//
// ### Description
//
// # The `SyncStatus` object is used to represent the syncing state of an account
//
// ### Usage Example
//
// View the `SyncStatus` for an account to see how recently its models were synced.
type SyncStatus struct {
	ModelName                        string                                `json:"model_name"`
	ModelId                          string                                `json:"model_id"`
	LastSyncStart                    *time.Time                            `json:"last_sync_start,omitempty"`
	NextSyncStart                    *time.Time                            `json:"next_sync_start,omitempty"`
	Status                           SyncStatusStatusEnum                  `json:"status,omitempty"`
	IsInitialSync                    bool                                  `json:"is_initial_sync"`
	SelectiveSyncConfigurationsUsage *SelectiveSyncConfigurationsUsageEnum `json:"selective_sync_configurations_usage,omitempty"`
}

// - `SYNCING` - SYNCING
// - `DONE` - DONE
// - `FAILED` - FAILED
// - `DISABLED` - DISABLED
// - `PAUSED` - PAUSED
// - `PARTIALLY_SYNCED` - PARTIALLY_SYNCED
type SyncStatusStatusEnum uint

const (
	SyncStatusStatusEnumSyncing SyncStatusStatusEnum = iota + 1
	SyncStatusStatusEnumDone
	SyncStatusStatusEnumFailed
	SyncStatusStatusEnumDisabled
	SyncStatusStatusEnumPaused
	SyncStatusStatusEnumPartiallySynced
)

func (s SyncStatusStatusEnum) String() string {
	switch s {
	default:
		return strconv.Itoa(int(s))
	case SyncStatusStatusEnumSyncing:
		return "SYNCING"
	case SyncStatusStatusEnumDone:
		return "DONE"
	case SyncStatusStatusEnumFailed:
		return "FAILED"
	case SyncStatusStatusEnumDisabled:
		return "DISABLED"
	case SyncStatusStatusEnumPaused:
		return "PAUSED"
	case SyncStatusStatusEnumPartiallySynced:
		return "PARTIALLY_SYNCED"
	}
}

func (s SyncStatusStatusEnum) MarshalJSON() ([]byte, error) {
	return []byte(fmt.Sprintf("%q", s.String())), nil
}

func (s *SyncStatusStatusEnum) UnmarshalJSON(data []byte) error {
	var raw string
	if err := json.Unmarshal(data, &raw); err != nil {
		return err
	}
	switch raw {
	case "SYNCING":
		value := SyncStatusStatusEnumSyncing
		*s = value
	case "DONE":
		value := SyncStatusStatusEnumDone
		*s = value
	case "FAILED":
		value := SyncStatusStatusEnumFailed
		*s = value
	case "DISABLED":
		value := SyncStatusStatusEnumDisabled
		*s = value
	case "PAUSED":
		value := SyncStatusStatusEnumPaused
		*s = value
	case "PARTIALLY_SYNCED":
		value := SyncStatusStatusEnumPartiallySynced
		*s = value
	}
	return nil
}

// - `USER` - USER
// - `GROUP` - GROUP
// - `COMPANY` - COMPANY
// - `ANYONE` - ANYONE
type TypeEnum uint

const (
	TypeEnumUser TypeEnum = iota + 1
	TypeEnumGroup
	TypeEnumCompany
	TypeEnumAnyone
)

func (t TypeEnum) String() string {
	switch t {
	default:
		return strconv.Itoa(int(t))
	case TypeEnumUser:
		return "USER"
	case TypeEnumGroup:
		return "GROUP"
	case TypeEnumCompany:
		return "COMPANY"
	case TypeEnumAnyone:
		return "ANYONE"
	}
}

func (t TypeEnum) MarshalJSON() ([]byte, error) {
	return []byte(fmt.Sprintf("%q", t.String())), nil
}

func (t *TypeEnum) UnmarshalJSON(data []byte) error {
	var raw string
	if err := json.Unmarshal(data, &raw); err != nil {
		return err
	}
	switch raw {
	case "USER":
		value := TypeEnumUser
		*t = value
	case "GROUP":
		value := TypeEnumGroup
		*t = value
	case "COMPANY":
		value := TypeEnumCompany
		*t = value
	case "ANYONE":
		value := TypeEnumAnyone
		*t = value
	}
	return nil
}

// # The User Object
//
// ### Description
//
// The `User` object is used to represent a user within the File Storage account.
//
// ### Usage Example
//
// Fetch from the `GET /api/filestorage/v1/users` endpoint and view their users.
type User struct {
	Id *string `json:"id,omitempty"`
	// The third-party API ID of the matching object.
	RemoteId *string `json:"remote_id,omitempty"`
	// The user's name.
	Name *string `json:"name,omitempty"`
	// The user's email address. This is typically used to identify a user across linked accounts.
	EmailAddress *string `json:"email_address,omitempty"`
	// Whether the user is the one who linked this account.
	IsMe *bool `json:"is_me,omitempty"`
	// Indicates whether or not this object has been deleted in the third party platform.
	RemoteWasDeleted *bool      `json:"remote_was_deleted,omitempty"`
	CreatedAt        *time.Time `json:"created_at,omitempty"`
	// This is the datetime that this object was last updated by Merge
	ModifiedAt    *time.Time       `json:"modified_at,omitempty"`
	FieldMappings map[string]any   `json:"field_mappings,omitempty"`
	RemoteData    []map[string]any `json:"remote_data,omitempty"`
}

type ValidationProblemSource struct {
	Pointer string `json:"pointer"`
}

type WarningValidationProblem struct {
	Source      *ValidationProblemSource `json:"source,omitempty"`
	Title       string                   `json:"title"`
	Detail      string                   `json:"detail"`
	ProblemType string                   `json:"problem_type"`
}

type WebhookReceiver struct {
	Event    string  `json:"event"`
	IsActive bool    `json:"is_active"`
	Key      *string `json:"key,omitempty"`
}
