// This file was auto-generated by Fern from our API Definition.

package filestorage

import (
	json "encoding/json"
	fmt "fmt"
	strconv "strconv"
	time "time"
)

type AccountDetails struct {
	Id                      *string       `json:"id,omitempty"`
	Integration             *string       `json:"integration,omitempty"`
	IntegrationSlug         *string       `json:"integration_slug,omitempty"`
	Category                *CategoryEnum `json:"category,omitempty"`
	EndUserOriginId         *string       `json:"end_user_origin_id,omitempty"`
	EndUserOrganizationName *string       `json:"end_user_organization_name,omitempty"`
	EndUserEmailAddress     *string       `json:"end_user_email_address,omitempty"`
	Status                  *string       `json:"status,omitempty"`
	WebhookListenerUrl      *string       `json:"webhook_listener_url,omitempty"`
	// Whether a Production Linked Account's credentials match another existing Production Linked Account. This field is `null` for Test Linked Accounts, incomplete Production Linked Accounts, and ignored duplicate Production Linked Account sets.
	IsDuplicate *bool `json:"is_duplicate,omitempty"`
}

// # The LinkedAccount Object
// ### Description
// The `LinkedAccount` object is used to represent an end user's link with a specific integration.
//
// ### Usage Example
// View a list of your organization's `LinkedAccount` objects.
type AccountDetailsAndActions struct {
	Id                      string                             `json:"id"`
	Category                *CategoryEnum                      `json:"category,omitempty"`
	Status                  AccountDetailsAndActionsStatusEnum `json:"status,omitempty"`
	StatusDetail            *string                            `json:"status_detail,omitempty"`
	EndUserOriginId         *string                            `json:"end_user_origin_id,omitempty"`
	EndUserOrganizationName string                             `json:"end_user_organization_name"`
	EndUserEmailAddress     string                             `json:"end_user_email_address"`
	WebhookListenerUrl      string                             `json:"webhook_listener_url"`
	// Whether a Production Linked Account's credentials match another existing Production Linked Account. This field is `null` for Test Linked Accounts, incomplete Production Linked Accounts, and ignored duplicate Production Linked Account sets.
	IsDuplicate *bool                                `json:"is_duplicate,omitempty"`
	Integration *AccountDetailsAndActionsIntegration `json:"integration,omitempty"`
}

type AccountDetailsAndActionsIntegration struct {
	Name                     string            `json:"name"`
	Categories               []CategoriesEnum  `json:"categories,omitempty"`
	Image                    *string           `json:"image,omitempty"`
	SquareImage              *string           `json:"square_image,omitempty"`
	Color                    string            `json:"color"`
	Slug                     string            `json:"slug"`
	PassthroughAvailable     bool              `json:"passthrough_available"`
	AvailableModelOperations []*ModelOperation `json:"available_model_operations,omitempty"`
}

// * `COMPLETE` - COMPLETE
// * `INCOMPLETE` - INCOMPLETE
// * `RELINK_NEEDED` - RELINK_NEEDED
type AccountDetailsAndActionsStatusEnum uint

const (
	AccountDetailsAndActionsStatusEnumComplete AccountDetailsAndActionsStatusEnum = iota + 1
	AccountDetailsAndActionsStatusEnumIncomplete
	AccountDetailsAndActionsStatusEnumRelinkNeeded
)

func (a AccountDetailsAndActionsStatusEnum) String() string {
	switch a {
	default:
		return strconv.Itoa(int(a))
	case AccountDetailsAndActionsStatusEnumComplete:
		return "COMPLETE"
	case AccountDetailsAndActionsStatusEnumIncomplete:
		return "INCOMPLETE"
	case AccountDetailsAndActionsStatusEnumRelinkNeeded:
		return "RELINK_NEEDED"
	}
}

func (a AccountDetailsAndActionsStatusEnum) MarshalJSON() ([]byte, error) {
	return []byte(fmt.Sprintf("%q", a.String())), nil
}

func (a *AccountDetailsAndActionsStatusEnum) UnmarshalJSON(data []byte) error {
	var raw string
	if err := json.Unmarshal(data, &raw); err != nil {
		return err
	}
	switch raw {
	case "COMPLETE":
		value := AccountDetailsAndActionsStatusEnumComplete
		*a = value
	case "INCOMPLETE":
		value := AccountDetailsAndActionsStatusEnumIncomplete
		*a = value
	case "RELINK_NEEDED":
		value := AccountDetailsAndActionsStatusEnumRelinkNeeded
		*a = value
	}
	return nil
}

type AccountIntegration struct {
	// Company name.
	Name string `json:"name"`
	// Category or categories this integration belongs to. Multiple categories should be comma separated, i.e. [ats, hris].
	Categories []CategoriesEnum `json:"categories,omitempty"`
	// Company logo in rectangular shape. <b>Upload an image with a clear background.</b>
	Image *string `json:"image,omitempty"`
	// Company logo in square shape. <b>Upload an image with a white background.</b>
	SquareImage *string `json:"square_image,omitempty"`
	// The color of this integration used for buttons and text throughout the app and landing pages. <b>Choose a darker, saturated color.</b> <span style="white-space: nowrap">`<= 18 characters`</span>
	Color *string `json:"color,omitempty"`
	Slug  *string `json:"slug,omitempty"`
	// If checked, this integration will not appear in the linking flow, and will appear elsewhere with a Beta tag.
	IsInBeta *bool `json:"is_in_beta,omitempty"`
	// Mapping of API endpoints to documentation urls for support. Example: {'GET': [['/common-model-scopes', 'https://docs.merge.dev/accounting/common-model-scopes/#common_model_scopes_retrieve'],['/common-model-actions', 'https://docs.merge.dev/accounting/common-model-actions/#common_model_actions_retrieve']], 'POST': []}
	ApiEndpointsToDocumentationUrls map[string]any `json:"api_endpoints_to_documentation_urls,omitempty"`
}

type AccountToken struct {
	AccountToken string              `json:"account_token"`
	Integration  *AccountIntegration `json:"integration,omitempty"`
}

type AsyncPassthroughReciept struct {
	AsyncPassthroughReceiptId string `json:"async_passthrough_receipt_id"`
}

// # The AvailableActions Object
// ### Description
// The `Activity` object is used to see all available model/operation combinations for an integration.
//
// ### Usage Example
// Fetch all the actions available for the `Zenefits` integration.
type AvailableActions struct {
	Integration              *AccountIntegration `json:"integration,omitempty"`
	PassthroughAvailable     bool                `json:"passthrough_available"`
	AvailableModelOperations []*ModelOperation   `json:"available_model_operations,omitempty"`
}

// * `hris` - hris
// * `ats` - ats
// * `accounting` - accounting
// * `ticketing` - ticketing
// * `crm` - crm
// * `mktg` - mktg
// * `filestorage` - filestorage
type CategoriesEnum uint

const (
	CategoriesEnumHris CategoriesEnum = iota + 1
	CategoriesEnumAts
	CategoriesEnumAccounting
	CategoriesEnumTicketing
	CategoriesEnumCrm
	CategoriesEnumMktg
	CategoriesEnumFilestorage
)

func (c CategoriesEnum) String() string {
	switch c {
	default:
		return strconv.Itoa(int(c))
	case CategoriesEnumHris:
		return "hris"
	case CategoriesEnumAts:
		return "ats"
	case CategoriesEnumAccounting:
		return "accounting"
	case CategoriesEnumTicketing:
		return "ticketing"
	case CategoriesEnumCrm:
		return "crm"
	case CategoriesEnumMktg:
		return "mktg"
	case CategoriesEnumFilestorage:
		return "filestorage"
	}
}

func (c CategoriesEnum) MarshalJSON() ([]byte, error) {
	return []byte(fmt.Sprintf("%q", c.String())), nil
}

func (c *CategoriesEnum) UnmarshalJSON(data []byte) error {
	var raw string
	if err := json.Unmarshal(data, &raw); err != nil {
		return err
	}
	switch raw {
	case "hris":
		value := CategoriesEnumHris
		*c = value
	case "ats":
		value := CategoriesEnumAts
		*c = value
	case "accounting":
		value := CategoriesEnumAccounting
		*c = value
	case "ticketing":
		value := CategoriesEnumTicketing
		*c = value
	case "crm":
		value := CategoriesEnumCrm
		*c = value
	case "mktg":
		value := CategoriesEnumMktg
		*c = value
	case "filestorage":
		value := CategoriesEnumFilestorage
		*c = value
	}
	return nil
}

// * `hris` - hris
// * `ats` - ats
// * `accounting` - accounting
// * `ticketing` - ticketing
// * `crm` - crm
// * `mktg` - mktg
// * `filestorage` - filestorage
type CategoryEnum uint

const (
	CategoryEnumHris CategoryEnum = iota + 1
	CategoryEnumAts
	CategoryEnumAccounting
	CategoryEnumTicketing
	CategoryEnumCrm
	CategoryEnumMktg
	CategoryEnumFilestorage
)

func (c CategoryEnum) String() string {
	switch c {
	default:
		return strconv.Itoa(int(c))
	case CategoryEnumHris:
		return "hris"
	case CategoryEnumAts:
		return "ats"
	case CategoryEnumAccounting:
		return "accounting"
	case CategoryEnumTicketing:
		return "ticketing"
	case CategoryEnumCrm:
		return "crm"
	case CategoryEnumMktg:
		return "mktg"
	case CategoryEnumFilestorage:
		return "filestorage"
	}
}

func (c CategoryEnum) MarshalJSON() ([]byte, error) {
	return []byte(fmt.Sprintf("%q", c.String())), nil
}

func (c *CategoryEnum) UnmarshalJSON(data []byte) error {
	var raw string
	if err := json.Unmarshal(data, &raw); err != nil {
		return err
	}
	switch raw {
	case "hris":
		value := CategoryEnumHris
		*c = value
	case "ats":
		value := CategoryEnumAts
		*c = value
	case "accounting":
		value := CategoryEnumAccounting
		*c = value
	case "ticketing":
		value := CategoryEnumTicketing
		*c = value
	case "crm":
		value := CategoryEnumCrm
		*c = value
	case "mktg":
		value := CategoryEnumMktg
		*c = value
	case "filestorage":
		value := CategoryEnumFilestorage
		*c = value
	}
	return nil
}

type CommonModelScopesBodyRequest struct {
	// <span style="white-space: nowrap">`non-empty`</span>
	ModelId        string               `json:"model_id"`
	EnabledActions []EnabledActionsEnum `json:"enabled_actions,omitempty"`
	DisabledFields []string             `json:"disabled_fields,omitempty"`
}

type ConditionSchema struct {
	// The ID of the condition schema. This ID is used when updating selective syncs for a linked account.
	Id string `json:"id"`
	// The common model for which a condition schema is defined.
	CommonModel *string `json:"common_model,omitempty"`
	// User-facing *native condition* name. e.g. "Skip Manager".
	NativeName *string `json:"native_name,omitempty"`
	// The name of the field on the common model that this condition corresponds to, if they conceptually match. e.g. "location_type".
	FieldName *string `json:"field_name,omitempty"`
	// Whether this condition can only be applied once. If false, the condition can be AND'd together multiple times.
	IsUnique *bool `json:"is_unique,omitempty"`
	// The type of value(s) that can be set for this condition.
	//
	// * `BOOLEAN` - BOOLEAN
	// * `DATE` - DATE
	// * `DATE_TIME` - DATE_TIME
	// * `INTEGER` - INTEGER
	// * `FLOAT` - FLOAT
	// * `STRING` - STRING
	// * `LIST_OF_STRINGS` - LIST_OF_STRINGS
	ConditionType *ConditionSchemaConditionType `json:"condition_type,omitempty"`
	// The schemas for the operators that can be used on a condition.
	Operators []*OperatorSchema `json:"operators,omitempty"`
}

// The type of value(s) that can be set for this condition.
//
// * `BOOLEAN` - BOOLEAN
// * `DATE` - DATE
// * `DATE_TIME` - DATE_TIME
// * `INTEGER` - INTEGER
// * `FLOAT` - FLOAT
// * `STRING` - STRING
// * `LIST_OF_STRINGS` - LIST_OF_STRINGS
type ConditionSchemaConditionType struct {
	typeName          string
	ConditionTypeEnum ConditionTypeEnum
	String            string
}

func NewConditionSchemaConditionTypeFromConditionTypeEnum(value ConditionTypeEnum) *ConditionSchemaConditionType {
	return &ConditionSchemaConditionType{typeName: "conditionTypeEnum", ConditionTypeEnum: value}
}

func NewConditionSchemaConditionTypeFromString(value string) *ConditionSchemaConditionType {
	return &ConditionSchemaConditionType{typeName: "string", String: value}
}

func (c *ConditionSchemaConditionType) UnmarshalJSON(data []byte) error {
	var valueConditionTypeEnum ConditionTypeEnum
	if err := json.Unmarshal(data, &valueConditionTypeEnum); err == nil {
		c.typeName = "conditionTypeEnum"
		c.ConditionTypeEnum = valueConditionTypeEnum
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		c.typeName = "string"
		c.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, c)
}

func (c ConditionSchemaConditionType) MarshalJSON() ([]byte, error) {
	switch c.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", c.typeName, c)
	case "conditionTypeEnum":
		return json.Marshal(c.ConditionTypeEnum)
	case "string":
		return json.Marshal(c.String)
	}
}

type ConditionSchemaConditionTypeVisitor interface {
	VisitConditionTypeEnum(ConditionTypeEnum) error
	VisitString(string) error
}

func (c *ConditionSchemaConditionType) Accept(visitor ConditionSchemaConditionTypeVisitor) error {
	switch c.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", c.typeName, c)
	case "conditionTypeEnum":
		return visitor.VisitConditionTypeEnum(c.ConditionTypeEnum)
	case "string":
		return visitor.VisitString(c.String)
	}
}

// * `BOOLEAN` - BOOLEAN
// * `DATE` - DATE
// * `DATE_TIME` - DATE_TIME
// * `INTEGER` - INTEGER
// * `FLOAT` - FLOAT
// * `STRING` - STRING
// * `LIST_OF_STRINGS` - LIST_OF_STRINGS
type ConditionTypeEnum uint

const (
	ConditionTypeEnumBoolean ConditionTypeEnum = iota + 1
	ConditionTypeEnumDate
	ConditionTypeEnumDateTime
	ConditionTypeEnumInteger
	ConditionTypeEnumFloat
	ConditionTypeEnumString
	ConditionTypeEnumListOfStrings
)

func (c ConditionTypeEnum) String() string {
	switch c {
	default:
		return strconv.Itoa(int(c))
	case ConditionTypeEnumBoolean:
		return "BOOLEAN"
	case ConditionTypeEnumDate:
		return "DATE"
	case ConditionTypeEnumDateTime:
		return "DATE_TIME"
	case ConditionTypeEnumInteger:
		return "INTEGER"
	case ConditionTypeEnumFloat:
		return "FLOAT"
	case ConditionTypeEnumString:
		return "STRING"
	case ConditionTypeEnumListOfStrings:
		return "LIST_OF_STRINGS"
	}
}

func (c ConditionTypeEnum) MarshalJSON() ([]byte, error) {
	return []byte(fmt.Sprintf("%q", c.String())), nil
}

func (c *ConditionTypeEnum) UnmarshalJSON(data []byte) error {
	var raw string
	if err := json.Unmarshal(data, &raw); err != nil {
		return err
	}
	switch raw {
	case "BOOLEAN":
		value := ConditionTypeEnumBoolean
		*c = value
	case "DATE":
		value := ConditionTypeEnumDate
		*c = value
	case "DATE_TIME":
		value := ConditionTypeEnumDateTime
		*c = value
	case "INTEGER":
		value := ConditionTypeEnumInteger
		*c = value
	case "FLOAT":
		value := ConditionTypeEnumFloat
		*c = value
	case "STRING":
		value := ConditionTypeEnumString
		*c = value
	case "LIST_OF_STRINGS":
		value := ConditionTypeEnumListOfStrings
		*c = value
	}
	return nil
}

// # The DataPassthrough Object
// ### Description
// The `DataPassthrough` object is used to send information to an otherwise-unsupported third-party endpoint.
//
// ### Usage Example
// Create a `DataPassthrough` to get team hierarchies from your Rippling integration.
type DataPassthroughRequest struct {
	Method MethodEnum `json:"method,omitempty"`
	// <span style="white-space: nowrap">`non-empty`</span>
	Path string `json:"path"`
	// <span style="white-space: nowrap">`non-empty`</span>
	BaseUrlOverride *string `json:"base_url_override,omitempty"`
	// <span style="white-space: nowrap">`non-empty`</span>
	Data *string `json:"data,omitempty"`
	// Pass an array of `MultipartFormField` objects in here instead of using the `data` param if `request_format` is set to `MULTIPART`.
	MultipartFormData []*MultipartFormFieldRequest `json:"multipart_form_data,omitempty"`
	// The headers to use for the request (Merge will handle the account's authorization headers). `Content-Type` header is required for passthrough. Choose content type corresponding to expected format of receiving server.
	Headers       map[string]any     `json:"headers,omitempty"`
	RequestFormat *RequestFormatEnum `json:"request_format,omitempty"`
	// Optional. If true, the response will always be an object of the form `{"type": T, "value": ...}` where `T` will be one of `string, boolean, number, null, array, object`.
	NormalizeResponse *bool `json:"normalize_response,omitempty"`
}

type DebugModeLog struct {
	LogId         string                `json:"log_id"`
	DashboardView string                `json:"dashboard_view"`
	LogSummary    *DebugModelLogSummary `json:"log_summary,omitempty"`
}

type DebugModelLogSummary struct {
	Url        string `json:"url"`
	Method     string `json:"method"`
	StatusCode int    `json:"status_code"`
}

// # The Drive Object
// ### Description
// The `Drive` object is used to represent a drive that contains the folders and files in the user's workspace.
// ### Usage Example
// Fetch from the `GET /api/filestorage/v1/drives` endpoint and view their drives.
type Drive struct {
	Id *string `json:"id,omitempty"`
	// The third-party API ID of the matching object.
	RemoteId *string `json:"remote_id,omitempty"`
	// The drive's name.
	Name *string `json:"name,omitempty"`
	// When the third party's drive was created.
	RemoteCreatedAt *time.Time `json:"remote_created_at,omitempty"`
	// The drive's url.
	DriveUrl *string `json:"drive_url,omitempty"`
	// Indicates whether or not this object has been deleted by third party webhooks.
	RemoteWasDeleted *bool `json:"remote_was_deleted,omitempty"`
	// This is the datetime that this object was last updated by Merge
	ModifiedAt    *time.Time       `json:"modified_at,omitempty"`
	FieldMappings map[string]any   `json:"field_mappings,omitempty"`
	RemoteData    []map[string]any `json:"remote_data,omitempty"`
}

// * `READ` - READ
// * `WRITE` - WRITE
type EnabledActionsEnum uint

const (
	EnabledActionsEnumRead EnabledActionsEnum = iota + 1
	EnabledActionsEnumWrite
)

func (e EnabledActionsEnum) String() string {
	switch e {
	default:
		return strconv.Itoa(int(e))
	case EnabledActionsEnumRead:
		return "READ"
	case EnabledActionsEnumWrite:
		return "WRITE"
	}
}

func (e EnabledActionsEnum) MarshalJSON() ([]byte, error) {
	return []byte(fmt.Sprintf("%q", e.String())), nil
}

func (e *EnabledActionsEnum) UnmarshalJSON(data []byte) error {
	var raw string
	if err := json.Unmarshal(data, &raw); err != nil {
		return err
	}
	switch raw {
	case "READ":
		value := EnabledActionsEnumRead
		*e = value
	case "WRITE":
		value := EnabledActionsEnumWrite
		*e = value
	}
	return nil
}

// * `RAW` - RAW
// * `BASE64` - BASE64
// * `GZIP_BASE64` - GZIP_BASE64
type EncodingEnum uint

const (
	EncodingEnumRaw EncodingEnum = iota + 1
	EncodingEnumBase64
	EncodingEnumGzipBase64
)

func (e EncodingEnum) String() string {
	switch e {
	default:
		return strconv.Itoa(int(e))
	case EncodingEnumRaw:
		return "RAW"
	case EncodingEnumBase64:
		return "BASE64"
	case EncodingEnumGzipBase64:
		return "GZIP_BASE64"
	}
}

func (e EncodingEnum) MarshalJSON() ([]byte, error) {
	return []byte(fmt.Sprintf("%q", e.String())), nil
}

func (e *EncodingEnum) UnmarshalJSON(data []byte) error {
	var raw string
	if err := json.Unmarshal(data, &raw); err != nil {
		return err
	}
	switch raw {
	case "RAW":
		value := EncodingEnumRaw
		*e = value
	case "BASE64":
		value := EncodingEnumBase64
		*e = value
	case "GZIP_BASE64":
		value := EncodingEnumGzipBase64
		*e = value
	}
	return nil
}

type ErrorValidationProblem struct {
	Source      *ValidationProblemSource `json:"source,omitempty"`
	Title       string                   `json:"title"`
	Detail      string                   `json:"detail"`
	ProblemType string                   `json:"problem_type"`
}

// # The File Object
// ### Description
// The `File` object is used to represent a file in the workspace. The Object typically exists under a folder or drive, if it exists.
// ### Usage Example
// Fetch from the `GET /api/filestorage/v1/files` endpoint and view their files.
type File struct {
	Id *string `json:"id,omitempty"`
	// The third-party API ID of the matching object.
	RemoteId *string `json:"remote_id,omitempty"`
	// The file's name.
	Name *string `json:"name,omitempty"`
	// The URL to access the file.
	FileUrl *string `json:"file_url,omitempty"`
	// The URL that produces a thumbnail preview of the file. Typically an image.
	FileThumbnailUrl *string `json:"file_thumbnail_url,omitempty"`
	// The file's size, in bytes.
	Size *int `json:"size,omitempty"`
	// The file's mime type.
	MimeType *string `json:"mime_type,omitempty"`
	// The file's description.
	Description *string `json:"description,omitempty"`
	// The folder that the file belongs to.
	Folder *string `json:"folder,omitempty"`
	// The Permission object is used to represent a user's or group's access to a File or Folder. Permissions are unexpanded by default. Use the query param `expand=permissions` to see more details under `GET /files`.
	Permissions *FilePermissions `json:"permissions,omitempty"`
	// The drive that the file belongs to.
	Drive *string `json:"drive,omitempty"`
	// When the third party's file was created.
	RemoteCreatedAt *time.Time `json:"remote_created_at,omitempty"`
	// When the third party's file was updated.
	RemoteUpdatedAt *time.Time `json:"remote_updated_at,omitempty"`
	// Indicates whether or not this object has been deleted by third party webhooks.
	RemoteWasDeleted *bool `json:"remote_was_deleted,omitempty"`
	// This is the datetime that this object was last updated by Merge
	ModifiedAt    *time.Time       `json:"modified_at,omitempty"`
	FieldMappings map[string]any   `json:"field_mappings,omitempty"`
	RemoteData    []map[string]any `json:"remote_data,omitempty"`
}

// The Permission object is used to represent a user's or group's access to a File or Folder. Permissions are unexpanded by default. Use the query param `expand=permissions` to see more details under `GET /files`.
type FilePermissions struct {
	typeName                string
	String                  string
	Unknown                 any
	FilePermissionsItemList []*FilePermissionsItem
}

func NewFilePermissionsFromString(value string) *FilePermissions {
	return &FilePermissions{typeName: "string", String: value}
}

func NewFilePermissionsFromUnknown(value any) *FilePermissions {
	return &FilePermissions{typeName: "unknown", Unknown: value}
}

func NewFilePermissionsFromFilePermissionsItemList(value []*FilePermissionsItem) *FilePermissions {
	return &FilePermissions{typeName: "filePermissionsItemList", FilePermissionsItemList: value}
}

func (f *FilePermissions) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		f.typeName = "string"
		f.String = valueString
		return nil
	}
	var valueUnknown any
	if err := json.Unmarshal(data, &valueUnknown); err == nil {
		f.typeName = "unknown"
		f.Unknown = valueUnknown
		return nil
	}
	var valueFilePermissionsItemList []*FilePermissionsItem
	if err := json.Unmarshal(data, &valueFilePermissionsItemList); err == nil {
		f.typeName = "filePermissionsItemList"
		f.FilePermissionsItemList = valueFilePermissionsItemList
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, f)
}

func (f FilePermissions) MarshalJSON() ([]byte, error) {
	switch f.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", f.typeName, f)
	case "string":
		return json.Marshal(f.String)
	case "unknown":
		return json.Marshal(f.Unknown)
	case "filePermissionsItemList":
		return json.Marshal(f.FilePermissionsItemList)
	}
}

type FilePermissionsVisitor interface {
	VisitString(string) error
	VisitUnknown(any) error
	VisitFilePermissionsItemList([]*FilePermissionsItem) error
}

func (f *FilePermissions) Accept(visitor FilePermissionsVisitor) error {
	switch f.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", f.typeName, f)
	case "string":
		return visitor.VisitString(f.String)
	case "unknown":
		return visitor.VisitUnknown(f.Unknown)
	case "filePermissionsItemList":
		return visitor.VisitFilePermissionsItemList(f.FilePermissionsItemList)
	}
}

type FilePermissionsItem struct {
	typeName          string
	String            string
	PermissionRequest *PermissionRequest
}

func NewFilePermissionsItemFromString(value string) *FilePermissionsItem {
	return &FilePermissionsItem{typeName: "string", String: value}
}

func NewFilePermissionsItemFromPermissionRequest(value *PermissionRequest) *FilePermissionsItem {
	return &FilePermissionsItem{typeName: "permissionRequest", PermissionRequest: value}
}

func (f *FilePermissionsItem) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		f.typeName = "string"
		f.String = valueString
		return nil
	}
	valuePermissionRequest := new(PermissionRequest)
	if err := json.Unmarshal(data, &valuePermissionRequest); err == nil {
		f.typeName = "permissionRequest"
		f.PermissionRequest = valuePermissionRequest
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, f)
}

func (f FilePermissionsItem) MarshalJSON() ([]byte, error) {
	switch f.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", f.typeName, f)
	case "string":
		return json.Marshal(f.String)
	case "permissionRequest":
		return json.Marshal(f.PermissionRequest)
	}
}

type FilePermissionsItemVisitor interface {
	VisitString(string) error
	VisitPermissionRequest(*PermissionRequest) error
}

func (f *FilePermissionsItem) Accept(visitor FilePermissionsItemVisitor) error {
	switch f.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", f.typeName, f)
	case "string":
		return visitor.VisitString(f.String)
	case "permissionRequest":
		return visitor.VisitPermissionRequest(f.PermissionRequest)
	}
}

// # The File Object
// ### Description
// The `File` object is used to represent a file in the workspace. The Object typically exists under a folder or drive, if it exists.
// ### Usage Example
// Fetch from the `GET /api/filestorage/v1/files` endpoint and view their files.
type FileRequest struct {
	// The file's name.
	Name *string `json:"name,omitempty"`
	// The URL to access the file.
	FileUrl *string `json:"file_url,omitempty"`
	// The URL that produces a thumbnail preview of the file. Typically an image.
	FileThumbnailUrl *string `json:"file_thumbnail_url,omitempty"`
	// The file's size, in bytes.
	Size *int `json:"size,omitempty"`
	// The file's mime type.
	MimeType *string `json:"mime_type,omitempty"`
	// The file's description.
	Description *string `json:"description,omitempty"`
	// The folder that the file belongs to.
	Folder *string `json:"folder,omitempty"`
	// The Permission object is used to represent a user's or group's access to a File or Folder. Permissions are unexpanded by default. Use the query param `expand=permissions` to see more details under `GET /files`.
	Permissions *FileRequestPermissions `json:"permissions,omitempty"`
	// The drive that the file belongs to.
	Drive               *string        `json:"drive,omitempty"`
	IntegrationParams   map[string]any `json:"integration_params,omitempty"`
	LinkedAccountParams map[string]any `json:"linked_account_params,omitempty"`
}

// The Permission object is used to represent a user's or group's access to a File or Folder. Permissions are unexpanded by default. Use the query param `expand=permissions` to see more details under `GET /files`.
type FileRequestPermissions struct {
	typeName                       string
	String                         string
	Unknown                        any
	FileRequestPermissionsItemList []*FileRequestPermissionsItem
}

func NewFileRequestPermissionsFromString(value string) *FileRequestPermissions {
	return &FileRequestPermissions{typeName: "string", String: value}
}

func NewFileRequestPermissionsFromUnknown(value any) *FileRequestPermissions {
	return &FileRequestPermissions{typeName: "unknown", Unknown: value}
}

func NewFileRequestPermissionsFromFileRequestPermissionsItemList(value []*FileRequestPermissionsItem) *FileRequestPermissions {
	return &FileRequestPermissions{typeName: "fileRequestPermissionsItemList", FileRequestPermissionsItemList: value}
}

func (f *FileRequestPermissions) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		f.typeName = "string"
		f.String = valueString
		return nil
	}
	var valueUnknown any
	if err := json.Unmarshal(data, &valueUnknown); err == nil {
		f.typeName = "unknown"
		f.Unknown = valueUnknown
		return nil
	}
	var valueFileRequestPermissionsItemList []*FileRequestPermissionsItem
	if err := json.Unmarshal(data, &valueFileRequestPermissionsItemList); err == nil {
		f.typeName = "fileRequestPermissionsItemList"
		f.FileRequestPermissionsItemList = valueFileRequestPermissionsItemList
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, f)
}

func (f FileRequestPermissions) MarshalJSON() ([]byte, error) {
	switch f.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", f.typeName, f)
	case "string":
		return json.Marshal(f.String)
	case "unknown":
		return json.Marshal(f.Unknown)
	case "fileRequestPermissionsItemList":
		return json.Marshal(f.FileRequestPermissionsItemList)
	}
}

type FileRequestPermissionsVisitor interface {
	VisitString(string) error
	VisitUnknown(any) error
	VisitFileRequestPermissionsItemList([]*FileRequestPermissionsItem) error
}

func (f *FileRequestPermissions) Accept(visitor FileRequestPermissionsVisitor) error {
	switch f.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", f.typeName, f)
	case "string":
		return visitor.VisitString(f.String)
	case "unknown":
		return visitor.VisitUnknown(f.Unknown)
	case "fileRequestPermissionsItemList":
		return visitor.VisitFileRequestPermissionsItemList(f.FileRequestPermissionsItemList)
	}
}

type FileRequestPermissionsItem struct {
	typeName          string
	String            string
	PermissionRequest *PermissionRequest
}

func NewFileRequestPermissionsItemFromString(value string) *FileRequestPermissionsItem {
	return &FileRequestPermissionsItem{typeName: "string", String: value}
}

func NewFileRequestPermissionsItemFromPermissionRequest(value *PermissionRequest) *FileRequestPermissionsItem {
	return &FileRequestPermissionsItem{typeName: "permissionRequest", PermissionRequest: value}
}

func (f *FileRequestPermissionsItem) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		f.typeName = "string"
		f.String = valueString
		return nil
	}
	valuePermissionRequest := new(PermissionRequest)
	if err := json.Unmarshal(data, &valuePermissionRequest); err == nil {
		f.typeName = "permissionRequest"
		f.PermissionRequest = valuePermissionRequest
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, f)
}

func (f FileRequestPermissionsItem) MarshalJSON() ([]byte, error) {
	switch f.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", f.typeName, f)
	case "string":
		return json.Marshal(f.String)
	case "permissionRequest":
		return json.Marshal(f.PermissionRequest)
	}
}

type FileRequestPermissionsItemVisitor interface {
	VisitString(string) error
	VisitPermissionRequest(*PermissionRequest) error
}

func (f *FileRequestPermissionsItem) Accept(visitor FileRequestPermissionsItemVisitor) error {
	switch f.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", f.typeName, f)
	case "string":
		return visitor.VisitString(f.String)
	case "permissionRequest":
		return visitor.VisitPermissionRequest(f.PermissionRequest)
	}
}

type FileStorageFileResponse struct {
	Model    *File                       `json:"model,omitempty"`
	Warnings []*WarningValidationProblem `json:"warnings,omitempty"`
	Errors   []*ErrorValidationProblem   `json:"errors,omitempty"`
	Logs     []*DebugModeLog             `json:"logs,omitempty"`
}

type FileStorageFolderResponse struct {
	Model    *Folder                     `json:"model,omitempty"`
	Warnings []*WarningValidationProblem `json:"warnings,omitempty"`
	Errors   []*ErrorValidationProblem   `json:"errors,omitempty"`
	Logs     []*DebugModeLog             `json:"logs,omitempty"`
}

type FilesListRequestExpand uint

const (
	FilesListRequestExpandDrive FilesListRequestExpand = iota + 1
	FilesListRequestExpandFolder
	FilesListRequestExpandFolderDrive
	FilesListRequestExpandPermissions
	FilesListRequestExpandPermissionsDrive
	FilesListRequestExpandPermissionsFolder
	FilesListRequestExpandPermissionsFolderDrive
)

func (f FilesListRequestExpand) String() string {
	switch f {
	default:
		return strconv.Itoa(int(f))
	case FilesListRequestExpandDrive:
		return "drive"
	case FilesListRequestExpandFolder:
		return "folder"
	case FilesListRequestExpandFolderDrive:
		return "folder,drive"
	case FilesListRequestExpandPermissions:
		return "permissions"
	case FilesListRequestExpandPermissionsDrive:
		return "permissions,drive"
	case FilesListRequestExpandPermissionsFolder:
		return "permissions,folder"
	case FilesListRequestExpandPermissionsFolderDrive:
		return "permissions,folder,drive"
	}
}

func (f FilesListRequestExpand) MarshalJSON() ([]byte, error) {
	return []byte(fmt.Sprintf("%q", f.String())), nil
}

func (f *FilesListRequestExpand) UnmarshalJSON(data []byte) error {
	var raw string
	if err := json.Unmarshal(data, &raw); err != nil {
		return err
	}
	switch raw {
	case "drive":
		value := FilesListRequestExpandDrive
		*f = value
	case "folder":
		value := FilesListRequestExpandFolder
		*f = value
	case "folder,drive":
		value := FilesListRequestExpandFolderDrive
		*f = value
	case "permissions":
		value := FilesListRequestExpandPermissions
		*f = value
	case "permissions,drive":
		value := FilesListRequestExpandPermissionsDrive
		*f = value
	case "permissions,folder":
		value := FilesListRequestExpandPermissionsFolder
		*f = value
	case "permissions,folder,drive":
		value := FilesListRequestExpandPermissionsFolderDrive
		*f = value
	}
	return nil
}

type FilesRetrieveRequestExpand uint

const (
	FilesRetrieveRequestExpandDrive FilesRetrieveRequestExpand = iota + 1
	FilesRetrieveRequestExpandFolder
	FilesRetrieveRequestExpandFolderDrive
	FilesRetrieveRequestExpandPermissions
	FilesRetrieveRequestExpandPermissionsDrive
	FilesRetrieveRequestExpandPermissionsFolder
	FilesRetrieveRequestExpandPermissionsFolderDrive
)

func (f FilesRetrieveRequestExpand) String() string {
	switch f {
	default:
		return strconv.Itoa(int(f))
	case FilesRetrieveRequestExpandDrive:
		return "drive"
	case FilesRetrieveRequestExpandFolder:
		return "folder"
	case FilesRetrieveRequestExpandFolderDrive:
		return "folder,drive"
	case FilesRetrieveRequestExpandPermissions:
		return "permissions"
	case FilesRetrieveRequestExpandPermissionsDrive:
		return "permissions,drive"
	case FilesRetrieveRequestExpandPermissionsFolder:
		return "permissions,folder"
	case FilesRetrieveRequestExpandPermissionsFolderDrive:
		return "permissions,folder,drive"
	}
}

func (f FilesRetrieveRequestExpand) MarshalJSON() ([]byte, error) {
	return []byte(fmt.Sprintf("%q", f.String())), nil
}

func (f *FilesRetrieveRequestExpand) UnmarshalJSON(data []byte) error {
	var raw string
	if err := json.Unmarshal(data, &raw); err != nil {
		return err
	}
	switch raw {
	case "drive":
		value := FilesRetrieveRequestExpandDrive
		*f = value
	case "folder":
		value := FilesRetrieveRequestExpandFolder
		*f = value
	case "folder,drive":
		value := FilesRetrieveRequestExpandFolderDrive
		*f = value
	case "permissions":
		value := FilesRetrieveRequestExpandPermissions
		*f = value
	case "permissions,drive":
		value := FilesRetrieveRequestExpandPermissionsDrive
		*f = value
	case "permissions,folder":
		value := FilesRetrieveRequestExpandPermissionsFolder
		*f = value
	case "permissions,folder,drive":
		value := FilesRetrieveRequestExpandPermissionsFolderDrive
		*f = value
	}
	return nil
}

// # The Folder Object
// ### Description
// The `Folder` object is used to represent a collection of files and/or folders in the workspace. Could be within a drive, if it exists.
// ### Usage Example
// Fetch from the `GET /api/filestorage/v1/folders` endpoint and view their folders.
type Folder struct {
	Id *string `json:"id,omitempty"`
	// The third-party API ID of the matching object.
	RemoteId *string `json:"remote_id,omitempty"`
	// The folder's name.
	Name *string `json:"name,omitempty"`
	// The URL to access the folder.
	FolderUrl *string `json:"folder_url,omitempty"`
	// The folder's size, in bytes.
	Size *int `json:"size,omitempty"`
	// The folder's description.
	Description *string `json:"description,omitempty"`
	// The folder that the folder belongs to.
	ParentFolder *string `json:"parent_folder,omitempty"`
	// The drive that the folder belongs to.
	Drive *string `json:"drive,omitempty"`
	// The Permission object is used to represent a user's or group's access to a File or Folder. Permissions are unexpanded by default. Use the query param `expand=permissions` to see more details under `GET /folders`.
	Permissions *FolderPermissions `json:"permissions,omitempty"`
	// When the third party's folder was created.
	RemoteCreatedAt *time.Time `json:"remote_created_at,omitempty"`
	// When the third party's folder was updated.
	RemoteUpdatedAt *time.Time `json:"remote_updated_at,omitempty"`
	// Indicates whether or not this object has been deleted by third party webhooks.
	RemoteWasDeleted *bool `json:"remote_was_deleted,omitempty"`
	// This is the datetime that this object was last updated by Merge
	ModifiedAt    *time.Time       `json:"modified_at,omitempty"`
	FieldMappings map[string]any   `json:"field_mappings,omitempty"`
	RemoteData    []map[string]any `json:"remote_data,omitempty"`
}

// The Permission object is used to represent a user's or group's access to a File or Folder. Permissions are unexpanded by default. Use the query param `expand=permissions` to see more details under `GET /folders`.
type FolderPermissions struct {
	typeName                  string
	String                    string
	Unknown                   any
	FolderPermissionsItemList []*FolderPermissionsItem
}

func NewFolderPermissionsFromString(value string) *FolderPermissions {
	return &FolderPermissions{typeName: "string", String: value}
}

func NewFolderPermissionsFromUnknown(value any) *FolderPermissions {
	return &FolderPermissions{typeName: "unknown", Unknown: value}
}

func NewFolderPermissionsFromFolderPermissionsItemList(value []*FolderPermissionsItem) *FolderPermissions {
	return &FolderPermissions{typeName: "folderPermissionsItemList", FolderPermissionsItemList: value}
}

func (f *FolderPermissions) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		f.typeName = "string"
		f.String = valueString
		return nil
	}
	var valueUnknown any
	if err := json.Unmarshal(data, &valueUnknown); err == nil {
		f.typeName = "unknown"
		f.Unknown = valueUnknown
		return nil
	}
	var valueFolderPermissionsItemList []*FolderPermissionsItem
	if err := json.Unmarshal(data, &valueFolderPermissionsItemList); err == nil {
		f.typeName = "folderPermissionsItemList"
		f.FolderPermissionsItemList = valueFolderPermissionsItemList
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, f)
}

func (f FolderPermissions) MarshalJSON() ([]byte, error) {
	switch f.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", f.typeName, f)
	case "string":
		return json.Marshal(f.String)
	case "unknown":
		return json.Marshal(f.Unknown)
	case "folderPermissionsItemList":
		return json.Marshal(f.FolderPermissionsItemList)
	}
}

type FolderPermissionsVisitor interface {
	VisitString(string) error
	VisitUnknown(any) error
	VisitFolderPermissionsItemList([]*FolderPermissionsItem) error
}

func (f *FolderPermissions) Accept(visitor FolderPermissionsVisitor) error {
	switch f.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", f.typeName, f)
	case "string":
		return visitor.VisitString(f.String)
	case "unknown":
		return visitor.VisitUnknown(f.Unknown)
	case "folderPermissionsItemList":
		return visitor.VisitFolderPermissionsItemList(f.FolderPermissionsItemList)
	}
}

type FolderPermissionsItem struct {
	typeName          string
	String            string
	PermissionRequest *PermissionRequest
}

func NewFolderPermissionsItemFromString(value string) *FolderPermissionsItem {
	return &FolderPermissionsItem{typeName: "string", String: value}
}

func NewFolderPermissionsItemFromPermissionRequest(value *PermissionRequest) *FolderPermissionsItem {
	return &FolderPermissionsItem{typeName: "permissionRequest", PermissionRequest: value}
}

func (f *FolderPermissionsItem) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		f.typeName = "string"
		f.String = valueString
		return nil
	}
	valuePermissionRequest := new(PermissionRequest)
	if err := json.Unmarshal(data, &valuePermissionRequest); err == nil {
		f.typeName = "permissionRequest"
		f.PermissionRequest = valuePermissionRequest
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, f)
}

func (f FolderPermissionsItem) MarshalJSON() ([]byte, error) {
	switch f.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", f.typeName, f)
	case "string":
		return json.Marshal(f.String)
	case "permissionRequest":
		return json.Marshal(f.PermissionRequest)
	}
}

type FolderPermissionsItemVisitor interface {
	VisitString(string) error
	VisitPermissionRequest(*PermissionRequest) error
}

func (f *FolderPermissionsItem) Accept(visitor FolderPermissionsItemVisitor) error {
	switch f.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", f.typeName, f)
	case "string":
		return visitor.VisitString(f.String)
	case "permissionRequest":
		return visitor.VisitPermissionRequest(f.PermissionRequest)
	}
}

// # The Folder Object
// ### Description
// The `Folder` object is used to represent a collection of files and/or folders in the workspace. Could be within a drive, if it exists.
// ### Usage Example
// Fetch from the `GET /api/filestorage/v1/folders` endpoint and view their folders.
type FolderRequest struct {
	// The folder's name.
	Name *string `json:"name,omitempty"`
	// The URL to access the folder.
	FolderUrl *string `json:"folder_url,omitempty"`
	// The folder's size, in bytes.
	Size *int `json:"size,omitempty"`
	// The folder's description.
	Description *string `json:"description,omitempty"`
	// The folder that the folder belongs to.
	ParentFolder *string `json:"parent_folder,omitempty"`
	// The drive that the folder belongs to.
	Drive *string `json:"drive,omitempty"`
	// The Permission object is used to represent a user's or group's access to a File or Folder. Permissions are unexpanded by default. Use the query param `expand=permissions` to see more details under `GET /folders`.
	Permissions         *FolderRequestPermissions `json:"permissions,omitempty"`
	IntegrationParams   map[string]any            `json:"integration_params,omitempty"`
	LinkedAccountParams map[string]any            `json:"linked_account_params,omitempty"`
}

// The Permission object is used to represent a user's or group's access to a File or Folder. Permissions are unexpanded by default. Use the query param `expand=permissions` to see more details under `GET /folders`.
type FolderRequestPermissions struct {
	typeName                         string
	String                           string
	Unknown                          any
	FolderRequestPermissionsItemList []*FolderRequestPermissionsItem
}

func NewFolderRequestPermissionsFromString(value string) *FolderRequestPermissions {
	return &FolderRequestPermissions{typeName: "string", String: value}
}

func NewFolderRequestPermissionsFromUnknown(value any) *FolderRequestPermissions {
	return &FolderRequestPermissions{typeName: "unknown", Unknown: value}
}

func NewFolderRequestPermissionsFromFolderRequestPermissionsItemList(value []*FolderRequestPermissionsItem) *FolderRequestPermissions {
	return &FolderRequestPermissions{typeName: "folderRequestPermissionsItemList", FolderRequestPermissionsItemList: value}
}

func (f *FolderRequestPermissions) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		f.typeName = "string"
		f.String = valueString
		return nil
	}
	var valueUnknown any
	if err := json.Unmarshal(data, &valueUnknown); err == nil {
		f.typeName = "unknown"
		f.Unknown = valueUnknown
		return nil
	}
	var valueFolderRequestPermissionsItemList []*FolderRequestPermissionsItem
	if err := json.Unmarshal(data, &valueFolderRequestPermissionsItemList); err == nil {
		f.typeName = "folderRequestPermissionsItemList"
		f.FolderRequestPermissionsItemList = valueFolderRequestPermissionsItemList
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, f)
}

func (f FolderRequestPermissions) MarshalJSON() ([]byte, error) {
	switch f.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", f.typeName, f)
	case "string":
		return json.Marshal(f.String)
	case "unknown":
		return json.Marshal(f.Unknown)
	case "folderRequestPermissionsItemList":
		return json.Marshal(f.FolderRequestPermissionsItemList)
	}
}

type FolderRequestPermissionsVisitor interface {
	VisitString(string) error
	VisitUnknown(any) error
	VisitFolderRequestPermissionsItemList([]*FolderRequestPermissionsItem) error
}

func (f *FolderRequestPermissions) Accept(visitor FolderRequestPermissionsVisitor) error {
	switch f.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", f.typeName, f)
	case "string":
		return visitor.VisitString(f.String)
	case "unknown":
		return visitor.VisitUnknown(f.Unknown)
	case "folderRequestPermissionsItemList":
		return visitor.VisitFolderRequestPermissionsItemList(f.FolderRequestPermissionsItemList)
	}
}

type FolderRequestPermissionsItem struct {
	typeName          string
	String            string
	PermissionRequest *PermissionRequest
}

func NewFolderRequestPermissionsItemFromString(value string) *FolderRequestPermissionsItem {
	return &FolderRequestPermissionsItem{typeName: "string", String: value}
}

func NewFolderRequestPermissionsItemFromPermissionRequest(value *PermissionRequest) *FolderRequestPermissionsItem {
	return &FolderRequestPermissionsItem{typeName: "permissionRequest", PermissionRequest: value}
}

func (f *FolderRequestPermissionsItem) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		f.typeName = "string"
		f.String = valueString
		return nil
	}
	valuePermissionRequest := new(PermissionRequest)
	if err := json.Unmarshal(data, &valuePermissionRequest); err == nil {
		f.typeName = "permissionRequest"
		f.PermissionRequest = valuePermissionRequest
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, f)
}

func (f FolderRequestPermissionsItem) MarshalJSON() ([]byte, error) {
	switch f.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", f.typeName, f)
	case "string":
		return json.Marshal(f.String)
	case "permissionRequest":
		return json.Marshal(f.PermissionRequest)
	}
}

type FolderRequestPermissionsItemVisitor interface {
	VisitString(string) error
	VisitPermissionRequest(*PermissionRequest) error
}

func (f *FolderRequestPermissionsItem) Accept(visitor FolderRequestPermissionsItemVisitor) error {
	switch f.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", f.typeName, f)
	case "string":
		return visitor.VisitString(f.String)
	case "permissionRequest":
		return visitor.VisitPermissionRequest(f.PermissionRequest)
	}
}

type FoldersListRequestExpand uint

const (
	FoldersListRequestExpandDrive FoldersListRequestExpand = iota + 1
	FoldersListRequestExpandParentFolder
	FoldersListRequestExpandParentFolderDrive
	FoldersListRequestExpandPermissions
	FoldersListRequestExpandPermissionsDrive
	FoldersListRequestExpandPermissionsParentFolder
	FoldersListRequestExpandPermissionsParentFolderDrive
)

func (f FoldersListRequestExpand) String() string {
	switch f {
	default:
		return strconv.Itoa(int(f))
	case FoldersListRequestExpandDrive:
		return "drive"
	case FoldersListRequestExpandParentFolder:
		return "parent_folder"
	case FoldersListRequestExpandParentFolderDrive:
		return "parent_folder,drive"
	case FoldersListRequestExpandPermissions:
		return "permissions"
	case FoldersListRequestExpandPermissionsDrive:
		return "permissions,drive"
	case FoldersListRequestExpandPermissionsParentFolder:
		return "permissions,parent_folder"
	case FoldersListRequestExpandPermissionsParentFolderDrive:
		return "permissions,parent_folder,drive"
	}
}

func (f FoldersListRequestExpand) MarshalJSON() ([]byte, error) {
	return []byte(fmt.Sprintf("%q", f.String())), nil
}

func (f *FoldersListRequestExpand) UnmarshalJSON(data []byte) error {
	var raw string
	if err := json.Unmarshal(data, &raw); err != nil {
		return err
	}
	switch raw {
	case "drive":
		value := FoldersListRequestExpandDrive
		*f = value
	case "parent_folder":
		value := FoldersListRequestExpandParentFolder
		*f = value
	case "parent_folder,drive":
		value := FoldersListRequestExpandParentFolderDrive
		*f = value
	case "permissions":
		value := FoldersListRequestExpandPermissions
		*f = value
	case "permissions,drive":
		value := FoldersListRequestExpandPermissionsDrive
		*f = value
	case "permissions,parent_folder":
		value := FoldersListRequestExpandPermissionsParentFolder
		*f = value
	case "permissions,parent_folder,drive":
		value := FoldersListRequestExpandPermissionsParentFolderDrive
		*f = value
	}
	return nil
}

type FoldersRetrieveRequestExpand uint

const (
	FoldersRetrieveRequestExpandDrive FoldersRetrieveRequestExpand = iota + 1
	FoldersRetrieveRequestExpandParentFolder
	FoldersRetrieveRequestExpandParentFolderDrive
	FoldersRetrieveRequestExpandPermissions
	FoldersRetrieveRequestExpandPermissionsDrive
	FoldersRetrieveRequestExpandPermissionsParentFolder
	FoldersRetrieveRequestExpandPermissionsParentFolderDrive
)

func (f FoldersRetrieveRequestExpand) String() string {
	switch f {
	default:
		return strconv.Itoa(int(f))
	case FoldersRetrieveRequestExpandDrive:
		return "drive"
	case FoldersRetrieveRequestExpandParentFolder:
		return "parent_folder"
	case FoldersRetrieveRequestExpandParentFolderDrive:
		return "parent_folder,drive"
	case FoldersRetrieveRequestExpandPermissions:
		return "permissions"
	case FoldersRetrieveRequestExpandPermissionsDrive:
		return "permissions,drive"
	case FoldersRetrieveRequestExpandPermissionsParentFolder:
		return "permissions,parent_folder"
	case FoldersRetrieveRequestExpandPermissionsParentFolderDrive:
		return "permissions,parent_folder,drive"
	}
}

func (f FoldersRetrieveRequestExpand) MarshalJSON() ([]byte, error) {
	return []byte(fmt.Sprintf("%q", f.String())), nil
}

func (f *FoldersRetrieveRequestExpand) UnmarshalJSON(data []byte) error {
	var raw string
	if err := json.Unmarshal(data, &raw); err != nil {
		return err
	}
	switch raw {
	case "drive":
		value := FoldersRetrieveRequestExpandDrive
		*f = value
	case "parent_folder":
		value := FoldersRetrieveRequestExpandParentFolder
		*f = value
	case "parent_folder,drive":
		value := FoldersRetrieveRequestExpandParentFolderDrive
		*f = value
	case "permissions":
		value := FoldersRetrieveRequestExpandPermissions
		*f = value
	case "permissions,drive":
		value := FoldersRetrieveRequestExpandPermissionsDrive
		*f = value
	case "permissions,parent_folder":
		value := FoldersRetrieveRequestExpandPermissionsParentFolder
		*f = value
	case "permissions,parent_folder,drive":
		value := FoldersRetrieveRequestExpandPermissionsParentFolderDrive
		*f = value
	}
	return nil
}

// # The Group Object
// ### Description
// The `Group` object is used to represent any subset of `User`s. This can extend to company domains as well.
// ### Usage Example
// Fetch from the `GET /api/filestorage/v1/groups` endpoint and view their groups.
type Group struct {
	Id *string `json:"id,omitempty"`
	// The third-party API ID of the matching object.
	RemoteId *string `json:"remote_id,omitempty"`
	// The group's name.
	Name *string `json:"name,omitempty"`
	// The users that belong in the group. If null, this typically means it's either a domain or the third-party platform does not surface this information.
	Users []string `json:"users,omitempty"`
	// Indicates whether or not this object has been deleted by third party webhooks.
	RemoteWasDeleted *bool `json:"remote_was_deleted,omitempty"`
	// This is the datetime that this object was last updated by Merge
	ModifiedAt    *time.Time       `json:"modified_at,omitempty"`
	FieldMappings map[string]any   `json:"field_mappings,omitempty"`
	RemoteData    []map[string]any `json:"remote_data,omitempty"`
}

type Issue struct {
	Id *string `json:"id,omitempty"`
	// Status of the issue. Options: ('ONGOING', 'RESOLVED')
	//
	// * `ONGOING` - ONGOING
	// * `RESOLVED` - RESOLVED
	Status            *IssueStatus   `json:"status,omitempty"`
	ErrorDescription  string         `json:"error_description"`
	EndUser           map[string]any `json:"end_user,omitempty"`
	FirstIncidentTime *time.Time     `json:"first_incident_time,omitempty"`
	LastIncidentTime  *time.Time     `json:"last_incident_time,omitempty"`
	IsMuted           *bool          `json:"is_muted,omitempty"`
	ErrorDetails      []string       `json:"error_details,omitempty"`
}

// Status of the issue. Options: ('ONGOING', 'RESOLVED')
//
// * `ONGOING` - ONGOING
// * `RESOLVED` - RESOLVED
type IssueStatus struct {
	typeName        string
	IssueStatusEnum IssueStatusEnum
	String          string
}

func NewIssueStatusFromIssueStatusEnum(value IssueStatusEnum) *IssueStatus {
	return &IssueStatus{typeName: "issueStatusEnum", IssueStatusEnum: value}
}

func NewIssueStatusFromString(value string) *IssueStatus {
	return &IssueStatus{typeName: "string", String: value}
}

func (i *IssueStatus) UnmarshalJSON(data []byte) error {
	var valueIssueStatusEnum IssueStatusEnum
	if err := json.Unmarshal(data, &valueIssueStatusEnum); err == nil {
		i.typeName = "issueStatusEnum"
		i.IssueStatusEnum = valueIssueStatusEnum
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		i.typeName = "string"
		i.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, i)
}

func (i IssueStatus) MarshalJSON() ([]byte, error) {
	switch i.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", i.typeName, i)
	case "issueStatusEnum":
		return json.Marshal(i.IssueStatusEnum)
	case "string":
		return json.Marshal(i.String)
	}
}

type IssueStatusVisitor interface {
	VisitIssueStatusEnum(IssueStatusEnum) error
	VisitString(string) error
}

func (i *IssueStatus) Accept(visitor IssueStatusVisitor) error {
	switch i.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", i.typeName, i)
	case "issueStatusEnum":
		return visitor.VisitIssueStatusEnum(i.IssueStatusEnum)
	case "string":
		return visitor.VisitString(i.String)
	}
}

// * `ONGOING` - ONGOING
// * `RESOLVED` - RESOLVED
type IssueStatusEnum uint

const (
	IssueStatusEnumOngoing IssueStatusEnum = iota + 1
	IssueStatusEnumResolved
)

func (i IssueStatusEnum) String() string {
	switch i {
	default:
		return strconv.Itoa(int(i))
	case IssueStatusEnumOngoing:
		return "ONGOING"
	case IssueStatusEnumResolved:
		return "RESOLVED"
	}
}

func (i IssueStatusEnum) MarshalJSON() ([]byte, error) {
	return []byte(fmt.Sprintf("%q", i.String())), nil
}

func (i *IssueStatusEnum) UnmarshalJSON(data []byte) error {
	var raw string
	if err := json.Unmarshal(data, &raw); err != nil {
		return err
	}
	switch raw {
	case "ONGOING":
		value := IssueStatusEnumOngoing
		*i = value
	case "RESOLVED":
		value := IssueStatusEnumResolved
		*i = value
	}
	return nil
}

type IssuesListRequestStatus uint

const (
	IssuesListRequestStatusOngoing IssuesListRequestStatus = iota + 1
	IssuesListRequestStatusResolved
)

func (i IssuesListRequestStatus) String() string {
	switch i {
	default:
		return strconv.Itoa(int(i))
	case IssuesListRequestStatusOngoing:
		return "ONGOING"
	case IssuesListRequestStatusResolved:
		return "RESOLVED"
	}
}

func (i IssuesListRequestStatus) MarshalJSON() ([]byte, error) {
	return []byte(fmt.Sprintf("%q", i.String())), nil
}

func (i *IssuesListRequestStatus) UnmarshalJSON(data []byte) error {
	var raw string
	if err := json.Unmarshal(data, &raw); err != nil {
		return err
	}
	switch raw {
	case "ONGOING":
		value := IssuesListRequestStatusOngoing
		*i = value
	case "RESOLVED":
		value := IssuesListRequestStatusResolved
		*i = value
	}
	return nil
}

type LinkToken struct {
	LinkToken       string  `json:"link_token"`
	IntegrationName *string `json:"integration_name,omitempty"`
	MagicLinkUrl    *string `json:"magic_link_url,omitempty"`
}

type LinkedAccountCondition struct {
	// The ID indicating which condition schema to use for a specific condition.
	ConditionSchemaId string `json:"condition_schema_id"`
	// The common model for a specific condition.
	CommonModel *string `json:"common_model,omitempty"`
	// User-facing *native condition* name. e.g. "Skip Manager".
	NativeName *string `json:"native_name,omitempty"`
	// The operator for a specific condition.
	Operator string `json:"operator"`
	Value    *any   `json:"value,omitempty"`
	// The name of the field on the common model that this condition corresponds to, if they conceptually match. e.g. "location_type".
	FieldName *string `json:"field_name,omitempty"`
}

type LinkedAccountConditionRequest struct {
	// The ID indicating which condition schema to use for a specific condition.
	ConditionSchemaId string `json:"condition_schema_id"`
	// The operator for a specific condition. <span style="white-space: nowrap">`non-empty`</span>
	Operator string `json:"operator"`
	Value    any    `json:"value,omitempty"`
}

type LinkedAccountSelectiveSyncConfiguration struct {
	// The conditions belonging to a selective sync.
	LinkedAccountConditions []*LinkedAccountCondition `json:"linked_account_conditions,omitempty"`
}

type LinkedAccountSelectiveSyncConfigurationRequest struct {
	// The conditions belonging to a selective sync.
	LinkedAccountConditions []*LinkedAccountConditionRequest `json:"linked_account_conditions,omitempty"`
}

type LinkedAccountStatus struct {
	LinkedAccountStatus string `json:"linked_account_status"`
	CanMakeRequest      bool   `json:"can_make_request"`
}

type LinkedAccountsListRequestCategory uint

const (
	LinkedAccountsListRequestCategoryAccounting LinkedAccountsListRequestCategory = iota + 1
	LinkedAccountsListRequestCategoryAts
	LinkedAccountsListRequestCategoryCrm
	LinkedAccountsListRequestCategoryFilestorage
	LinkedAccountsListRequestCategoryHris
	LinkedAccountsListRequestCategoryMktg
	LinkedAccountsListRequestCategoryTicketing
)

func (l LinkedAccountsListRequestCategory) String() string {
	switch l {
	default:
		return strconv.Itoa(int(l))
	case LinkedAccountsListRequestCategoryAccounting:
		return "accounting"
	case LinkedAccountsListRequestCategoryAts:
		return "ats"
	case LinkedAccountsListRequestCategoryCrm:
		return "crm"
	case LinkedAccountsListRequestCategoryFilestorage:
		return "filestorage"
	case LinkedAccountsListRequestCategoryHris:
		return "hris"
	case LinkedAccountsListRequestCategoryMktg:
		return "mktg"
	case LinkedAccountsListRequestCategoryTicketing:
		return "ticketing"
	}
}

func (l LinkedAccountsListRequestCategory) MarshalJSON() ([]byte, error) {
	return []byte(fmt.Sprintf("%q", l.String())), nil
}

func (l *LinkedAccountsListRequestCategory) UnmarshalJSON(data []byte) error {
	var raw string
	if err := json.Unmarshal(data, &raw); err != nil {
		return err
	}
	switch raw {
	case "accounting":
		value := LinkedAccountsListRequestCategoryAccounting
		*l = value
	case "ats":
		value := LinkedAccountsListRequestCategoryAts
		*l = value
	case "crm":
		value := LinkedAccountsListRequestCategoryCrm
		*l = value
	case "filestorage":
		value := LinkedAccountsListRequestCategoryFilestorage
		*l = value
	case "hris":
		value := LinkedAccountsListRequestCategoryHris
		*l = value
	case "mktg":
		value := LinkedAccountsListRequestCategoryMktg
		*l = value
	case "ticketing":
		value := LinkedAccountsListRequestCategoryTicketing
		*l = value
	}
	return nil
}

type MetaResponse struct {
	RequestSchema                  map[string]any       `json:"request_schema,omitempty"`
	RemoteFieldClasses             map[string]any       `json:"remote_field_classes,omitempty"`
	Status                         *LinkedAccountStatus `json:"status,omitempty"`
	HasConditionalParams           bool                 `json:"has_conditional_params"`
	HasRequiredLinkedAccountParams bool                 `json:"has_required_linked_account_params"`
}

// * `GET` - GET
// * `OPTIONS` - OPTIONS
// * `HEAD` - HEAD
// * `POST` - POST
// * `PUT` - PUT
// * `PATCH` - PATCH
// * `DELETE` - DELETE
type MethodEnum uint

const (
	MethodEnumGet MethodEnum = iota + 1
	MethodEnumOptions
	MethodEnumHead
	MethodEnumPost
	MethodEnumPut
	MethodEnumPatch
	MethodEnumDelete
)

func (m MethodEnum) String() string {
	switch m {
	default:
		return strconv.Itoa(int(m))
	case MethodEnumGet:
		return "GET"
	case MethodEnumOptions:
		return "OPTIONS"
	case MethodEnumHead:
		return "HEAD"
	case MethodEnumPost:
		return "POST"
	case MethodEnumPut:
		return "PUT"
	case MethodEnumPatch:
		return "PATCH"
	case MethodEnumDelete:
		return "DELETE"
	}
}

func (m MethodEnum) MarshalJSON() ([]byte, error) {
	return []byte(fmt.Sprintf("%q", m.String())), nil
}

func (m *MethodEnum) UnmarshalJSON(data []byte) error {
	var raw string
	if err := json.Unmarshal(data, &raw); err != nil {
		return err
	}
	switch raw {
	case "GET":
		value := MethodEnumGet
		*m = value
	case "OPTIONS":
		value := MethodEnumOptions
		*m = value
	case "HEAD":
		value := MethodEnumHead
		*m = value
	case "POST":
		value := MethodEnumPost
		*m = value
	case "PUT":
		value := MethodEnumPut
		*m = value
	case "PATCH":
		value := MethodEnumPatch
		*m = value
	case "DELETE":
		value := MethodEnumDelete
		*m = value
	}
	return nil
}

// # The ModelOperation Object
// ### Description
// The `ModelOperation` object is used to represent the operations that are currently supported for a given model.
//
// ### Usage Example
// View what operations are supported for the `Candidate` endpoint.
type ModelOperation struct {
	ModelName              string   `json:"model_name"`
	AvailableOperations    []string `json:"available_operations,omitempty"`
	RequiredPostParameters []string `json:"required_post_parameters,omitempty"`
	SupportedFields        []string `json:"supported_fields,omitempty"`
}

// # The MultipartFormField Object
// ### Description
// The `MultipartFormField` object is used to represent fields in an HTTP request using `multipart/form-data`.
//
// ### Usage Example
// Create a `MultipartFormField` to define a multipart form entry.
type MultipartFormFieldRequest struct {
	// The name of the form field <span style="white-space: nowrap">`non-empty`</span>
	Name string `json:"name"`
	// The data for the form field. <span style="white-space: nowrap">`non-empty`</span>
	Data string `json:"data"`
	// The encoding of the value of `data`. Defaults to `RAW` if not defined.
	//
	// * `RAW` - RAW
	// * `BASE64` - BASE64
	// * `GZIP_BASE64` - GZIP_BASE64
	Encoding *MultipartFormFieldRequestEncoding `json:"encoding,omitempty"`
	// The file name of the form field, if the field is for a file.
	FileName *string `json:"file_name,omitempty"`
	// The MIME type of the file, if the field is for a file.
	ContentType *string `json:"content_type,omitempty"`
}

// The encoding of the value of `data`. Defaults to `RAW` if not defined.
//
// * `RAW` - RAW
// * `BASE64` - BASE64
// * `GZIP_BASE64` - GZIP_BASE64
type MultipartFormFieldRequestEncoding struct {
	typeName     string
	EncodingEnum EncodingEnum
	String       string
}

func NewMultipartFormFieldRequestEncodingFromEncodingEnum(value EncodingEnum) *MultipartFormFieldRequestEncoding {
	return &MultipartFormFieldRequestEncoding{typeName: "encodingEnum", EncodingEnum: value}
}

func NewMultipartFormFieldRequestEncodingFromString(value string) *MultipartFormFieldRequestEncoding {
	return &MultipartFormFieldRequestEncoding{typeName: "string", String: value}
}

func (m *MultipartFormFieldRequestEncoding) UnmarshalJSON(data []byte) error {
	var valueEncodingEnum EncodingEnum
	if err := json.Unmarshal(data, &valueEncodingEnum); err == nil {
		m.typeName = "encodingEnum"
		m.EncodingEnum = valueEncodingEnum
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		m.typeName = "string"
		m.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, m)
}

func (m MultipartFormFieldRequestEncoding) MarshalJSON() ([]byte, error) {
	switch m.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", m.typeName, m)
	case "encodingEnum":
		return json.Marshal(m.EncodingEnum)
	case "string":
		return json.Marshal(m.String)
	}
}

type MultipartFormFieldRequestEncodingVisitor interface {
	VisitEncodingEnum(EncodingEnum) error
	VisitString(string) error
}

func (m *MultipartFormFieldRequestEncoding) Accept(visitor MultipartFormFieldRequestEncodingVisitor) error {
	switch m.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", m.typeName, m)
	case "encodingEnum":
		return visitor.VisitEncodingEnum(m.EncodingEnum)
	case "string":
		return visitor.VisitString(m.String)
	}
}

type OperatorSchema struct {
	// The operator for which an operator schema is defined.
	Operator *string `json:"operator,omitempty"`
	// Whether the operator can be repeated multiple times.
	IsUnique *bool `json:"is_unique,omitempty"`
}

type PaginatedAccountDetailsAndActionsList struct {
	Next     *string                     `json:"next,omitempty"`
	Previous *string                     `json:"previous,omitempty"`
	Results  []*AccountDetailsAndActions `json:"results,omitempty"`
}

type PaginatedConditionSchemaList struct {
	Next     *string            `json:"next,omitempty"`
	Previous *string            `json:"previous,omitempty"`
	Results  []*ConditionSchema `json:"results,omitempty"`
}

type PaginatedDriveList struct {
	Next     *string  `json:"next,omitempty"`
	Previous *string  `json:"previous,omitempty"`
	Results  []*Drive `json:"results,omitempty"`
}

type PaginatedFileList struct {
	Next     *string `json:"next,omitempty"`
	Previous *string `json:"previous,omitempty"`
	Results  []*File `json:"results,omitempty"`
}

type PaginatedFolderList struct {
	Next     *string   `json:"next,omitempty"`
	Previous *string   `json:"previous,omitempty"`
	Results  []*Folder `json:"results,omitempty"`
}

type PaginatedGroupList struct {
	Next     *string  `json:"next,omitempty"`
	Previous *string  `json:"previous,omitempty"`
	Results  []*Group `json:"results,omitempty"`
}

type PaginatedIssueList struct {
	Next     *string  `json:"next,omitempty"`
	Previous *string  `json:"previous,omitempty"`
	Results  []*Issue `json:"results,omitempty"`
}

type PaginatedSyncStatusList struct {
	Next     *string       `json:"next,omitempty"`
	Previous *string       `json:"previous,omitempty"`
	Results  []*SyncStatus `json:"results,omitempty"`
}

type PaginatedUserList struct {
	Next     *string `json:"next,omitempty"`
	Previous *string `json:"previous,omitempty"`
	Results  []*User `json:"results,omitempty"`
}

// # The Permission Object
// ### Description
// The Permission object is used to represent a user's or group's access to a File or Folder. Permissions are unexpanded by default.
//
// ### Usage Example
// Fetch from the `GET Files` or `GET Folders` endpoint. Permissions are unexpanded by default. Use the query param `expand=permissions` to see more details.
type Permission struct {
	Id *string `json:"id,omitempty"`
	// The third-party API ID of the matching object.
	RemoteId *string `json:"remote_id,omitempty"`
	// The user that is granted this permission.
	User *string `json:"user,omitempty"`
	// The group that is granted this permission.
	Group *string `json:"group,omitempty"`
	// Denotes what type of people have access to the file.
	//
	// * `USER` - USER
	// * `GROUP` - GROUP
	// * `COMPANY` - COMPANY
	// * `ANYONE` - ANYONE
	Type *TypeEnum `json:"type,omitempty"`
	// The permissions that the user or group has for the File or Folder. It is possible for a user or group to have multiple roles, such as viewing & uploading. Possible values include: `READ`, `WRITE`, `OWNER`. In cases where there is no clear mapping, the original value passed through will be returned.
	Roles []*RolesEnum `json:"roles,omitempty"`
	// This is the datetime that this object was last updated by Merge
	ModifiedAt *time.Time `json:"modified_at,omitempty"`
}

// # The Permission Object
// ### Description
// The Permission object is used to represent a user's or group's access to a File or Folder. Permissions are unexpanded by default.
//
// ### Usage Example
// Fetch from the `GET Files` or `GET Folders` endpoint. Permissions are unexpanded by default. Use the query param `expand=permissions` to see more details.
type PermissionRequest struct {
	// The third-party API ID of the matching object.
	RemoteId *string `json:"remote_id,omitempty"`
	// The user that is granted this permission.
	User *string `json:"user,omitempty"`
	// The group that is granted this permission.
	Group *string `json:"group,omitempty"`
	// Denotes what type of people have access to the file.
	//
	// * `USER` - USER
	// * `GROUP` - GROUP
	// * `COMPANY` - COMPANY
	// * `ANYONE` - ANYONE
	Type *TypeEnum `json:"type,omitempty"`
	// The permissions that the user or group has for the File or Folder. It is possible for a user or group to have multiple roles, such as viewing & uploading. Possible values include: `READ`, `WRITE`, `OWNER`. In cases where there is no clear mapping, the original value passed through will be returned.
	Roles               []*RolesEnum   `json:"roles,omitempty"`
	IntegrationParams   map[string]any `json:"integration_params,omitempty"`
	LinkedAccountParams map[string]any `json:"linked_account_params,omitempty"`
}

// # The RemoteKey Object
// ### Description
// The `RemoteKey` object is used to represent a request for a new remote key.
//
// ### Usage Example
// Post a `GenerateRemoteKey` to receive a new `RemoteKey`.
type RemoteKey struct {
	Name string `json:"name"`
	Key  string `json:"key"`
}

// # The RemoteResponse Object
// ### Description
// The `RemoteResponse` object is used to represent information returned from a third-party endpoint.
//
// ### Usage Example
// View the `RemoteResponse` returned from your `DataPassthrough`.
type RemoteResponse struct {
	Method          string            `json:"method"`
	Path            string            `json:"path"`
	Status          int               `json:"status"`
	Response        any               `json:"response,omitempty"`
	ResponseHeaders map[string]any    `json:"response_headers,omitempty"`
	ResponseType    *ResponseTypeEnum `json:"response_type,omitempty"`
	Headers         map[string]any    `json:"headers,omitempty"`
}

// * `JSON` - JSON
// * `XML` - XML
// * `MULTIPART` - MULTIPART
type RequestFormatEnum uint

const (
	RequestFormatEnumJson RequestFormatEnum = iota + 1
	RequestFormatEnumXml
	RequestFormatEnumMultipart
)

func (r RequestFormatEnum) String() string {
	switch r {
	default:
		return strconv.Itoa(int(r))
	case RequestFormatEnumJson:
		return "JSON"
	case RequestFormatEnumXml:
		return "XML"
	case RequestFormatEnumMultipart:
		return "MULTIPART"
	}
}

func (r RequestFormatEnum) MarshalJSON() ([]byte, error) {
	return []byte(fmt.Sprintf("%q", r.String())), nil
}

func (r *RequestFormatEnum) UnmarshalJSON(data []byte) error {
	var raw string
	if err := json.Unmarshal(data, &raw); err != nil {
		return err
	}
	switch raw {
	case "JSON":
		value := RequestFormatEnumJson
		*r = value
	case "XML":
		value := RequestFormatEnumXml
		*r = value
	case "MULTIPART":
		value := RequestFormatEnumMultipart
		*r = value
	}
	return nil
}

// * `JSON` - JSON
// * `BASE64_GZIP` - BASE64_GZIP
type ResponseTypeEnum uint

const (
	ResponseTypeEnumJson ResponseTypeEnum = iota + 1
	ResponseTypeEnumBase64Gzip
)

func (r ResponseTypeEnum) String() string {
	switch r {
	default:
		return strconv.Itoa(int(r))
	case ResponseTypeEnumJson:
		return "JSON"
	case ResponseTypeEnumBase64Gzip:
		return "BASE64_GZIP"
	}
}

func (r ResponseTypeEnum) MarshalJSON() ([]byte, error) {
	return []byte(fmt.Sprintf("%q", r.String())), nil
}

func (r *ResponseTypeEnum) UnmarshalJSON(data []byte) error {
	var raw string
	if err := json.Unmarshal(data, &raw); err != nil {
		return err
	}
	switch raw {
	case "JSON":
		value := ResponseTypeEnumJson
		*r = value
	case "BASE64_GZIP":
		value := ResponseTypeEnumBase64Gzip
		*r = value
	}
	return nil
}

// * `READ` - READ
// * `WRITE` - WRITE
// * `OWNER` - OWNER
type RolesEnum uint

const (
	RolesEnumRead RolesEnum = iota + 1
	RolesEnumWrite
	RolesEnumOwner
)

func (r RolesEnum) String() string {
	switch r {
	default:
		return strconv.Itoa(int(r))
	case RolesEnumRead:
		return "READ"
	case RolesEnumWrite:
		return "WRITE"
	case RolesEnumOwner:
		return "OWNER"
	}
}

func (r RolesEnum) MarshalJSON() ([]byte, error) {
	return []byte(fmt.Sprintf("%q", r.String())), nil
}

func (r *RolesEnum) UnmarshalJSON(data []byte) error {
	var raw string
	if err := json.Unmarshal(data, &raw); err != nil {
		return err
	}
	switch raw {
	case "READ":
		value := RolesEnumRead
		*r = value
	case "WRITE":
		value := RolesEnumWrite
		*r = value
	case "OWNER":
		value := RolesEnumOwner
		*r = value
	}
	return nil
}

// * `IN_NEXT_SYNC` - IN_NEXT_SYNC
// * `IN_LAST_SYNC` - IN_LAST_SYNC
type SelectiveSyncConfigurationsUsageEnum uint

const (
	SelectiveSyncConfigurationsUsageEnumInNextSync SelectiveSyncConfigurationsUsageEnum = iota + 1
	SelectiveSyncConfigurationsUsageEnumInLastSync
)

func (s SelectiveSyncConfigurationsUsageEnum) String() string {
	switch s {
	default:
		return strconv.Itoa(int(s))
	case SelectiveSyncConfigurationsUsageEnumInNextSync:
		return "IN_NEXT_SYNC"
	case SelectiveSyncConfigurationsUsageEnumInLastSync:
		return "IN_LAST_SYNC"
	}
}

func (s SelectiveSyncConfigurationsUsageEnum) MarshalJSON() ([]byte, error) {
	return []byte(fmt.Sprintf("%q", s.String())), nil
}

func (s *SelectiveSyncConfigurationsUsageEnum) UnmarshalJSON(data []byte) error {
	var raw string
	if err := json.Unmarshal(data, &raw); err != nil {
		return err
	}
	switch raw {
	case "IN_NEXT_SYNC":
		value := SelectiveSyncConfigurationsUsageEnumInNextSync
		*s = value
	case "IN_LAST_SYNC":
		value := SelectiveSyncConfigurationsUsageEnumInLastSync
		*s = value
	}
	return nil
}

// # The SyncStatus Object
// ### Description
// The `SyncStatus` object is used to represent the syncing state of an account
//
// ### Usage Example
// View the `SyncStatus` for an account to see how recently its models were synced.
type SyncStatus struct {
	ModelName                        string                                `json:"model_name"`
	ModelId                          string                                `json:"model_id"`
	LastSyncStart                    *time.Time                            `json:"last_sync_start,omitempty"`
	NextSyncStart                    *time.Time                            `json:"next_sync_start,omitempty"`
	Status                           SyncStatusStatusEnum                  `json:"status,omitempty"`
	IsInitialSync                    bool                                  `json:"is_initial_sync"`
	SelectiveSyncConfigurationsUsage *SelectiveSyncConfigurationsUsageEnum `json:"selective_sync_configurations_usage,omitempty"`
}

// * `SYNCING` - SYNCING
// * `DONE` - DONE
// * `FAILED` - FAILED
// * `DISABLED` - DISABLED
// * `PAUSED` - PAUSED
// * `PARTIALLY_SYNCED` - PARTIALLY_SYNCED
type SyncStatusStatusEnum uint

const (
	SyncStatusStatusEnumSyncing SyncStatusStatusEnum = iota + 1
	SyncStatusStatusEnumDone
	SyncStatusStatusEnumFailed
	SyncStatusStatusEnumDisabled
	SyncStatusStatusEnumPaused
	SyncStatusStatusEnumPartiallySynced
)

func (s SyncStatusStatusEnum) String() string {
	switch s {
	default:
		return strconv.Itoa(int(s))
	case SyncStatusStatusEnumSyncing:
		return "SYNCING"
	case SyncStatusStatusEnumDone:
		return "DONE"
	case SyncStatusStatusEnumFailed:
		return "FAILED"
	case SyncStatusStatusEnumDisabled:
		return "DISABLED"
	case SyncStatusStatusEnumPaused:
		return "PAUSED"
	case SyncStatusStatusEnumPartiallySynced:
		return "PARTIALLY_SYNCED"
	}
}

func (s SyncStatusStatusEnum) MarshalJSON() ([]byte, error) {
	return []byte(fmt.Sprintf("%q", s.String())), nil
}

func (s *SyncStatusStatusEnum) UnmarshalJSON(data []byte) error {
	var raw string
	if err := json.Unmarshal(data, &raw); err != nil {
		return err
	}
	switch raw {
	case "SYNCING":
		value := SyncStatusStatusEnumSyncing
		*s = value
	case "DONE":
		value := SyncStatusStatusEnumDone
		*s = value
	case "FAILED":
		value := SyncStatusStatusEnumFailed
		*s = value
	case "DISABLED":
		value := SyncStatusStatusEnumDisabled
		*s = value
	case "PAUSED":
		value := SyncStatusStatusEnumPaused
		*s = value
	case "PARTIALLY_SYNCED":
		value := SyncStatusStatusEnumPartiallySynced
		*s = value
	}
	return nil
}

// * `USER` - USER
// * `GROUP` - GROUP
// * `COMPANY` - COMPANY
// * `ANYONE` - ANYONE
type TypeEnum uint

const (
	TypeEnumUser TypeEnum = iota + 1
	TypeEnumGroup
	TypeEnumCompany
	TypeEnumAnyone
)

func (t TypeEnum) String() string {
	switch t {
	default:
		return strconv.Itoa(int(t))
	case TypeEnumUser:
		return "USER"
	case TypeEnumGroup:
		return "GROUP"
	case TypeEnumCompany:
		return "COMPANY"
	case TypeEnumAnyone:
		return "ANYONE"
	}
}

func (t TypeEnum) MarshalJSON() ([]byte, error) {
	return []byte(fmt.Sprintf("%q", t.String())), nil
}

func (t *TypeEnum) UnmarshalJSON(data []byte) error {
	var raw string
	if err := json.Unmarshal(data, &raw); err != nil {
		return err
	}
	switch raw {
	case "USER":
		value := TypeEnumUser
		*t = value
	case "GROUP":
		value := TypeEnumGroup
		*t = value
	case "COMPANY":
		value := TypeEnumCompany
		*t = value
	case "ANYONE":
		value := TypeEnumAnyone
		*t = value
	}
	return nil
}

// # The User Object
// ### Description
// The `User` object is used to represent a user within the File Storage account.
// ### Usage Example
// Fetch from the `GET /api/filestorage/v1/users` endpoint and view their users.
type User struct {
	Id *string `json:"id,omitempty"`
	// The third-party API ID of the matching object.
	RemoteId *string `json:"remote_id,omitempty"`
	// The user's name.
	Name *string `json:"name,omitempty"`
	// The user's email address. This is typically used to identify a user across linked accounts.
	EmailAddress *string `json:"email_address,omitempty"`
	// Whether the user is the one who linked this account.
	IsMe *bool `json:"is_me,omitempty"`
	// Indicates whether or not this object has been deleted by third party webhooks.
	RemoteWasDeleted *bool `json:"remote_was_deleted,omitempty"`
	// This is the datetime that this object was last updated by Merge
	ModifiedAt    *time.Time       `json:"modified_at,omitempty"`
	FieldMappings map[string]any   `json:"field_mappings,omitempty"`
	RemoteData    []map[string]any `json:"remote_data,omitempty"`
}

type ValidationProblemSource struct {
	Pointer string `json:"pointer"`
}

type WarningValidationProblem struct {
	Source      *ValidationProblemSource `json:"source,omitempty"`
	Title       string                   `json:"title"`
	Detail      string                   `json:"detail"`
	ProblemType string                   `json:"problem_type"`
}

type WebhookReceiver struct {
	Event    string  `json:"event"`
	IsActive bool    `json:"is_active"`
	Key      *string `json:"key,omitempty"`
}
